{
  "version": 3,
  "sources": ["../../src/matchers/toMatchText.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport { colors } from 'playwright-core/lib/utils';\n\nimport { callLogText, expectTypes } from '../util';\nimport {\n  printReceivedStringContainExpectedResult,\n  printReceivedStringContainExpectedSubstring\n} from './expect';\nimport { kNoElementsFoundError, matcherHint } from './matcherHint';\nimport { EXPECTED_COLOR } from '../common/expectBundle';\nimport { runBrowserBackendOnError } from '../mcp/browser/backend';\n\nimport type { MatcherResult } from './matcherHint';\nimport type { ExpectMatcherState } from '../../types/test';\nimport type { Page, Locator } from 'playwright-core';\n\nexport async function toMatchText(\n  this: ExpectMatcherState,\n  matcherName: string,\n  receiver: Locator | Page,\n  receiverType: 'Locator' | 'Page',\n  query: (isNot: boolean, timeout: number) => Promise<{ matches: boolean, received?: string, log?: string[], timedOut?: boolean }>,\n  expected: string | RegExp,\n  options: { timeout?: number, matchSubstring?: boolean, receiverLabel?: string } = {},\n): Promise<MatcherResult<string | RegExp, string>> {\n  expectTypes(receiver, [receiverType], matcherName);\n\n  const matcherOptions = {\n    isNot: this.isNot,\n    promise: this.promise,\n  };\n\n  if (\n    !(typeof expected === 'string') &&\n    !(expected && typeof expected.test === 'function')\n  ) {\n    // Same format as jest's matcherErrorMessage\n    throw new Error([\n      matcherHint(this, receiverType === 'Locator' ? receiver as Locator : undefined, matcherName, options.receiverLabel ?? receiver, expected, matcherOptions, undefined, undefined, true),\n      `${colors.bold('Matcher error')}: ${EXPECTED_COLOR('expected',)} value must be a string or regular expression`,\n      this.utils.printWithType('Expected', expected, this.utils.printExpected)\n    ].join('\\n\\n'));\n  }\n\n  const timeout = options.timeout ?? this.timeout;\n\n  const { matches: pass, received, log, timedOut } = await query(!!this.isNot, timeout).catch(async error => {\n    // FIXME: query should not throw, but it does for strict mode violations for example.\n    if (receiverType === 'Locator')\n      await runBrowserBackendOnError((receiver as Locator).page(), () => error.message);\n    throw error;\n  });\n\n  if (pass === !this.isNot) {\n    return {\n      name: matcherName,\n      message: () => '',\n      pass,\n      expected\n    };\n  }\n\n  const stringSubstring = options.matchSubstring ? 'substring' : 'string';\n  const receivedString = received || '';\n  const notFound = received === kNoElementsFoundError;\n\n  let printedReceived: string | undefined;\n  let printedExpected: string | undefined;\n  let printedDiff: string | undefined;\n  if (pass) {\n    if (typeof expected === 'string') {\n      if (notFound) {\n        printedExpected = `Expected ${stringSubstring}: not ${this.utils.printExpected(expected)}`;\n        printedReceived = `Received: ${received}`;\n      } else {\n        printedExpected = `Expected ${stringSubstring}: not ${this.utils.printExpected(expected)}`;\n        const formattedReceived = printReceivedStringContainExpectedSubstring(receivedString, receivedString.indexOf(expected), expected.length);\n        printedReceived = `Received string: ${formattedReceived}`;\n      }\n    } else {\n      if (notFound) {\n        printedExpected = `Expected pattern: not ${this.utils.printExpected(expected)}`;\n        printedReceived = `Received: ${received}`;\n      } else {\n        printedExpected = `Expected pattern: not ${this.utils.printExpected(expected)}`;\n        const formattedReceived = printReceivedStringContainExpectedResult(receivedString, typeof expected.exec === 'function' ? expected.exec(receivedString) : null);\n        printedReceived = `Received string: ${formattedReceived}`;\n      }\n    }\n  } else {\n    const labelExpected = `Expected ${typeof expected === 'string' ? stringSubstring : 'pattern'}`;\n    if (notFound) {\n      printedExpected = `${labelExpected}: ${this.utils.printExpected(expected)}`;\n      printedReceived = `Received: ${received}`;\n    } else {\n      printedDiff = this.utils.printDiffOrStringify(expected, receivedString, labelExpected, 'Received string', false);\n    }\n  }\n\n  const message = () => {\n    const resultDetails = printedDiff ? printedDiff : printedExpected + '\\n' + printedReceived;\n    const hints = matcherHint(this, receiverType === 'Locator' ? receiver as Locator : undefined, matcherName, options.receiverLabel ?? 'locator', undefined, matcherOptions, timedOut ? timeout : undefined, resultDetails, true);\n    return hints + callLogText(log);\n  };\n\n  if (receiverType === 'Locator')\n    await runBrowserBackendOnError((receiver as Locator).page(), message);\n\n  return {\n    name: matcherName,\n    expected,\n    message,\n    pass,\n    actual: received,\n    log,\n    timeout: timedOut ? timeout : undefined,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}

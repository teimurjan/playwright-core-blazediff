{
  "version": 3,
  "sources": ["../../src/matchers/toMatchAriaSnapshot.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { escapeTemplateString, isString } from 'playwright-core/lib/utils';\n\nimport {  kNoElementsFoundError, matcherHint } from './matcherHint';\nimport { EXPECTED_COLOR } from '../common/expectBundle';\nimport { callLogText, fileExistsAsync } from '../util';\nimport { printReceivedStringContainExpectedSubstring } from './expect';\nimport { currentTestInfo } from '../common/globals';\n\nimport type { MatcherResult } from './matcherHint';\nimport type { LocatorEx } from './matchers';\nimport type { ExpectMatcherState } from '../../types/test';\nimport type { MatcherReceived } from '@injected/ariaSnapshot';\n\n\ntype ToMatchAriaSnapshotExpected = {\n  name?: string;\n  path?: string;\n  timeout?: number;\n} | string;\n\nexport async function toMatchAriaSnapshot(\n  this: ExpectMatcherState,\n  receiver: LocatorEx,\n  expectedParam?: ToMatchAriaSnapshotExpected,\n  options: { timeout?: number } = {},\n): Promise<MatcherResult<string | RegExp, string>> {\n  const matcherName = 'toMatchAriaSnapshot';\n\n  const testInfo = currentTestInfo();\n  if (!testInfo)\n    throw new Error(`toMatchAriaSnapshot() must be called during the test`);\n\n  if (testInfo._projectInternal.ignoreSnapshots)\n    return { pass: !this.isNot, message: () => '', name: 'toMatchAriaSnapshot', expected: '' };\n\n  const updateSnapshots = testInfo.config.updateSnapshots;\n\n  const matcherOptions = {\n    isNot: this.isNot,\n    promise: this.promise,\n  };\n\n  let expected: string;\n  let timeout: number;\n  let expectedPath: string | undefined;\n  if (isString(expectedParam)) {\n    expected = expectedParam;\n    timeout = options.timeout ?? this.timeout;\n  } else {\n    const legacyPath = testInfo._resolveSnapshotPaths('aria', expectedParam?.name, 'dontUpdateSnapshotIndex', '.yml').absoluteSnapshotPath;\n    expectedPath = testInfo._resolveSnapshotPaths('aria', expectedParam?.name, 'updateSnapshotIndex').absoluteSnapshotPath;\n    // in 1.51, we changed the default template to use .aria.yml extension\n    // for backwards compatibility, we check for the legacy .yml extension\n    if (!(await fileExistsAsync(expectedPath)) && await fileExistsAsync(legacyPath))\n      expectedPath = legacyPath;\n    expected = await fs.promises.readFile(expectedPath, 'utf8').catch(() => '');\n    timeout = expectedParam?.timeout ?? this.timeout;\n  }\n\n  const generateMissingBaseline = updateSnapshots === 'missing' && !expected;\n  if (generateMissingBaseline) {\n    if (this.isNot) {\n      const message = `Matchers using \".not\" can't generate new baselines`;\n      return { pass: this.isNot, message: () => message, name: 'toMatchAriaSnapshot' };\n    } else {\n      // When generating new baseline, run entire pipeline against impossible match.\n      expected = `- none \"Generating new baseline\"`;\n    }\n  }\n\n  expected = unshift(expected);\n  const { matches: pass, received, log, timedOut } = await receiver._expect('to.match.aria', { expectedValue: expected, isNot: this.isNot, timeout });\n  const typedReceived = received as MatcherReceived | typeof kNoElementsFoundError;\n\n  const matcherHintWithExpect = (expectedReceivedString: string) => {\n    return matcherHint(this, receiver, matcherName, 'locator', undefined, matcherOptions, timedOut ? timeout : undefined, expectedReceivedString);\n  };\n\n  const notFound = typedReceived === kNoElementsFoundError;\n  if (notFound) {\n    return {\n      pass: this.isNot,\n      message: () => matcherHintWithExpect(`Expected: ${this.utils.printExpected(expected)}\\nReceived: ${EXPECTED_COLOR('<element not found>')}`) + callLogText(log),\n      name: 'toMatchAriaSnapshot',\n      expected,\n    };\n  }\n\n  const receivedText = typedReceived.raw;\n  const message = () => {\n    if (pass) {\n      const receivedString = notFound ? receivedText : printReceivedStringContainExpectedSubstring(receivedText, receivedText.indexOf(expected), expected.length);\n      const expectedReceivedString = `Expected: not ${this.utils.printExpected(expected)}\\nReceived: ${receivedString}`;\n      return matcherHintWithExpect(expectedReceivedString) + callLogText(log);\n    } else {\n      const labelExpected = `Expected`;\n      const expectedReceivedString = notFound ? `${labelExpected}: ${this.utils.printExpected(expected)}\\nReceived: ${receivedText}` : this.utils.printDiffOrStringify(expected, receivedText, labelExpected, 'Received', false);\n      return matcherHintWithExpect(expectedReceivedString) + callLogText(log);\n    }\n  };\n\n  if (!this.isNot) {\n    if ((updateSnapshots === 'all') ||\n        (updateSnapshots === 'changed' && pass === this.isNot) ||\n        generateMissingBaseline) {\n      if (expectedPath) {\n        await fs.promises.mkdir(path.dirname(expectedPath), { recursive: true });\n        await fs.promises.writeFile(expectedPath, typedReceived.regex, 'utf8');\n        const relativePath = path.relative(process.cwd(), expectedPath);\n        if (updateSnapshots === 'missing') {\n          const message = `A snapshot doesn't exist at ${relativePath}, writing actual.`;\n          testInfo._hasNonRetriableError = true;\n          testInfo._failWithError(new Error(message));\n        } else {\n          const message = `A snapshot is generated at ${relativePath}.`;\n          /* eslint-disable no-console */\n          console.log(message);\n        }\n        return { pass: true, message: () => '', name: 'toMatchAriaSnapshot' };\n      } else {\n        const suggestedRebaseline = `\\`\\n${escapeTemplateString(indent(typedReceived.regex, '{indent}  '))}\\n{indent}\\``;\n        if (updateSnapshots === 'missing') {\n          const message = 'A snapshot is not provided, generating new baseline.';\n          testInfo._hasNonRetriableError = true;\n          testInfo._failWithError(new Error(message));\n        }\n        // TODO: ideally, we should return \"pass: true\" here because this matcher passes\n        // when regenerating baselines. However, we can only access suggestedRebaseline in case\n        // of an error, so we fail here and workaround it in the expect implementation.\n        return { pass: false, message: () => '', name: 'toMatchAriaSnapshot', suggestedRebaseline };\n      }\n    }\n  }\n\n  return {\n    name: matcherName,\n    expected,\n    message,\n    pass,\n    actual: received,\n    log,\n    timeout: timedOut ? timeout : undefined,\n  };\n}\n\nfunction unshift(snapshot: string): string {\n  const lines = snapshot.split('\\n');\n  let whitespacePrefixLength = 100;\n  for (const line of lines) {\n    if (!line.trim())\n      continue;\n    const match = line.match(/^(\\s*)/);\n    if (match && match[1].length < whitespacePrefixLength)\n      whitespacePrefixLength = match[1].length;\n  }\n  return lines.filter(t => t.trim()).map(line => line.substring(whitespacePrefixLength)).join('\\n');\n}\n\nfunction indent(snapshot: string, indent: string): string {\n  return snapshot.split('\\n').map(line => indent + line).join('\\n');\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,gBAAe;AACf,kBAAiB;AAEjB,mBAA+C;AAE/C,yBAAoD;AACpD,0BAA+B;AAC/B,kBAA6C;AAC7C,oBAA4D;AAC5D,qBAAgC;AAchC,eAAsB,oBAEpB,UACA,eACA,UAAgC,CAAC,GACgB;AACjD,QAAM,cAAc;AAEpB,QAAM,eAAW,gCAAgB;AACjC,MAAI,CAAC;AACH,UAAM,IAAI,MAAM,sDAAsD;AAExE,MAAI,SAAS,iBAAiB;AAC5B,WAAO,EAAE,MAAM,CAAC,KAAK,OAAO,SAAS,MAAM,IAAI,MAAM,uBAAuB,UAAU,GAAG;AAE3F,QAAM,kBAAkB,SAAS,OAAO;AAExC,QAAM,iBAAiB;AAAA,IACrB,OAAO,KAAK;AAAA,IACZ,SAAS,KAAK;AAAA,EAChB;AAEA,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,UAAI,uBAAS,aAAa,GAAG;AAC3B,eAAW;AACX,cAAU,QAAQ,WAAW,KAAK;AAAA,EACpC,OAAO;AACL,UAAM,aAAa,SAAS,sBAAsB,QAAQ,eAAe,MAAM,2BAA2B,MAAM,EAAE;AAClH,mBAAe,SAAS,sBAAsB,QAAQ,eAAe,MAAM,qBAAqB,EAAE;AAGlG,QAAI,CAAE,UAAM,6BAAgB,YAAY,KAAM,UAAM,6BAAgB,UAAU;AAC5E,qBAAe;AACjB,eAAW,MAAM,UAAAA,QAAG,SAAS,SAAS,cAAc,MAAM,EAAE,MAAM,MAAM,EAAE;AAC1E,cAAU,eAAe,WAAW,KAAK;AAAA,EAC3C;AAEA,QAAM,0BAA0B,oBAAoB,aAAa,CAAC;AAClE,MAAI,yBAAyB;AAC3B,QAAI,KAAK,OAAO;AACd,YAAMC,WAAU;AAChB,aAAO,EAAE,MAAM,KAAK,OAAO,SAAS,MAAMA,UAAS,MAAM,sBAAsB;AAAA,IACjF,OAAO;AAEL,iBAAW;AAAA,IACb;AAAA,EACF;AAEA,aAAW,QAAQ,QAAQ;AAC3B,QAAM,EAAE,SAAS,MAAM,UAAU,KAAK,SAAS,IAAI,MAAM,SAAS,QAAQ,iBAAiB,EAAE,eAAe,UAAU,OAAO,KAAK,OAAO,QAAQ,CAAC;AAClJ,QAAM,gBAAgB;AAEtB,QAAM,wBAAwB,CAAC,2BAAmC;AAChE,eAAO,gCAAY,MAAM,UAAU,aAAa,WAAW,QAAW,gBAAgB,WAAW,UAAU,QAAW,sBAAsB;AAAA,EAC9I;AAEA,QAAM,WAAW,kBAAkB;AACnC,MAAI,UAAU;AACZ,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,MAAM,sBAAsB,aAAa,KAAK,MAAM,cAAc,QAAQ,CAAC;AAAA,gBAAe,oCAAe,qBAAqB,CAAC,EAAE,QAAI,yBAAY,GAAG;AAAA,MAC7J,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAEA,QAAM,eAAe,cAAc;AACnC,QAAM,UAAU,MAAM;AACpB,QAAI,MAAM;AACR,YAAM,iBAAiB,WAAW,mBAAe,2DAA4C,cAAc,aAAa,QAAQ,QAAQ,GAAG,SAAS,MAAM;AAC1J,YAAM,yBAAyB,iBAAiB,KAAK,MAAM,cAAc,QAAQ,CAAC;AAAA,YAAe,cAAc;AAC/G,aAAO,sBAAsB,sBAAsB,QAAI,yBAAY,GAAG;AAAA,IACxE,OAAO;AACL,YAAM,gBAAgB;AACtB,YAAM,yBAAyB,WAAW,GAAG,aAAa,KAAK,KAAK,MAAM,cAAc,QAAQ,CAAC;AAAA,YAAe,YAAY,KAAK,KAAK,MAAM,qBAAqB,UAAU,cAAc,eAAe,YAAY,KAAK;AACzN,aAAO,sBAAsB,sBAAsB,QAAI,yBAAY,GAAG;AAAA,IACxE;AAAA,EACF;AAEA,MAAI,CAAC,KAAK,OAAO;AACf,QAAK,oBAAoB,SACpB,oBAAoB,aAAa,SAAS,KAAK,SAChD,yBAAyB;AAC3B,UAAI,cAAc;AAChB,cAAM,UAAAD,QAAG,SAAS,MAAM,YAAAE,QAAK,QAAQ,YAAY,GAAG,EAAE,WAAW,KAAK,CAAC;AACvE,cAAM,UAAAF,QAAG,SAAS,UAAU,cAAc,cAAc,OAAO,MAAM;AACrE,cAAM,eAAe,YAAAE,QAAK,SAAS,QAAQ,IAAI,GAAG,YAAY;AAC9D,YAAI,oBAAoB,WAAW;AACjC,gBAAMD,WAAU,+BAA+B,YAAY;AAC3D,mBAAS,wBAAwB;AACjC,mBAAS,eAAe,IAAI,MAAMA,QAAO,CAAC;AAAA,QAC5C,OAAO;AACL,gBAAMA,WAAU,8BAA8B,YAAY;AAE1D,kBAAQ,IAAIA,QAAO;AAAA,QACrB;AACA,eAAO,EAAE,MAAM,MAAM,SAAS,MAAM,IAAI,MAAM,sBAAsB;AAAA,MACtE,OAAO;AACL,cAAM,sBAAsB;AAAA,MAAO,mCAAqB,OAAO,cAAc,OAAO,YAAY,CAAC,CAAC;AAAA;AAClG,YAAI,oBAAoB,WAAW;AACjC,gBAAMA,WAAU;AAChB,mBAAS,wBAAwB;AACjC,mBAAS,eAAe,IAAI,MAAMA,QAAO,CAAC;AAAA,QAC5C;AAIA,eAAO,EAAE,MAAM,OAAO,SAAS,MAAM,IAAI,MAAM,uBAAuB,oBAAoB;AAAA,MAC5F;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA,SAAS,WAAW,UAAU;AAAA,EAChC;AACF;AAEA,SAAS,QAAQ,UAA0B;AACzC,QAAM,QAAQ,SAAS,MAAM,IAAI;AACjC,MAAI,yBAAyB;AAC7B,aAAW,QAAQ,OAAO;AACxB,QAAI,CAAC,KAAK,KAAK;AACb;AACF,UAAM,QAAQ,KAAK,MAAM,QAAQ;AACjC,QAAI,SAAS,MAAM,CAAC,EAAE,SAAS;AAC7B,+BAAyB,MAAM,CAAC,EAAE;AAAA,EACtC;AACA,SAAO,MAAM,OAAO,OAAK,EAAE,KAAK,CAAC,EAAE,IAAI,UAAQ,KAAK,UAAU,sBAAsB,CAAC,EAAE,KAAK,IAAI;AAClG;AAEA,SAAS,OAAO,UAAkBE,SAAwB;AACxD,SAAO,SAAS,MAAM,IAAI,EAAE,IAAI,UAAQA,UAAS,IAAI,EAAE,KAAK,IAAI;AAClE;",
  "names": ["fs", "message", "path", "indent"]
}

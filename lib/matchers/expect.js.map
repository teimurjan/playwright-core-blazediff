{
  "version": 3,
  "sources": ["../../src/matchers/expect.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  captureRawStack,\n  createGuid,\n  currentZone,\n  escapeWithQuotes,\n  isString,\n  pollAgainstDeadline } from 'playwright-core/lib/utils';\n\nimport { ExpectError, isJestError } from './matcherHint';\nimport {\n  toBeAttached,\n  toBeChecked,\n  toBeDisabled,\n  toBeEditable,\n  toBeEmpty,\n  toBeEnabled,\n  toBeFocused,\n  toBeHidden,\n  toBeInViewport,\n  toBeOK,\n  toBeVisible,\n  toContainClass,\n  toContainText,\n  toHaveAccessibleDescription,\n  toHaveAccessibleErrorMessage,\n  toHaveAccessibleName,\n  toHaveAttribute,\n  toHaveCSS,\n  toHaveClass,\n  toHaveCount,\n  toHaveId,\n  toHaveJSProperty,\n  toHaveRole,\n  toHaveText,\n  toHaveTitle,\n  toHaveURL,\n  toHaveValue,\n  toHaveValues,\n  toPass\n} from './matchers';\nimport { toMatchAriaSnapshot } from './toMatchAriaSnapshot';\nimport { toHaveScreenshot, toHaveScreenshotStepTitle, toMatchSnapshot } from './toMatchSnapshot';\nimport {\n  INVERTED_COLOR,\n  RECEIVED_COLOR,\n  expect as expectLibrary,\n  printReceived,\n} from '../common/expectBundle';\nimport { currentTestInfo } from '../common/globals';\nimport { filteredStackTrace } from '../util';\nimport { TestInfoImpl } from '../worker/testInfo';\n\nimport type { ExpectMatcherStateInternal } from './matchers';\nimport type { Expect } from '../../types/test';\nimport type { TestStepCategory, TestStepInfoImpl } from '../worker/testInfo';\n\n\n// #region\n// Mirrored from https://github.com/facebook/jest/blob/f13abff8df9a0e1148baf3584bcde6d1b479edc7/packages/expect/src/print.ts\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found here\n * https://github.com/facebook/jest/blob/1547740bbc26400d69f4576bf35645163e942829/LICENSE\n */\n\n// Format substring but do not enclose in double quote marks.\n// The replacement is compatible with pretty-format package.\nconst printSubstring = (val: string): string => val.replace(/\"|\\\\/g, '\\\\$&');\n\nexport const printReceivedStringContainExpectedSubstring = (\n  received: string,\n  start: number,\n  length: number, // not end\n): string =>\n  RECEIVED_COLOR(\n      '\"' +\n      printSubstring(received.slice(0, start)) +\n      INVERTED_COLOR(printSubstring(received.slice(start, start + length))) +\n      printSubstring(received.slice(start + length)) +\n      '\"',\n  );\n\nexport const printReceivedStringContainExpectedResult = (\n  received: string,\n  result: RegExpExecArray | null,\n): string =>\n  result === null\n    ? printReceived(received)\n    : printReceivedStringContainExpectedSubstring(\n        received,\n        result.index,\n        result[0].length,\n    );\n\n// #endregion\n\ntype ExpectMessage = string | { message?: string };\n\nfunction createMatchers(actual: unknown, info: ExpectMetaInfo, prefix: string[]): any {\n  return new Proxy(expectLibrary(actual), new ExpectMetaInfoProxyHandler(info, prefix));\n}\n\nconst userMatchersSymbol = Symbol('userMatchers');\n\nfunction qualifiedMatcherName(qualifier: string[], matcherName: string) {\n  return qualifier.join(':') + '$' + matcherName;\n}\n\nfunction createExpect(info: ExpectMetaInfo, prefix: string[], userMatchers: Record<string, Function>) {\n  const expectInstance: Expect<{}> = new Proxy(expectLibrary, {\n    apply: function(target: any, thisArg: any, argumentsList: [unknown, ExpectMessage?]) {\n      const [actual, messageOrOptions] = argumentsList;\n      const message = isString(messageOrOptions) ? messageOrOptions : messageOrOptions?.message || info.message;\n      const newInfo = { ...info, message };\n      if (newInfo.poll) {\n        if (typeof actual !== 'function')\n          throw new Error('`expect.poll()` accepts only function as a first argument');\n        newInfo.poll.generator = actual as any;\n      }\n      return createMatchers(actual, newInfo, prefix);\n    },\n\n    get: function(target: any, property: string | typeof userMatchersSymbol) {\n      if (property === 'configure')\n        return configure;\n\n      if (property === 'extend') {\n        return (matchers: any) => {\n          const qualifier = [...prefix, createGuid()];\n\n          const wrappedMatchers: any = {};\n          for (const [name, matcher] of Object.entries(matchers)) {\n            wrappedMatchers[name] = wrapPlaywrightMatcherToPassNiceThis(matcher);\n            const key = qualifiedMatcherName(qualifier, name);\n            wrappedMatchers[key] = wrappedMatchers[name];\n            Object.defineProperty(wrappedMatchers[key], 'name', { value: name });\n          }\n          expectLibrary.extend(wrappedMatchers);\n          return createExpect(info, qualifier, { ...userMatchers, ...matchers });\n        };\n      }\n\n      if (property === 'soft') {\n        return (actual: unknown, messageOrOptions?: ExpectMessage) => {\n          return configure({ soft: true })(actual, messageOrOptions) as any;\n        };\n      }\n\n      if (property === userMatchersSymbol)\n        return userMatchers;\n\n      if (property === 'poll') {\n        return (actual: unknown, messageOrOptions?: ExpectMessage & { timeout?: number, intervals?: number[] }) => {\n          const poll = isString(messageOrOptions) ? {} : messageOrOptions || {};\n          return configure({ _poll: poll })(actual, messageOrOptions) as any;\n        };\n      }\n      return (expectLibrary as any)[property];\n    },\n  });\n\n  const configure = (configuration: { message?: string, timeout?: number, soft?: boolean, _poll?: boolean | { timeout?: number, intervals?: number[] } }) => {\n    const newInfo = { ...info };\n    if ('message' in configuration)\n      newInfo.message = configuration.message;\n    if ('timeout' in configuration)\n      newInfo.timeout = configuration.timeout;\n    if ('soft' in configuration)\n      newInfo.isSoft = configuration.soft;\n    if ('_poll' in configuration) {\n      newInfo.poll = configuration._poll ? { ...info.poll, generator: () => {} } : undefined;\n      if (typeof configuration._poll === 'object') {\n        newInfo.poll!.timeout = configuration._poll.timeout ?? newInfo.poll!.timeout;\n        newInfo.poll!.intervals = configuration._poll.intervals ?? newInfo.poll!.intervals;\n      }\n    }\n    return createExpect(newInfo, prefix, userMatchers);\n  };\n\n  return expectInstance;\n}\n\n// Expect wraps matchers, so there is no way to pass this information to the raw Playwright matcher.\n// Rely on sync call sequence to seed each matcher call with the context.\ntype MatcherCallContext = {\n  expectInfo: ExpectMetaInfo;\n  testInfo: TestInfoImpl | null;\n  step?: TestStepInfoImpl;\n};\n\nlet matcherCallContext: MatcherCallContext | undefined;\n\nfunction setMatcherCallContext(context: MatcherCallContext) {\n  matcherCallContext = context;\n}\n\nfunction takeMatcherCallContext(): MatcherCallContext | undefined {\n  try {\n    return matcherCallContext;\n  } finally {\n    // Any subsequent matcher following the first is assumed to be an unsupported legacy asymmetric matcher.\n    // Lacking call context in these scenarios is not particularly important.\n    matcherCallContext = undefined;\n  }\n}\n\nconst defaultExpectTimeout = 5000;\n\nfunction wrapPlaywrightMatcherToPassNiceThis(matcher: any) {\n  return function(this: any, ...args: any[]) {\n    const { isNot, promise, utils } = this;\n    const context = takeMatcherCallContext();\n    const timeout = context?.expectInfo.timeout ?? context?.testInfo?._projectInternal?.expect?.timeout ?? defaultExpectTimeout;\n    const newThis: ExpectMatcherStateInternal = {\n      isNot,\n      promise,\n      utils,\n      timeout,\n      _stepInfo: context?.step,\n    };\n    (newThis as any).equals = throwUnsupportedExpectMatcherError;\n    return matcher.call(newThis, ...args);\n  };\n}\n\nfunction throwUnsupportedExpectMatcherError() {\n  throw new Error('It looks like you are using custom expect matchers that are not compatible with Playwright. See https://aka.ms/playwright/expect-compatibility');\n}\n\nexpectLibrary.setState({ expand: false });\n\nconst customAsyncMatchers = {\n  toBeAttached,\n  toBeChecked,\n  toBeDisabled,\n  toBeEditable,\n  toBeEmpty,\n  toBeEnabled,\n  toBeFocused,\n  toBeHidden,\n  toBeInViewport,\n  toBeOK,\n  toBeVisible,\n  toContainText,\n  toContainClass,\n  toHaveAccessibleDescription,\n  toHaveAccessibleName,\n  toHaveAccessibleErrorMessage,\n  toHaveAttribute,\n  toHaveClass,\n  toHaveCount,\n  toHaveCSS,\n  toHaveId,\n  toHaveJSProperty,\n  toHaveRole,\n  toHaveText,\n  toHaveTitle,\n  toHaveURL,\n  toHaveValue,\n  toHaveValues,\n  toHaveScreenshot,\n  toMatchAriaSnapshot,\n  toPass,\n};\n\nconst customMatchers = {\n  ...customAsyncMatchers,\n  toMatchSnapshot,\n};\n\ntype Generator = () => any;\n\ntype ExpectMetaInfo = {\n  message?: string;\n  isNot?: boolean;\n  isSoft?: boolean;\n  poll?: {\n    timeout?: number;\n    intervals?: number[];\n    generator: Generator;\n  };\n  timeout?: number;\n};\n\nclass ExpectMetaInfoProxyHandler implements ProxyHandler<any> {\n  private _info: ExpectMetaInfo;\n  private _prefix: string[];\n\n  constructor(info: ExpectMetaInfo, prefix: string[]) {\n    this._info = { ...info };\n    this._prefix = prefix;\n  }\n\n  get(target: Object, matcherName: string | symbol, receiver: any): any {\n    let matcher = Reflect.get(target, matcherName, receiver);\n    if (typeof matcherName !== 'string')\n      return matcher;\n\n    let resolvedMatcherName = matcherName;\n    for (let i = this._prefix.length; i > 0; i--) {\n      const qualifiedName = qualifiedMatcherName(this._prefix.slice(0, i), matcherName);\n      if (Reflect.has(target, qualifiedName)) {\n        matcher = Reflect.get(target, qualifiedName, receiver);\n        resolvedMatcherName = qualifiedName;\n        break;\n      }\n    }\n\n    if (matcher === undefined)\n      throw new Error(`expect: Property '${matcherName}' not found.`);\n    if (typeof matcher !== 'function') {\n      if (matcherName === 'not')\n        this._info.isNot = !this._info.isNot;\n      return new Proxy(matcher, this);\n    }\n    if (this._info.poll) {\n      if ((customAsyncMatchers as any)[matcherName] || matcherName === 'resolves' || matcherName === 'rejects')\n        throw new Error(`\\`expect.poll()\\` does not support \"${matcherName}\" matcher.`);\n      matcher = (...args: any[]) => pollMatcher(resolvedMatcherName, this._info, this._prefix, ...args);\n    }\n    return (...args: any[]) => {\n      const testInfo = currentTestInfo();\n      setMatcherCallContext({ expectInfo: this._info, testInfo });\n      if (!testInfo)\n        return matcher.call(target, ...args);\n\n      const customMessage = this._info.message || '';\n      const argsSuffix = computeArgsSuffix(matcherName, args);\n\n      const defaultTitle = `${this._info.poll ? 'poll ' : ''}${this._info.isSoft ? 'soft ' : ''}${this._info.isNot ? 'not ' : ''}${matcherName}${argsSuffix}`;\n      const title = customMessage || `Expect ${escapeWithQuotes(defaultTitle, '\"')}`;\n      const apiName = `expect${this._info.poll ? '.poll ' : ''}${this._info.isSoft ? '.soft ' : ''}${this._info.isNot ? '.not' : ''}.${matcherName}${argsSuffix}`;\n\n      // This looks like it is unnecessary, but it isn't - we need to filter\n      // out all the frames that belong to the test runner from caught runtime errors.\n      const stackFrames = filteredStackTrace(captureRawStack());\n      const category = matcherName === 'toPass' || this._info.poll ? 'test.step' : 'expect' as TestStepCategory;\n\n      // toPass and poll matchers can contain other steps, expects and API calls,\n      // so they behave like a retriable step.\n      const stepInfo = {\n        category,\n        apiName,\n        title,\n        params: args[0] ? { expected: args[0] } : undefined,\n        infectParentStepsWithError: this._info.isSoft,\n      };\n\n      const step = testInfo._addStep(stepInfo);\n\n      const reportStepError = (e: Error | unknown) => {\n        const jestError = isJestError(e) ? e : null;\n        const expectError = jestError ? new ExpectError(jestError, customMessage, stackFrames) : undefined;\n        if (jestError?.matcherResult.suggestedRebaseline) {\n          // NOTE: this is a workaround for the fact that we can't pass the suggested rebaseline\n          // for passing matchers. See toMatchAriaSnapshot for a counterpart.\n          step.complete({ suggestedRebaseline: jestError?.matcherResult.suggestedRebaseline });\n          return;\n        }\n\n        const error = expectError ?? e;\n        step.complete({ error });\n\n        if (this._info.isSoft)\n          testInfo._failWithError(error);\n        else\n          throw error;\n      };\n\n      const finalizer = () => {\n        step.complete({});\n      };\n\n      try {\n        setMatcherCallContext({ expectInfo: this._info, testInfo, step: step.info });\n        const callback = () => matcher.call(target, ...args);\n        const result = currentZone().with('stepZone', step).run(callback);\n        if (result instanceof Promise)\n          return result.then(finalizer).catch(reportStepError);\n        finalizer();\n        return result;\n      } catch (e) {\n        void reportStepError(e);\n      }\n    };\n  }\n}\n\nasync function pollMatcher(qualifiedMatcherName: string, info: ExpectMetaInfo, prefix: string[], ...args: any[]) {\n  const testInfo = currentTestInfo();\n  const poll = info.poll!;\n  const timeout = poll.timeout ?? info.timeout ?? testInfo?._projectInternal?.expect?.timeout ?? defaultExpectTimeout;\n  const { deadline, timeoutMessage } = testInfo ? testInfo._deadlineForMatcher(timeout) : TestInfoImpl._defaultDeadlineForMatcher(timeout);\n\n  const result = await pollAgainstDeadline<Error|undefined>(async () => {\n    if (testInfo && currentTestInfo() !== testInfo)\n      return { continuePolling: false, result: undefined };\n\n    const innerInfo: ExpectMetaInfo = {\n      ...info,\n      isSoft: false, // soft is outside of poll, not inside\n      poll: undefined,\n    };\n    const value = await poll.generator();\n    try {\n      let matchers = createMatchers(value, innerInfo, prefix);\n      if (info.isNot)\n        matchers = matchers.not;\n      matchers[qualifiedMatcherName](...args);\n      return { continuePolling: false, result: undefined };\n    } catch (error) {\n      return { continuePolling: true, result: error };\n    }\n  }, deadline, poll.intervals ?? [100, 250, 500, 1000]);\n\n  if (result.timedOut) {\n    const message = result.result ? [\n      result.result.message,\n      '',\n      `Call Log:`,\n      `- ${timeoutMessage}`,\n    ].join('\\n') : timeoutMessage;\n\n    throw new Error(message);\n  }\n}\n\nfunction computeArgsSuffix(matcherName: string, args: any[]) {\n  let value = '';\n  if (matcherName === 'toHaveScreenshot')\n    value = toHaveScreenshotStepTitle(...args);\n  return value ? `(${value})` : '';\n}\n\nexport const expect: Expect<{}> = createExpect({}, [], {}).extend(customMatchers);\n\nexport function mergeExpects(...expects: any[]) {\n  let merged = expect;\n  for (const e of expects) {\n    const internals = e[userMatchersSymbol];\n    if (!internals) // non-playwright expects mutate the global expect, so we don't need to do anything special\n      continue;\n    merged = merged.extend(internals);\n  }\n  return merged;\n}\n"],
  "mappings": "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",
  "names": ["expectLibrary", "qualifiedMatcherName"]
}

{
  "version": 3,
  "sources": ["../../src/matchers/matcherHint.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stringifyStackFrames } from 'playwright-core/lib/utils';\n\nimport type { ExpectMatcherState } from '../../types/test';\nimport type { StackFrame } from '@protocol/channels';\nimport type { Locator } from 'playwright-core';\n\nexport const kNoElementsFoundError = '<element(s) not found>';\n\nexport function matcherHint(state: ExpectMatcherState, locator: Locator | undefined, matcherName: string, expression: any, actual: any, matcherOptions: any, timeout: number | undefined, expectedReceivedString?: string, preventExtraStatIndent: boolean = false) {\n  let header = state.utils.matcherHint(matcherName, expression, actual, matcherOptions).replace(/ \\/\\/ deep equality/, '') + ' failed\\n\\n';\n  // Extra space added after locator and timeout to match Jest's received/expected output\n  const extraSpace = preventExtraStatIndent ? '' : ' ';\n  if (locator)\n    header += `Locator: ${extraSpace}${String(locator)}\\n`;\n  if (expectedReceivedString)\n    header += `${expectedReceivedString}\\n`;\n  if (timeout)\n    header += `Timeout: ${extraSpace}${timeout}ms\\n`;\n  return header;\n}\n\nexport type MatcherResult<E, A> = {\n  name: string;\n  expected?: E;\n  message: () => string;\n  pass: boolean;\n  actual?: A;\n  log?: string[];\n  timeout?: number;\n  suggestedRebaseline?: string;\n};\n\nexport type MatcherResultProperty = Omit<MatcherResult<unknown, unknown>, 'message'> & {\n  message: string;\n};\n\ntype JestError = Error & {\n  matcherResult: MatcherResultProperty;\n};\n\nexport class ExpectError extends Error {\n  matcherResult: MatcherResultProperty;\n\n  constructor(jestError: JestError, customMessage: string, stackFrames: StackFrame[]) {\n    super('');\n    // Copy to erase the JestMatcherError constructor name from the console.log(error).\n    this.name = jestError.name;\n    this.message = jestError.message;\n    this.matcherResult = jestError.matcherResult;\n\n    if (customMessage)\n      this.message = customMessage + '\\n\\n' + this.message;\n    this.stack = this.name + ': ' + this.message + '\\n' + stringifyStackFrames(stackFrames).join('\\n');\n  }\n}\n\nexport function isJestError(e: unknown): e is JestError {\n  return e instanceof Error && 'matcherResult' in e;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,mBAAqC;AAM9B,MAAM,wBAAwB;AAE9B,SAAS,YAAY,OAA2B,SAA8B,aAAqB,YAAiB,QAAa,gBAAqB,SAA6B,wBAAiC,yBAAkC,OAAO;AAClQ,MAAI,SAAS,MAAM,MAAM,YAAY,aAAa,YAAY,QAAQ,cAAc,EAAE,QAAQ,uBAAuB,EAAE,IAAI;AAE3H,QAAM,aAAa,yBAAyB,KAAK;AACjD,MAAI;AACF,cAAU,YAAY,UAAU,GAAG,OAAO,OAAO,CAAC;AAAA;AACpD,MAAI;AACF,cAAU,GAAG,sBAAsB;AAAA;AACrC,MAAI;AACF,cAAU,YAAY,UAAU,GAAG,OAAO;AAAA;AAC5C,SAAO;AACT;AAqBO,MAAM,oBAAoB,MAAM;AAAA,EAGrC,YAAY,WAAsB,eAAuB,aAA2B;AAClF,UAAM,EAAE;AAER,SAAK,OAAO,UAAU;AACtB,SAAK,UAAU,UAAU;AACzB,SAAK,gBAAgB,UAAU;AAE/B,QAAI;AACF,WAAK,UAAU,gBAAgB,SAAS,KAAK;AAC/C,SAAK,QAAQ,KAAK,OAAO,OAAO,KAAK,UAAU,WAAO,mCAAqB,WAAW,EAAE,KAAK,IAAI;AAAA,EACnG;AACF;AAEO,SAAS,YAAY,GAA4B;AACtD,SAAO,aAAa,SAAS,mBAAmB;AAClD;",
  "names": []
}

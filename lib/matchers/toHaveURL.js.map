{
  "version": 3,
  "sources": ["../../src/matchers/toHaveURL.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { urlMatches } from 'playwright-core/lib/utils';\nimport { colors } from 'playwright-core/lib/utils';\n\nimport { printReceivedStringContainExpectedResult } from './expect';\nimport {  matcherHint } from './matcherHint';\nimport { EXPECTED_COLOR, printReceived } from '../common/expectBundle';\n\nimport type { MatcherResult } from './matcherHint';\nimport type { ExpectMatcherState } from '../../types/test';\nimport type { Page } from 'playwright-core';\n\nexport async function toHaveURLWithPredicate(\n  this: ExpectMatcherState,\n  page: Page,\n  expected: (url: URL) => boolean,\n  options?: { ignoreCase?: boolean; timeout?: number },\n): Promise<MatcherResult<string | RegExp, string>> {\n  const matcherName = 'toHaveURL';\n  const expression = 'page';\n  const matcherOptions = {\n    isNot: this.isNot,\n    promise: this.promise,\n  };\n\n  if (typeof expected !== 'function') {\n    throw new Error(\n        [\n          // Always display `expected` in expectation place\n          matcherHint(this, undefined, matcherName, expression, undefined, matcherOptions, undefined, undefined, true),\n          `${colors.bold('Matcher error')}: ${EXPECTED_COLOR('expected')} value must be a string, regular expression, or predicate`,\n          this.utils.printWithType('Expected', expected, this.utils.printExpected),\n        ].join('\\n\\n'),\n    );\n  }\n\n  const timeout = options?.timeout ?? this.timeout;\n  const baseURL: string | undefined = (page.context() as any)._options.baseURL;\n  let conditionSucceeded = false;\n  let lastCheckedURLString: string | undefined = undefined;\n  try {\n    await page.mainFrame().waitForURL(\n        url => {\n          lastCheckedURLString = url.toString();\n\n          if (options?.ignoreCase) {\n            return (\n              !this.isNot ===\n              urlMatches(\n                  baseURL?.toLocaleLowerCase(),\n                  lastCheckedURLString.toLocaleLowerCase(),\n                  expected,\n              )\n            );\n          }\n\n          return (\n            !this.isNot === urlMatches(baseURL, lastCheckedURLString, expected)\n          );\n        },\n        { timeout },\n    );\n\n    conditionSucceeded = true;\n  } catch (e) {\n    conditionSucceeded = false;\n  }\n\n  if (conditionSucceeded)\n    return { name: matcherName, pass: !this.isNot, message: () => '' };\n\n  return {\n    name: matcherName,\n    pass: this.isNot,\n    message: () =>\n      toHaveURLMessage(\n          this,\n          matcherName,\n          expression,\n          expected,\n          lastCheckedURLString,\n          this.isNot,\n          true,\n          timeout,\n      ),\n    actual: lastCheckedURLString,\n    timeout,\n  };\n}\n\nfunction toHaveURLMessage(\n  state: ExpectMatcherState,\n  matcherName: string,\n  expression: string,\n  expected: Function,\n  received: string | undefined,\n  pass: boolean,\n  didTimeout: boolean,\n  timeout: number,\n): string {\n  const matcherOptions = {\n    isNot: state.isNot,\n    promise: state.promise,\n  };\n  const receivedString = received || '';\n  const messagePrefix = matcherHint(state, undefined, matcherName, expression, undefined, matcherOptions, didTimeout ? timeout : undefined, undefined, true);\n\n  let printedReceived: string | undefined;\n  let printedExpected: string | undefined;\n  let printedDiff: string | undefined;\n  if (typeof expected === 'function') {\n    printedExpected = `Expected predicate to ${!state.isNot ? 'succeed' : 'fail'}`;\n    printedReceived = `Received string: ${printReceived(receivedString)}`;\n  } else {\n    if (pass) {\n      printedExpected = `Expected pattern: not ${state.utils.printExpected(expected)}`;\n      const formattedReceived = printReceivedStringContainExpectedResult(receivedString, null);\n      printedReceived = `Received string: ${formattedReceived}`;\n    } else {\n      const labelExpected = `Expected ${typeof expected === 'string' ? 'string' : 'pattern'}`;\n      printedDiff = state.utils.printDiffOrStringify(expected, receivedString, labelExpected, 'Received string', false);\n    }\n  }\n\n  const resultDetails = printedDiff ? printedDiff : printedExpected + '\\n' + printedReceived;\n  return messagePrefix + resultDetails;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,mBAA2B;AAC3B,IAAAA,gBAAuB;AAEvB,oBAAyD;AACzD,yBAA6B;AAC7B,0BAA8C;AAM9C,eAAsB,uBAEpB,MACA,UACA,SACiD;AACjD,QAAM,cAAc;AACpB,QAAM,aAAa;AACnB,QAAM,iBAAiB;AAAA,IACrB,OAAO,KAAK;AAAA,IACZ,SAAS,KAAK;AAAA,EAChB;AAEA,MAAI,OAAO,aAAa,YAAY;AAClC,UAAM,IAAI;AAAA,MACN;AAAA;AAAA,YAEE,gCAAY,MAAM,QAAW,aAAa,YAAY,QAAW,gBAAgB,QAAW,QAAW,IAAI;AAAA,QAC3G,GAAG,qBAAO,KAAK,eAAe,CAAC,SAAK,oCAAe,UAAU,CAAC;AAAA,QAC9D,KAAK,MAAM,cAAc,YAAY,UAAU,KAAK,MAAM,aAAa;AAAA,MACzE,EAAE,KAAK,MAAM;AAAA,IACjB;AAAA,EACF;AAEA,QAAM,UAAU,SAAS,WAAW,KAAK;AACzC,QAAM,UAA+B,KAAK,QAAQ,EAAU,SAAS;AACrE,MAAI,qBAAqB;AACzB,MAAI,uBAA2C;AAC/C,MAAI;AACF,UAAM,KAAK,UAAU,EAAE;AAAA,MACnB,SAAO;AACL,+BAAuB,IAAI,SAAS;AAEpC,YAAI,SAAS,YAAY;AACvB,iBACE,CAAC,KAAK,cACN;AAAA,YACI,SAAS,kBAAkB;AAAA,YAC3B,qBAAqB,kBAAkB;AAAA,YACvC;AAAA,UACJ;AAAA,QAEJ;AAEA,eACE,CAAC,KAAK,cAAU,yBAAW,SAAS,sBAAsB,QAAQ;AAAA,MAEtE;AAAA,MACA,EAAE,QAAQ;AAAA,IACd;AAEA,yBAAqB;AAAA,EACvB,SAAS,GAAG;AACV,yBAAqB;AAAA,EACvB;AAEA,MAAI;AACF,WAAO,EAAE,MAAM,aAAa,MAAM,CAAC,KAAK,OAAO,SAAS,MAAM,GAAG;AAEnE,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM,KAAK;AAAA,IACX,SAAS,MACP;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACJ;AAAA,IACF,QAAQ;AAAA,IACR;AAAA,EACF;AACF;AAEA,SAAS,iBACP,OACA,aACA,YACA,UACA,UACA,MACA,YACA,SACQ;AACR,QAAM,iBAAiB;AAAA,IACrB,OAAO,MAAM;AAAA,IACb,SAAS,MAAM;AAAA,EACjB;AACA,QAAM,iBAAiB,YAAY;AACnC,QAAM,oBAAgB,gCAAY,OAAO,QAAW,aAAa,YAAY,QAAW,gBAAgB,aAAa,UAAU,QAAW,QAAW,IAAI;AAEzJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,OAAO,aAAa,YAAY;AAClC,sBAAkB,yBAAyB,CAAC,MAAM,QAAQ,YAAY,MAAM;AAC5E,sBAAkB,wBAAoB,mCAAc,cAAc,CAAC;AAAA,EACrE,OAAO;AACL,QAAI,MAAM;AACR,wBAAkB,yBAAyB,MAAM,MAAM,cAAc,QAAQ,CAAC;AAC9E,YAAM,wBAAoB,wDAAyC,gBAAgB,IAAI;AACvF,wBAAkB,oBAAoB,iBAAiB;AAAA,IACzD,OAAO;AACL,YAAM,gBAAgB,YAAY,OAAO,aAAa,WAAW,WAAW,SAAS;AACrF,oBAAc,MAAM,MAAM,qBAAqB,UAAU,gBAAgB,eAAe,mBAAmB,KAAK;AAAA,IAClH;AAAA,EACF;AAEA,QAAM,gBAAgB,cAAc,cAAc,kBAAkB,OAAO;AAC3E,SAAO,gBAAgB;AACzB;",
  "names": ["import_utils"]
}

{
  "version": 3,
  "sources": ["../../../src/mcp/sdk/mdb.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debug } from 'playwright-core/lib/utilsBundle';\nimport { ManualPromise } from 'playwright-core/lib/utils';\n\nimport { PingRequestSchema, z } from './bundle.js';\nimport { StreamableHTTPClientTransport } from './bundle.js';\nimport * as mcpBundle from './bundle.js';\n\nimport { defineToolSchema } from './tool.js';\nimport * as mcpServer from './server.js';\nimport * as mcpHttp from './http.js';\nimport { wrapInProcess } from './server.js';\n\nimport type { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\n\nconst mdbDebug = debug('pw:mcp:mdb');\nconst errorsDebug = debug('pw:mcp:errors');\n\nexport class MDBBackend implements mcpServer.ServerBackend {\n  private _stack: { client: Client, toolNames: string[], resultPromise: ManualPromise<mcpServer.CallToolResult> | undefined }[] = [];\n  private _interruptPromise: ManualPromise<mcpServer.CallToolResult> | undefined;\n  private _topLevelBackend: mcpServer.ServerBackend;\n  private _initialized = false;\n\n  constructor(topLevelBackend: mcpServer.ServerBackend) {\n    this._topLevelBackend = topLevelBackend;\n  }\n\n  async initialize(server: mcpServer.Server): Promise<void> {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    const transport = await wrapInProcess(this._topLevelBackend);\n    await this._pushClient(transport);\n  }\n\n  async listTools(): Promise<mcpServer.Tool[]> {\n    const response = await this._client().listTools();\n    return response.tools;\n  }\n\n  async callTool(name: string, args: mcpServer.CallToolRequest['params']['arguments']): Promise<mcpServer.CallToolResult> {\n    if (name === pushToolsSchema.name)\n      return await this._pushTools(pushToolsSchema.inputSchema.parse(args || {}));\n\n    const interruptPromise = new ManualPromise<mcpServer.CallToolResult>();\n    this._interruptPromise = interruptPromise;\n    let [entry] = this._stack;\n\n    // Pop the client while the tool is not found.\n    while (entry && !entry.toolNames.includes(name)) {\n      mdbDebug('popping client from stack for ', name);\n      this._stack.shift();\n      await entry.client.close();\n      entry = this._stack[0];\n    }\n\n    const resultPromise = new ManualPromise<mcpServer.CallToolResult>();\n    entry.resultPromise = resultPromise;\n\n    this._client().callTool({\n      name,\n      arguments: args,\n    }).then(result => {\n      resultPromise.resolve(result as mcpServer.CallToolResult);\n    }).catch(e => {\n      mdbDebug('error in client call', e);\n      if (this._stack.length < 2)\n        throw e;\n      this._stack.shift();\n      const prevEntry = this._stack[0];\n      void prevEntry.resultPromise!.then(result => resultPromise.resolve(result));\n    });\n    const result = await Promise.race([interruptPromise, resultPromise]);\n    if (interruptPromise.isDone())\n      mdbDebug('client call intercepted', result);\n    else\n      mdbDebug('client call result', result);\n    return result;\n  }\n\n  private _client(): Client {\n    const [entry] = this._stack;\n    if (!entry)\n      throw new Error('No debugging backend available');\n    return entry.client;\n  }\n\n  private async _pushTools(params: { mcpUrl: string, introMessage?: string }): Promise<mcpServer.CallToolResult> {\n    mdbDebug('pushing tools to the stack', params.mcpUrl);\n    const transport = new StreamableHTTPClientTransport(new URL(params.mcpUrl));\n    await this._pushClient(transport, params.introMessage);\n    return { content: [{ type: 'text', text: 'Tools pushed' }] };\n  }\n\n  private async _pushClient(transport: Transport, introMessage?: string): Promise<mcpServer.CallToolResult> {\n    mdbDebug('pushing client to the stack');\n    const client = new mcpBundle.Client({ name: 'Internal client', version: '0.0.0' });\n    client.setRequestHandler(PingRequestSchema, () => ({}));\n    await client.connect(transport);\n    mdbDebug('connected to the new client');\n    const { tools } = await client.listTools();\n    this._stack.unshift({ client, toolNames: tools.map(tool => tool.name), resultPromise: undefined });\n    mdbDebug('new tools added to the stack:', tools.map(tool => tool.name));\n    mdbDebug('interrupting current call:', !!this._interruptPromise);\n    this._interruptPromise?.resolve({\n      content: [{\n        type: 'text',\n        text: introMessage || '',\n      }],\n    });\n    this._interruptPromise = undefined;\n    return { content: [{ type: 'text', text: 'Tools pushed' }] };\n  }\n}\n\nconst pushToolsSchema = defineToolSchema({\n  name: 'mdb_push_tools',\n  title: 'Push MCP tools to the tools stack',\n  description: 'Push MCP tools to the tools stack',\n  inputSchema: z.object({\n    mcpUrl: z.string(),\n    introMessage: z.string().optional(),\n  }),\n  type: 'readOnly',\n});\n\nexport type ServerBackendOnPause = mcpServer.ServerBackend & {\n  requestSelfDestruct?: () => void;\n};\n\nexport async function runMainBackend(backendFactory: mcpServer.ServerBackendFactory, options?: { port?: number }): Promise<string | undefined> {\n  const mdbBackend = new MDBBackend(backendFactory.create());\n  // Start HTTP unconditionally.\n  const factory: mcpServer.ServerBackendFactory = {\n    ...backendFactory,\n    create: () => mdbBackend\n  };\n  const url = await startAsHttp(factory, { port: options?.port || 0 });\n  process.env.PLAYWRIGHT_MDB_URL = url;\n\n  if (options?.port !== undefined)\n    return url;\n\n  // Start stdio conditionally.\n  await mcpServer.connect(factory, new mcpBundle.StdioServerTransport(), false);\n}\n\nexport async function runOnPauseBackendLoop(mdbUrl: string, backend: ServerBackendOnPause, introMessage: string) {\n  const wrappedBackend = new OnceTimeServerBackendWrapper(backend);\n\n  const factory = {\n    name: 'on-pause-backend',\n    nameInConfig: 'on-pause-backend',\n    version: '0.0.0',\n    create: () => wrappedBackend,\n  };\n\n  const httpServer = await mcpHttp.startHttpServer({ port: 0 });\n  await mcpHttp.installHttpTransport(httpServer, factory);\n  const url = mcpHttp.httpAddressToString(httpServer.address());\n\n  const client = new mcpBundle.Client({ name: 'Internal client', version: '0.0.0' });\n  client.setRequestHandler(PingRequestSchema, () => ({}));\n  const transport = new StreamableHTTPClientTransport(new URL(mdbUrl));\n  await client.connect(transport);\n\n  const pushToolsResult = await client.callTool({\n    name: pushToolsSchema.name,\n    arguments: {\n      mcpUrl: url,\n      introMessage,\n    },\n  });\n  if (pushToolsResult.isError)\n    errorsDebug('Failed to push tools', pushToolsResult.content);\n  await transport.terminateSession();\n  await client.close();\n\n  await wrappedBackend.waitForClosed();\n  httpServer.close();\n}\n\nasync function startAsHttp(backendFactory: mcpServer.ServerBackendFactory, options: { port: number }) {\n  const httpServer = await mcpHttp.startHttpServer(options);\n  await mcpHttp.installHttpTransport(httpServer, backendFactory);\n  return mcpHttp.httpAddressToString(httpServer.address());\n}\n\n\nclass OnceTimeServerBackendWrapper implements mcpServer.ServerBackend {\n  private _backend: ServerBackendOnPause;\n  private _selfDestructPromise = new ManualPromise<void>();\n\n  constructor(backend: ServerBackendOnPause) {\n    this._backend = backend;\n    this._backend.requestSelfDestruct = () => this._selfDestructPromise.resolve();\n  }\n\n  async initialize(server: mcpServer.Server, clientVersion: mcpServer.ClientVersion, roots: mcpServer.Root[]): Promise<void> {\n    await this._backend.initialize?.(server, clientVersion, roots);\n  }\n\n  async listTools(): Promise<mcpServer.Tool[]> {\n    return this._backend.listTools();\n  }\n\n  async callTool(name: string, args: mcpServer.CallToolRequest['params']['arguments']): Promise<mcpServer.CallToolResult> {\n    return this._backend.callTool(name, args);\n  }\n\n  serverClosed(server: mcpServer.Server) {\n    this._backend.serverClosed?.(server);\n    this._selfDestructPromise.resolve();\n  }\n\n  async waitForClosed() {\n    await this._selfDestructPromise;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_bundle", "result"]
}

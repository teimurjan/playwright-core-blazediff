{
  "version": 3,
  "sources": ["../../../src/mcp/sdk/inProcessTransport.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { Transport, TransportSendOptions } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport type { JSONRPCMessage, MessageExtraInfo } from '@modelcontextprotocol/sdk/types.js';\n\nexport class InProcessTransport implements Transport {\n  private _server: Server;\n  private _serverTransport: InProcessServerTransport;\n  private _connected: boolean = false;\n\n  constructor(server: Server) {\n    this._server = server;\n    this._serverTransport = new InProcessServerTransport(this);\n  }\n\n  async start(): Promise<void> {\n    if (this._connected)\n      throw new Error('InprocessTransport already started!');\n\n    await this._server.connect(this._serverTransport);\n    this._connected = true;\n  }\n\n  async send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void> {\n    if (!this._connected)\n      throw new Error('Transport not connected');\n\n\n    this._serverTransport._receiveFromClient(message);\n  }\n\n  async close(): Promise<void> {\n    if (this._connected) {\n      this._connected = false;\n      this.onclose?.();\n      this._serverTransport.onclose?.();\n    }\n  }\n\n  onclose?: (() => void) | undefined;\n  onerror?: ((error: Error) => void) | undefined;\n  onmessage?: ((message: JSONRPCMessage, extra?: MessageExtraInfo) => void) | undefined;\n  sessionId?: string | undefined;\n  setProtocolVersion?: ((version: string) => void) | undefined;\n\n  _receiveFromServer(message: JSONRPCMessage, extra?: MessageExtraInfo): void {\n    this.onmessage?.(message, extra);\n  }\n}\n\nclass InProcessServerTransport implements Transport {\n  private _clientTransport: InProcessTransport;\n\n  constructor(clientTransport: InProcessTransport) {\n    this._clientTransport = clientTransport;\n  }\n\n  async start(): Promise<void> {\n  }\n\n  async send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void> {\n    this._clientTransport._receiveFromServer(message);\n  }\n\n  async close(): Promise<void> {\n    this.onclose?.();\n  }\n\n  onclose?: (() => void) | undefined;\n  onerror?: ((error: Error) => void) | undefined;\n  onmessage?: ((message: JSONRPCMessage, extra?: MessageExtraInfo) => void) | undefined;\n  sessionId?: string | undefined;\n  setProtocolVersion?: ((version: string) => void) | undefined;\n  _receiveFromClient(message: JSONRPCMessage): void {\n    this.onmessage?.(message);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,MAAM,mBAAwC;AAAA,EAKnD,YAAY,QAAgB;AAF5B,SAAQ,aAAsB;AAG5B,SAAK,UAAU;AACf,SAAK,mBAAmB,IAAI,yBAAyB,IAAI;AAAA,EAC3D;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,qCAAqC;AAEvD,UAAM,KAAK,QAAQ,QAAQ,KAAK,gBAAgB;AAChD,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAM,KAAK,SAAyB,SAA+C;AACjF,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,yBAAyB;AAG3C,SAAK,iBAAiB,mBAAmB,OAAO;AAAA,EAClD;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,KAAK,YAAY;AACnB,WAAK,aAAa;AAClB,WAAK,UAAU;AACf,WAAK,iBAAiB,UAAU;AAAA,IAClC;AAAA,EACF;AAAA,EAQA,mBAAmB,SAAyB,OAAgC;AAC1E,SAAK,YAAY,SAAS,KAAK;AAAA,EACjC;AACF;AAEA,MAAM,yBAA8C;AAAA,EAGlD,YAAY,iBAAqC;AAC/C,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,MAAM,QAAuB;AAAA,EAC7B;AAAA,EAEA,MAAM,KAAK,SAAyB,SAA+C;AACjF,SAAK,iBAAiB,mBAAmB,OAAO;AAAA,EAClD;AAAA,EAEA,MAAM,QAAuB;AAC3B,SAAK,UAAU;AAAA,EACjB;AAAA,EAOA,mBAAmB,SAA+B;AAChD,SAAK,YAAY,OAAO;AAAA,EAC1B;AACF;",
  "names": []
}

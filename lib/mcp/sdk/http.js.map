{
  "version": 3,
  "sources": ["../../../src/mcp/sdk/http.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport assert from 'assert';\nimport net from 'net';\nimport http from 'http';\nimport crypto from 'crypto';\nimport { debug } from 'playwright-core/lib/utilsBundle';\n\nimport * as mcp from './bundle';\nimport { connect } from './server';\n\nimport type { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';\nimport type { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';\nimport type { ServerBackendFactory } from './server';\n\nconst testDebug = debug('pw:mcp:test');\n\nexport async function startHttpServer(config: { host?: string, port?: number }, abortSignal?: AbortSignal): Promise<http.Server> {\n  const { host, port } = config;\n  const httpServer = http.createServer();\n  await new Promise<void>((resolve, reject) => {\n    httpServer.on('error', reject);\n    abortSignal?.addEventListener('abort', () => {\n      httpServer.close();\n      reject(new Error('Aborted'));\n    });\n    httpServer.listen(port, host, () => {\n      resolve();\n      httpServer.removeListener('error', reject);\n    });\n  });\n  return httpServer;\n}\n\nexport function httpAddressToString(address: string | net.AddressInfo | null): string {\n  assert(address, 'Could not bind server socket');\n  if (typeof address === 'string')\n    return address;\n  const resolvedPort = address.port;\n  let resolvedHost = address.family === 'IPv4' ? address.address : `[${address.address}]`;\n  if (resolvedHost === '0.0.0.0' || resolvedHost === '[::]')\n    resolvedHost = 'localhost';\n  return `http://${resolvedHost}:${resolvedPort}`;\n}\n\nexport async function installHttpTransport(httpServer: http.Server, serverBackendFactory: ServerBackendFactory) {\n  const sseSessions = new Map();\n  const streamableSessions = new Map();\n  httpServer.on('request', async (req, res) => {\n    const url = new URL(`http://localhost${req.url}`);\n    if (url.pathname.startsWith('/sse'))\n      await handleSSE(serverBackendFactory, req, res, url, sseSessions);\n    else\n      await handleStreamable(serverBackendFactory, req, res, streamableSessions);\n  });\n}\n\nasync function handleSSE(serverBackendFactory: ServerBackendFactory, req: http.IncomingMessage, res: http.ServerResponse, url: URL, sessions: Map<string, SSEServerTransport>) {\n  if (req.method === 'POST') {\n    const sessionId = url.searchParams.get('sessionId');\n    if (!sessionId) {\n      res.statusCode = 400;\n      return res.end('Missing sessionId');\n    }\n\n    const transport = sessions.get(sessionId);\n    if (!transport) {\n      res.statusCode = 404;\n      return res.end('Session not found');\n    }\n\n    return await transport.handlePostMessage(req, res);\n  } else if (req.method === 'GET') {\n    const transport = new mcp.SSEServerTransport('/sse', res);\n    sessions.set(transport.sessionId, transport);\n    testDebug(`create SSE session: ${transport.sessionId}`);\n    await connect(serverBackendFactory, transport, false);\n    res.on('close', () => {\n      testDebug(`delete SSE session: ${transport.sessionId}`);\n      sessions.delete(transport.sessionId);\n    });\n    return;\n  }\n\n  res.statusCode = 405;\n  res.end('Method not allowed');\n}\n\nasync function handleStreamable(serverBackendFactory: ServerBackendFactory, req: http.IncomingMessage, res: http.ServerResponse, sessions: Map<string, StreamableHTTPServerTransport>) {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (sessionId) {\n    const transport = sessions.get(sessionId);\n    if (!transport) {\n      res.statusCode = 404;\n      res.end('Session not found');\n      return;\n    }\n    return await transport.handleRequest(req, res);\n  }\n\n  if (req.method === 'POST') {\n    const transport = new mcp.StreamableHTTPServerTransport({\n      sessionIdGenerator: () => crypto.randomUUID(),\n      onsessioninitialized: async sessionId => {\n        testDebug(`create http session: ${transport.sessionId}`);\n        await connect(serverBackendFactory, transport, true);\n        sessions.set(sessionId, transport);\n      }\n    });\n\n    transport.onclose = () => {\n      if (!transport.sessionId)\n        return;\n      sessions.delete(transport.sessionId);\n      testDebug(`delete http session: ${transport.sessionId}`);\n    };\n\n    await transport.handleRequest(req, res);\n    return;\n  }\n\n  res.statusCode = 400;\n  res.end('Invalid request');\n}\n"],
  "mappings": "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",
  "names": ["http", "assert", "crypto", "sessionId"]
}

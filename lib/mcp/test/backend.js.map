{
  "version": 3,
  "sources": ["../../../src/mcp/test/backend.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as mcp from '../sdk/exports.js';\nimport { Context } from './context';\nimport { listTests, runTests, debugTest } from './tools.js';\nimport { snapshot, pickLocator, evaluate } from '../browser/tools';\n\nimport type { ConfigLocation } from '../../common/config';\nimport type { Tool } from './tool';\n\n\nexport class TestServerBackend implements mcp.ServerBackend {\n  readonly name = 'Playwright';\n  readonly version = '0.0.1';\n  private _tools: Tool<any>[] = [listTests, runTests, debugTest];\n  private _context: Context;\n\n  constructor(resolvedLocation: ConfigLocation, options?: { muteConsole?: boolean }) {\n    this._context = new Context(resolvedLocation, options);\n  }\n\n  async listTools(): Promise<mcp.Tool[]> {\n    return [\n      ...this._tools.map(tool => mcp.toMcpTool(tool.schema)),\n      mcp.toMcpTool(snapshot.schema),\n      mcp.toMcpTool(pickLocator.schema),\n      mcp.toMcpTool(evaluate.schema),\n    ];\n  }\n\n  async callTool(name: string, args: mcp.CallToolRequest['params']['arguments']): Promise<mcp.CallToolResult> {\n    const tool = this._tools.find(tool => tool.schema.name === name);\n    if (!tool)\n      throw new Error(`Tool not found: ${name}. Available tools: ${this._tools.map(tool => tool.schema.name).join(', ')}`);\n    const parsedArguments = tool.schema.inputSchema.parse(args || {});\n    return await tool.handle(this._context!, parsedArguments);\n  }\n\n  serverClosed() {\n    void this._context!.close();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,UAAqB;AACrB,qBAAwB;AACxB,mBAA+C;AAC/C,IAAAA,gBAAgD;AAMzC,MAAM,kBAA+C;AAAA,EAM1D,YAAY,kBAAkC,SAAqC;AALnF,SAAS,OAAO;AAChB,SAAS,UAAU;AACnB,SAAQ,SAAsB,CAAC,wBAAW,uBAAU,sBAAS;AAI3D,SAAK,WAAW,IAAI,uBAAQ,kBAAkB,OAAO;AAAA,EACvD;AAAA,EAEA,MAAM,YAAiC;AACrC,WAAO;AAAA,MACL,GAAG,KAAK,OAAO,IAAI,UAAQ,IAAI,UAAU,KAAK,MAAM,CAAC;AAAA,MACrD,IAAI,UAAU,uBAAS,MAAM;AAAA,MAC7B,IAAI,UAAU,0BAAY,MAAM;AAAA,MAChC,IAAI,UAAU,uBAAS,MAAM;AAAA,IAC/B;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,MAAc,MAA+E;AAC1G,UAAM,OAAO,KAAK,OAAO,KAAK,CAAAC,UAAQA,MAAK,OAAO,SAAS,IAAI;AAC/D,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,mBAAmB,IAAI,sBAAsB,KAAK,OAAO,IAAI,CAAAA,UAAQA,MAAK,OAAO,IAAI,EAAE,KAAK,IAAI,CAAC,EAAE;AACrH,UAAM,kBAAkB,KAAK,OAAO,YAAY,MAAM,QAAQ,CAAC,CAAC;AAChE,WAAO,MAAM,KAAK,OAAO,KAAK,UAAW,eAAe;AAAA,EAC1D;AAAA,EAEA,eAAe;AACb,SAAK,KAAK,SAAU,MAAM;AAAA,EAC5B;AACF;",
  "names": ["import_tools", "tool"]
}

{
  "version": 3,
  "sources": ["../../../src/mcp/browser/tools.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asLocator } from 'playwright-core/lib/utils';\n\nimport { defineTool } from './tool.js';\nimport * as mcp from '../sdk/bundle';\n\nimport type * as playwright from '../../../index';\nimport type z from 'zod';\n\ntype PageEx = playwright.Page & {\n  _snapshotForAI: () => Promise<string>;\n};\n\nexport const snapshot = defineTool({\n  schema: {\n    name: 'playwright_test_browser_snapshot',\n    title: 'Capture page snapshot',\n    description: 'Capture page snapshot for debugging',\n    inputSchema: mcp.z.object({}),\n    type: 'readOnly',\n  },\n\n  handle: async (page, params) => {\n    const snapshot = await (page as PageEx)._snapshotForAI();\n    return {\n      content: [\n        {\n          type: 'text',\n          text: snapshot,\n        },\n      ],\n    };\n  },\n});\n\nexport const elementSchema = mcp.z.object({\n  element: mcp.z.string().describe('Human-readable element description used to obtain permission to interact with the element'),\n  ref: mcp.z.string().describe('Exact target element reference from the page snapshot'),\n});\n\nexport const pickLocator = defineTool({\n  schema: {\n    name: 'playwright_test_generate_locator',\n    title: 'Create locator for element',\n    description: 'Generate locator for the given element to use in tests',\n    inputSchema: elementSchema,\n    type: 'readOnly',\n  },\n\n  handle: async (page, params) => {\n    const locator = await refLocator(page, params);\n\n    try {\n      const { resolvedSelector } = await (locator as any)._resolveSelector();\n      const locatorString = asLocator('javascript', resolvedSelector);\n      return { content: [{ type: 'text', text: locatorString }] };\n    } catch (e) {\n      throw new Error(`Ref not found, likely because element was removed. Use ${snapshot.schema.name} to see what elements are currently on the page.`);\n    }\n  },\n});\n\nconst evaluateSchema = mcp.z.object({\n  function: mcp.z.string().describe('() => { /* code */ } or (element) => { /* code */ } when element is provided'),\n  element: mcp.z.string().optional().describe('Human-readable element description used to obtain permission to interact with the element'),\n  ref: mcp.z.string().optional().describe('Exact target element reference from the page snapshot'),\n});\n\nexport const evaluate = defineTool({\n  schema: {\n    name: 'playwright_test_evaluate_on_pause',\n    title: 'Evaluate in page',\n    description: 'Evaluate JavaScript expression on page or element',\n    inputSchema: evaluateSchema,\n    type: 'destructive',\n  },\n\n  handle: async (page, params) => {\n    let locator: playwright.Locator | undefined;\n    if (params.ref && params.element)\n      locator = await refLocator(page, { ref: params.ref, element: params.element });\n\n    const receiver = locator ?? page as any;\n    const result = await receiver._evaluateFunction(params.function);\n    return {\n      content: [{ type: 'text', text: JSON.stringify(result, null, 2) || 'undefined' }],\n    };\n  },\n});\n\nasync function refLocator(page: playwright.Page, elementRef: z.output<typeof elementSchema>): Promise<playwright.Locator> {\n  const snapshot = await (page as PageEx)._snapshotForAI();\n  if (!snapshot.includes(`[ref=${elementRef.ref}]`))\n    throw new Error(`Ref ${elementRef.ref} not found in the current page snapshot. Try capturing new snapshot.`);\n  return page.locator(`aria-ref=${elementRef.ref}`).describe(elementRef.element);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,mBAA0B;AAE1B,kBAA2B;AAC3B,UAAqB;AASd,MAAM,eAAW,wBAAW;AAAA,EACjC,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa,IAAI,EAAE,OAAO,CAAC,CAAC;AAAA,IAC5B,MAAM;AAAA,EACR;AAAA,EAEA,QAAQ,OAAO,MAAM,WAAW;AAC9B,UAAMA,YAAW,MAAO,KAAgB,eAAe;AACvD,WAAO;AAAA,MACL,SAAS;AAAA,QACP;AAAA,UACE,MAAM;AAAA,UACN,MAAMA;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF,CAAC;AAEM,MAAM,gBAAgB,IAAI,EAAE,OAAO;AAAA,EACxC,SAAS,IAAI,EAAE,OAAO,EAAE,SAAS,2FAA2F;AAAA,EAC5H,KAAK,IAAI,EAAE,OAAO,EAAE,SAAS,uDAAuD;AACtF,CAAC;AAEM,MAAM,kBAAc,wBAAW;AAAA,EACpC,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa;AAAA,IACb,MAAM;AAAA,EACR;AAAA,EAEA,QAAQ,OAAO,MAAM,WAAW;AAC9B,UAAM,UAAU,MAAM,WAAW,MAAM,MAAM;AAE7C,QAAI;AACF,YAAM,EAAE,iBAAiB,IAAI,MAAO,QAAgB,iBAAiB;AACrE,YAAM,oBAAgB,wBAAU,cAAc,gBAAgB;AAC9D,aAAO,EAAE,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,cAAc,CAAC,EAAE;AAAA,IAC5D,SAAS,GAAG;AACV,YAAM,IAAI,MAAM,0DAA0D,SAAS,OAAO,IAAI,kDAAkD;AAAA,IAClJ;AAAA,EACF;AACF,CAAC;AAED,MAAM,iBAAiB,IAAI,EAAE,OAAO;AAAA,EAClC,UAAU,IAAI,EAAE,OAAO,EAAE,SAAS,8EAA8E;AAAA,EAChH,SAAS,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,2FAA2F;AAAA,EACvI,KAAK,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,uDAAuD;AACjG,CAAC;AAEM,MAAM,eAAW,wBAAW;AAAA,EACjC,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,aAAa;AAAA,IACb,aAAa;AAAA,IACb,MAAM;AAAA,EACR;AAAA,EAEA,QAAQ,OAAO,MAAM,WAAW;AAC9B,QAAI;AACJ,QAAI,OAAO,OAAO,OAAO;AACvB,gBAAU,MAAM,WAAW,MAAM,EAAE,KAAK,OAAO,KAAK,SAAS,OAAO,QAAQ,CAAC;AAE/E,UAAM,WAAW,WAAW;AAC5B,UAAM,SAAS,MAAM,SAAS,kBAAkB,OAAO,QAAQ;AAC/D,WAAO;AAAA,MACL,SAAS,CAAC,EAAE,MAAM,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,CAAC,KAAK,YAAY,CAAC;AAAA,IAClF;AAAA,EACF;AACF,CAAC;AAED,eAAe,WAAW,MAAuB,YAAyE;AACxH,QAAMA,YAAW,MAAO,KAAgB,eAAe;AACvD,MAAI,CAACA,UAAS,SAAS,QAAQ,WAAW,GAAG,GAAG;AAC9C,UAAM,IAAI,MAAM,OAAO,WAAW,GAAG,sEAAsE;AAC7G,SAAO,KAAK,QAAQ,YAAY,WAAW,GAAG,EAAE,EAAE,SAAS,WAAW,OAAO;AAC/E;",
  "names": ["snapshot"]
}

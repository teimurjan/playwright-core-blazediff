{
  "version": 3,
  "sources": ["../../src/worker/testTracing.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { ManualPromise, SerializedFS, calculateSha1, createGuid, monotonicTime } from 'playwright-core/lib/utils';\nimport { yauzl, yazl } from 'playwright-core/lib/zipBundle';\n\nimport { filteredStackTrace } from '../util';\n\nimport type { TestStepCategory, TestInfoImpl } from './testInfo';\nimport type { PlaywrightWorkerOptions, TestInfo, TraceMode } from '../../types/test';\nimport type { TestInfoErrorImpl } from '../common/ipc';\nimport type { SerializedError, StackFrame } from '@protocol/channels';\nimport type * as trace from '@trace/trace';\nimport type EventEmitter from 'events';\n\nexport type Attachment = TestInfo['attachments'][0];\nexport const testTraceEntryName = 'test.trace';\nconst version: trace.VERSION = 8;\nlet traceOrdinal = 0;\n\ntype TraceFixtureValue =  PlaywrightWorkerOptions['trace'] | undefined;\ntype TraceOptions = { screenshots: boolean, snapshots: boolean, sources: boolean, attachments: boolean, _live: boolean, mode: TraceMode };\n\nexport class TestTracing {\n  private _testInfo: TestInfoImpl;\n  private _options: TraceOptions | undefined;\n  private _liveTraceFile: { file: string, fs: SerializedFS } | undefined;\n  private _traceEvents: trace.TraceEvent[] = [];\n  private _temporaryTraceFiles: string[] = [];\n  private _artifactsDir: string;\n  private _tracesDir: string;\n  private _contextCreatedEvent: trace.ContextCreatedTraceEvent;\n  private _didFinishTestFunctionAndAfterEachHooks = false;\n\n  constructor(testInfo: TestInfoImpl, artifactsDir: string) {\n    this._testInfo = testInfo;\n    this._artifactsDir = artifactsDir;\n    this._tracesDir = path.join(this._artifactsDir, 'traces');\n    this._contextCreatedEvent = {\n      version,\n      type: 'context-options',\n      origin: 'testRunner',\n      browserName: '',\n      options: {},\n      platform: process.platform,\n      wallTime: Date.now(),\n      monotonicTime: monotonicTime(),\n      sdkLanguage: 'javascript',\n    };\n    this._appendTraceEvent(this._contextCreatedEvent);\n  }\n\n  private _shouldCaptureTrace() {\n    if (this._options?.mode === 'on')\n      return true;\n\n    if (this._options?.mode === 'retain-on-failure')\n      return true;\n\n    if (this._options?.mode === 'on-first-retry' && this._testInfo.retry === 1)\n      return true;\n\n    if (this._options?.mode === 'on-all-retries' && this._testInfo.retry > 0)\n      return true;\n\n    if (this._options?.mode === 'retain-on-first-failure' && this._testInfo.retry === 0)\n      return true;\n\n    return false;\n  }\n\n  async startIfNeeded(value: TraceFixtureValue) {\n    const defaultTraceOptions: TraceOptions = { screenshots: true, snapshots: true, sources: true, attachments: true, _live: false, mode: 'off' };\n\n    if (!value) {\n      this._options = defaultTraceOptions;\n    } else if (typeof value === 'string') {\n      this._options = { ...defaultTraceOptions, mode: value === 'retry-with-trace' ? 'on-first-retry' : value as TraceMode };\n    } else {\n      const mode = value.mode || 'off';\n      this._options = { ...defaultTraceOptions, ...value, mode: (mode as string) === 'retry-with-trace' ? 'on-first-retry' : mode };\n    }\n\n    if (!this._shouldCaptureTrace()) {\n      this._options = undefined;\n      return;\n    }\n\n    if (!this._liveTraceFile && this._options._live) {\n      // Note that trace name must start with testId for live tracing to work.\n      this._liveTraceFile = { file: path.join(this._tracesDir, `${this._testInfo.testId}-test.trace`), fs: new SerializedFS() };\n      this._liveTraceFile.fs.mkdir(path.dirname(this._liveTraceFile.file));\n      const data = this._traceEvents.map(e => JSON.stringify(e)).join('\\n') + '\\n';\n      this._liveTraceFile.fs.writeFile(this._liveTraceFile.file, data);\n    }\n  }\n\n  didFinishTestFunctionAndAfterEachHooks() {\n    this._didFinishTestFunctionAndAfterEachHooks = true;\n  }\n\n  artifactsDir() {\n    return this._artifactsDir;\n  }\n\n  tracesDir() {\n    return this._tracesDir;\n  }\n\n  traceTitle() {\n    return [path.relative(this._testInfo.project.testDir, this._testInfo.file) + ':' + this._testInfo.line, ...this._testInfo.titlePath.slice(1)].join(' \u203A ');\n  }\n\n  generateNextTraceRecordingName() {\n    const ordinalSuffix = traceOrdinal ? `-recording${traceOrdinal}` : '';\n    ++traceOrdinal;\n    const retrySuffix = this._testInfo.retry ? `-retry${this._testInfo.retry}` : '';\n    // Note that trace name must start with testId for live tracing to work.\n    return `${this._testInfo.testId}${retrySuffix}${ordinalSuffix}`;\n  }\n\n  private _generateNextTraceRecordingPath() {\n    const file = path.join(this._artifactsDir, createGuid() + '.zip');\n    this._temporaryTraceFiles.push(file);\n    return file;\n  }\n\n  traceOptions() {\n    return this._options;\n  }\n\n  maybeGenerateNextTraceRecordingPath() {\n    // Forget about traces that should be saved on failure, when no failure happened\n    // during the test and beforeEach/afterEach hooks.\n    // This avoids downloading traces over the wire when not really needed.\n    if (this._didFinishTestFunctionAndAfterEachHooks && this._shouldAbandonTrace())\n      return;\n    return this._generateNextTraceRecordingPath();\n  }\n\n  private _shouldAbandonTrace() {\n    if (!this._options)\n      return true;\n    const testFailed = this._testInfo.status !== this._testInfo.expectedStatus;\n    return !testFailed && (this._options.mode === 'retain-on-failure' || this._options.mode === 'retain-on-first-failure');\n  }\n\n  async stopIfNeeded() {\n    if (!this._options)\n      return;\n\n    const error = await this._liveTraceFile?.fs.syncAndGetError();\n    if (error)\n      throw error;\n\n    if (this._shouldAbandonTrace()) {\n      for (const file of this._temporaryTraceFiles)\n        await fs.promises.unlink(file).catch(() => {});\n      return;\n    }\n\n    const zipFile = new yazl.ZipFile();\n\n    if (!this._options?.attachments) {\n      for (const event of this._traceEvents) {\n        if (event.type === 'after')\n          delete event.attachments;\n      }\n    }\n\n    if (this._options?.sources) {\n      const sourceFiles = new Set<string>();\n      for (const event of this._traceEvents) {\n        if (event.type === 'before') {\n          for (const frame of event.stack || [])\n            sourceFiles.add(frame.file);\n        }\n      }\n      for (const sourceFile of sourceFiles) {\n        await fs.promises.readFile(sourceFile, 'utf8').then(source => {\n          zipFile.addBuffer(Buffer.from(source), 'resources/src@' + calculateSha1(sourceFile) + '.txt');\n        }).catch(() => {});\n      }\n    }\n\n    const sha1s = new Set<string>();\n    for (const event of this._traceEvents.filter(e => e.type === 'after') as trace.AfterActionTraceEvent[]) {\n      for (const attachment of (event.attachments || [])) {\n        let contentPromise: Promise<Buffer | undefined> | undefined;\n        if (attachment.path)\n          contentPromise = fs.promises.readFile(attachment.path).catch(() => undefined);\n        else if (attachment.base64)\n          contentPromise = Promise.resolve(Buffer.from(attachment.base64, 'base64'));\n\n        const content = await contentPromise;\n        if (content === undefined)\n          continue;\n\n        const sha1 = calculateSha1(content);\n        attachment.sha1 = sha1;\n        delete attachment.path;\n        delete attachment.base64;\n        if (sha1s.has(sha1))\n          continue;\n        sha1s.add(sha1);\n        zipFile.addBuffer(content, 'resources/' + sha1);\n      }\n    }\n\n    const traceContent = Buffer.from(this._traceEvents.map(e => JSON.stringify(e)).join('\\n'));\n    zipFile.addBuffer(traceContent, testTraceEntryName);\n\n    await new Promise(f => {\n      zipFile.end(undefined, () => {\n        zipFile.outputStream.pipe(fs.createWriteStream(this._generateNextTraceRecordingPath())).on('close', f);\n      });\n    });\n\n    const tracePath = this._testInfo.outputPath('trace.zip');\n    await mergeTraceFiles(tracePath, this._temporaryTraceFiles);\n    this._testInfo.attachments.push({ name: 'trace', path: tracePath, contentType: 'application/zip' });\n  }\n\n  appendForError(error: TestInfoErrorImpl) {\n    const rawStack = error.stack?.split('\\n') || [];\n    const stack = rawStack ? filteredStackTrace(rawStack) : [];\n    this._appendTraceEvent({\n      type: 'error',\n      message: this._formatError(error),\n      stack,\n    });\n  }\n\n  _formatError(error: TestInfoErrorImpl) {\n    const parts: string[] = [error.message || String(error.value)];\n    if (error.cause)\n      parts.push('[cause]: ' + this._formatError(error.cause));\n    return parts.join('\\n');\n  }\n\n  appendStdioToTrace(type: 'stdout' | 'stderr', chunk: string | Buffer) {\n    this._appendTraceEvent({\n      type,\n      timestamp: monotonicTime(),\n      text: typeof chunk === 'string' ? chunk : undefined,\n      base64: typeof chunk === 'string' ? undefined : chunk.toString('base64'),\n    });\n  }\n\n  appendBeforeActionForStep(options: { stepId: string, parentId?: string, title: string, category: TestStepCategory, params?: Record<string, any>, stack: StackFrame[], group?: string }) {\n    this._appendTraceEvent({\n      type: 'before',\n      callId: options.stepId,\n      stepId: options.stepId,\n      parentId: options.parentId,\n      startTime: monotonicTime(),\n      class: 'Test',\n      method: options.category,\n      title: options.title,\n      params: Object.fromEntries(Object.entries(options.params || {}).map(([name, value]) => [name, generatePreview(value)])),\n      stack: options.stack,\n      group: options.group,\n    });\n  }\n\n  appendAfterActionForStep(callId: string, error?: SerializedError['error'], attachments: Attachment[] = [], annotations?: trace.AfterActionTraceEventAnnotation[]) {\n    this._appendTraceEvent({\n      type: 'after',\n      callId,\n      endTime: monotonicTime(),\n      attachments: serializeAttachments(attachments),\n      annotations,\n      error,\n    });\n  }\n\n  private _appendTraceEvent(event: trace.TraceEvent) {\n    this._traceEvents.push(event);\n    if (this._liveTraceFile)\n      this._liveTraceFile.fs.appendFile(this._liveTraceFile.file, JSON.stringify(event) + '\\n', true);\n  }\n}\n\nfunction serializeAttachments(attachments: Attachment[]): trace.AfterActionTraceEvent['attachments'] {\n  if (attachments.length === 0)\n    return undefined;\n  return attachments.filter(a => a.name !== 'trace').map(a => {\n    return {\n      name: a.name,\n      contentType: a.contentType,\n      path: a.path,\n      base64: a.body?.toString('base64'),\n    };\n  });\n}\n\nfunction generatePreview(value: any, visited = new Set<any>()): string {\n  if (visited.has(value))\n    return '';\n  visited.add(value);\n  if (typeof value === 'string')\n    return value;\n  if (typeof value === 'number')\n    return value.toString();\n  if (typeof value === 'boolean')\n    return value.toString();\n  if (value === null)\n    return 'null';\n  if (value === undefined)\n    return 'undefined';\n  if (Array.isArray(value))\n    return '[' + value.map(v => generatePreview(v, visited)).join(', ') + ']';\n  if (typeof value === 'object')\n    return 'Object';\n  return String(value);\n}\n\nasync function mergeTraceFiles(fileName: string, temporaryTraceFiles: string[]) {\n  temporaryTraceFiles = temporaryTraceFiles.filter(file => fs.existsSync(file));\n  if (temporaryTraceFiles.length === 1) {\n    await fs.promises.rename(temporaryTraceFiles[0], fileName);\n    return;\n  }\n\n  const mergePromise = new ManualPromise();\n  const zipFile = new yazl.ZipFile();\n  const entryNames = new Set<string>();\n  (zipFile as any as EventEmitter).on('error', error => mergePromise.reject(error));\n\n  for (let i = temporaryTraceFiles.length - 1; i >= 0; --i) {\n    const tempFile = temporaryTraceFiles[i];\n    const promise = new ManualPromise<void>();\n    yauzl.open(tempFile, (err, inZipFile) => {\n      if (err) {\n        promise.reject(err);\n        return;\n      }\n      let pendingEntries = inZipFile.entryCount;\n      inZipFile.on('entry', entry => {\n        let entryName = entry.fileName;\n        if (entry.fileName === testTraceEntryName) {\n          // Keep the name for test traces so that the last test trace\n          // that contains most of the information is kept in the trace.\n          // Note the reverse order of the iteration (from new traces to old).\n        } else if (entry.fileName.match(/trace\\.[a-z]*$/)) {\n          entryName = i + '-' + entry.fileName;\n        }\n        if (entryNames.has(entryName)) {\n          if (--pendingEntries === 0)\n            promise.resolve();\n          return;\n        }\n        entryNames.add(entryName);\n        inZipFile.openReadStream(entry, (err, readStream) => {\n          if (err) {\n            promise.reject(err);\n            return;\n          }\n          zipFile.addReadStream(readStream!, entryName);\n          if (--pendingEntries === 0)\n            promise.resolve();\n        });\n      });\n    });\n    await promise;\n  }\n\n  zipFile.end(undefined, () => {\n    zipFile.outputStream.pipe(fs.createWriteStream(fileName)).on('close', () => {\n      void Promise.all(temporaryTraceFiles.map(tempFile => fs.promises.unlink(tempFile))).then(() => {\n        mergePromise.resolve();\n      }).catch(error => mergePromise.reject(error));\n    }).on('error', error => mergePromise.reject(error));\n  });\n  await mergePromise;\n}\n"],
  "mappings": "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",
  "names": ["path", "fs", "err"]
}

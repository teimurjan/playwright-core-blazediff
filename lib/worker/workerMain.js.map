{
  "version": 3,
  "sources": ["../../src/worker/workerMain.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ManualPromise, gracefullyCloseAll, removeFolders } from 'playwright-core/lib/utils';\nimport { colors } from 'playwright-core/lib/utils';\n\nimport { deserializeConfig } from '../common/configLoader';\nimport { setCurrentTestInfo, setIsWorkerProcess } from '../common/globals';\nimport { stdioChunkToParams } from '../common/ipc';\nimport { debugTest, relativeFilePath } from '../util';\nimport { FixtureRunner } from './fixtureRunner';\nimport { TestSkipError, TestInfoImpl } from './testInfo';\nimport { testInfoError } from './util';\nimport { inheritFixtureNames } from '../common/fixtures';\nimport { PoolBuilder } from '../common/poolBuilder';\nimport { ProcessRunner } from '../common/process';\nimport { applyRepeatEachIndex, bindFileSuiteToProject, filterTestsRemoveEmptySuites } from '../common/suiteUtils';\nimport { loadTestFile } from '../common/testLoader';\n\nimport type { TimeSlot } from './timeoutManager';\nimport type { Location } from '../../types/testReporter';\nimport type { FullConfigInternal, FullProjectInternal } from '../common/config';\nimport type { DonePayload, RunPayload, TeardownErrorsPayload, TestBeginPayload, TestEndPayload, TestInfoErrorImpl, WorkerInitParams } from '../common/ipc';\nimport type { Suite, TestCase } from '../common/test';\nimport type { TestAnnotation } from '../../types/test';\n\nexport class WorkerMain extends ProcessRunner {\n  private _params: WorkerInitParams;\n  private _config!: FullConfigInternal;\n  private _project!: FullProjectInternal;\n  private _poolBuilder!: PoolBuilder;\n  private _fixtureRunner: FixtureRunner;\n\n  // Accumulated fatal errors that cannot be attributed to a test.\n  private _fatalErrors: TestInfoErrorImpl[] = [];\n  // Whether we should skip running remaining tests in this suite because\n  // of a setup error, usually beforeAll hook.\n  private _skipRemainingTestsInSuite: Suite | undefined;\n  // The stage of the full cleanup. Once \"finished\", we can safely stop running anything.\n  private _didRunFullCleanup = false;\n  // Whether the worker was requested to stop.\n  private _isStopped = false;\n  // This promise resolves once the single \"run test group\" call finishes.\n  private _runFinished = new ManualPromise<void>();\n  private _currentTest: TestInfoImpl | null = null;\n  private _lastRunningTests: TestCase[] = [];\n  private _totalRunningTests = 0;\n  // Suites that had their beforeAll hooks, but not afterAll hooks executed.\n  // These suites still need afterAll hooks to be executed for the proper cleanup.\n  // Contains dynamic annotations originated by modifiers with a callback, e.g. `test.skip(() => true)`.\n  private _activeSuites = new Map<Suite, TestAnnotation[]>();\n\n  constructor(params: WorkerInitParams) {\n    super();\n    process.env.TEST_WORKER_INDEX = String(params.workerIndex);\n    process.env.TEST_PARALLEL_INDEX = String(params.parallelIndex);\n    setIsWorkerProcess();\n\n    this._params = params;\n    this._fixtureRunner = new FixtureRunner();\n\n    // Resolve this promise, so worker does not stall waiting for the non-existent run to finish,\n    // when it was sopped before running any test group.\n    this._runFinished.resolve();\n\n    process.on('unhandledRejection', reason => this.unhandledError(reason));\n    process.on('uncaughtException', error => this.unhandledError(error));\n    // eslint-disable-next-line no-restricted-properties\n    process.stdout.write = (chunk: string | Buffer, cb?: any) => {\n      this.dispatchEvent('stdOut', stdioChunkToParams(chunk));\n      this._currentTest?._tracing.appendStdioToTrace('stdout', chunk);\n      if (typeof cb === 'function')\n        process.nextTick(cb);\n      return true;\n    };\n\n    if (!process.env.PW_RUNNER_DEBUG) {\n      // eslint-disable-next-line no-restricted-properties\n      process.stderr.write = (chunk: string | Buffer, cb?: any) => {\n        this.dispatchEvent('stdErr', stdioChunkToParams(chunk));\n        this._currentTest?._tracing.appendStdioToTrace('stderr', chunk);\n        if (typeof cb === 'function')\n          process.nextTick(cb);\n        return true;\n      };\n    }\n  }\n\n  private _stop(): Promise<void> {\n    if (!this._isStopped) {\n      this._isStopped = true;\n      this._currentTest?._interrupt();\n    }\n    return this._runFinished;\n  }\n\n  override async gracefullyClose() {\n    try {\n      await this._stop();\n      if (!this._config) {\n        // We never set anything up and we can crash on attempting cleanup\n        return;\n      }\n      // Ignore top-level errors, they are already inside TestInfo.errors.\n      const fakeTestInfo = new TestInfoImpl(this._config, this._project, this._params, undefined, 0, () => {}, () => {}, () => {});\n      const runnable = { type: 'teardown' } as const;\n      // We have to load the project to get the right deadline below.\n      await fakeTestInfo._runWithTimeout(runnable, () => this._loadIfNeeded()).catch(() => {});\n      await this._fixtureRunner.teardownScope('test', fakeTestInfo, runnable).catch(() => {});\n      await this._fixtureRunner.teardownScope('worker', fakeTestInfo, runnable).catch(() => {});\n      // Close any other browsers launched in this process. This includes anything launched\n      // manually in the test/hooks and internal browsers like Playwright Inspector.\n      await fakeTestInfo._runWithTimeout(runnable, () => gracefullyCloseAll()).catch(() => {});\n      this._fatalErrors.push(...fakeTestInfo.errors);\n    } catch (e) {\n      this._fatalErrors.push(testInfoError(e));\n    }\n\n    if (this._fatalErrors.length) {\n      this._appendProcessTeardownDiagnostics(this._fatalErrors[this._fatalErrors.length - 1]);\n      const payload: TeardownErrorsPayload = { fatalErrors: this._fatalErrors };\n      this.dispatchEvent('teardownErrors', payload);\n    }\n  }\n\n  private _appendProcessTeardownDiagnostics(error: TestInfoErrorImpl) {\n    if (!this._lastRunningTests.length)\n      return;\n    const count = this._totalRunningTests === 1 ? '1 test' : `${this._totalRunningTests} tests`;\n    let lastMessage = '';\n    if (this._lastRunningTests.length < this._totalRunningTests)\n      lastMessage = `, last ${this._lastRunningTests.length} tests were`;\n    const message = [\n      '',\n      '',\n      colors.red(`Failed worker ran ${count}${lastMessage}:`),\n      ...this._lastRunningTests.map(test => formatTestTitle(test, this._project.project.name)),\n    ].join('\\n');\n    if (error.message) {\n      if (error.stack) {\n        let index = error.stack.indexOf(error.message);\n        if (index !== -1) {\n          index += error.message.length;\n          error.stack = error.stack.substring(0, index) + message + error.stack.substring(index);\n        }\n      }\n      error.message += message;\n    } else if (error.value) {\n      error.value += message;\n    }\n  }\n\n  unhandledError(error: Error | any) {\n    // No current test - fatal error.\n    if (!this._currentTest) {\n      if (!this._fatalErrors.length)\n        this._fatalErrors.push(testInfoError(error));\n      void this._stop();\n      return;\n    }\n\n    // We do not differentiate between errors in the control flow\n    // and unhandled errors - both lead to the test failing. This is good for regular tests,\n    // so that you can, e.g. expect() from inside an event handler. The test fails,\n    // and we restart the worker.\n    if (!this._currentTest._hasUnhandledError) {\n      this._currentTest._hasUnhandledError = true;\n      this._currentTest._failWithError(error);\n    }\n\n    // For tests marked with test.fail(), this might be a problem when unhandled error\n    // is not coming from the user test code (legit failure), but from fixtures or test runner.\n    //\n    // Ideally, we would mark this test as \"failed unexpectedly\" and show that in the report.\n    // However, we do not have such a special test status, so the test will be considered ok (failed as expected).\n    //\n    // To avoid messing up future tests, we forcefully stop the worker, unless it is\n    // an expect() error which we know does not mess things up.\n    const isExpectError = (error instanceof Error) && !!(error as any).matcherResult;\n    const shouldContinueInThisWorker = this._currentTest.expectedStatus === 'failed' && isExpectError;\n    if (!shouldContinueInThisWorker)\n      void this._stop();\n  }\n\n  private async _loadIfNeeded() {\n    if (this._config)\n      return;\n\n    const config = await deserializeConfig(this._params.config);\n    const project = config.projects.find(p => p.id === this._params.projectId);\n    if (!project)\n      throw new Error(`Project \"${this._params.projectId}\" not found in the worker process. Make sure project name does not change.`);\n    this._config = config;\n    this._project = project;\n    this._poolBuilder = PoolBuilder.createForWorker(this._project);\n  }\n\n  async runTestGroup(runPayload: RunPayload) {\n    this._runFinished = new ManualPromise<void>();\n    const entries = new Map(runPayload.entries.map(e => [e.testId, e]));\n    let fatalUnknownTestIds: string[] | undefined;\n    try {\n      await this._loadIfNeeded();\n      const fileSuite = await loadTestFile(runPayload.file, this._config.config.rootDir);\n      const suite = bindFileSuiteToProject(this._project, fileSuite);\n      if (this._params.repeatEachIndex)\n        applyRepeatEachIndex(this._project, suite, this._params.repeatEachIndex);\n      const hasEntries = filterTestsRemoveEmptySuites(suite, test => entries.has(test.id));\n      if (hasEntries) {\n        this._poolBuilder.buildPools(suite);\n        this._activeSuites = new Map();\n        this._didRunFullCleanup = false;\n        const tests = suite.allTests();\n        for (let i = 0; i < tests.length; i++) {\n          // Do not run tests after full cleanup, because we are entirely done.\n          if (this._isStopped && this._didRunFullCleanup)\n            break;\n          const entry = entries.get(tests[i].id)!;\n          entries.delete(tests[i].id);\n          debugTest(`test started \"${tests[i].title}\"`);\n          await this._runTest(tests[i], entry.retry, tests[i + 1]);\n          debugTest(`test finished \"${tests[i].title}\"`);\n        }\n      } else {\n        fatalUnknownTestIds = runPayload.entries.map(e => e.testId);\n        void this._stop();\n      }\n    } catch (e) {\n      // In theory, we should run above code without any errors.\n      // However, in the case we screwed up, or loadTestFile failed in the worker\n      // but not in the runner, let's do a fatal error.\n      this._fatalErrors.push(testInfoError(e));\n      void this._stop();\n    } finally {\n      const donePayload: DonePayload = {\n        fatalErrors: this._fatalErrors,\n        skipTestsDueToSetupFailure: [],\n        fatalUnknownTestIds\n      };\n      for (const test of this._skipRemainingTestsInSuite?.allTests() || []) {\n        if (entries.has(test.id))\n          donePayload.skipTestsDueToSetupFailure.push(test.id);\n      }\n      this.dispatchEvent('done', donePayload);\n      this._fatalErrors = [];\n      this._skipRemainingTestsInSuite = undefined;\n      this._runFinished.resolve();\n    }\n  }\n\n  private async _runTest(test: TestCase, retry: number, nextTest: TestCase | undefined) {\n    const testInfo = new TestInfoImpl(this._config, this._project, this._params, test, retry,\n        stepBeginPayload => this.dispatchEvent('stepBegin', stepBeginPayload),\n        stepEndPayload => this.dispatchEvent('stepEnd', stepEndPayload),\n        attachment => this.dispatchEvent('attach', attachment));\n\n    const processAnnotation = (annotation: TestAnnotation) => {\n      testInfo.annotations.push(annotation);\n      switch (annotation.type) {\n        case 'fixme':\n        case 'skip':\n          testInfo.expectedStatus = 'skipped';\n          break;\n        case 'fail':\n          if (testInfo.expectedStatus !== 'skipped')\n            testInfo.expectedStatus = 'failed';\n          break;\n        case 'slow':\n          testInfo._timeoutManager.slow();\n          break;\n      }\n    };\n\n    if (!this._isStopped)\n      this._fixtureRunner.setPool(test._pool!);\n\n    const suites = getSuites(test);\n    const reversedSuites = suites.slice().reverse();\n    const nextSuites = new Set(getSuites(nextTest));\n\n    testInfo._timeoutManager.setTimeout(test.timeout);\n    for (const annotation of test.annotations)\n      processAnnotation(annotation);\n\n    // Process existing annotations dynamically set for parent suites.\n    for (const suite of suites) {\n      const extraAnnotations = this._activeSuites.get(suite) || [];\n      for (const annotation of extraAnnotations)\n        processAnnotation(annotation);\n    }\n\n    this._currentTest = testInfo;\n    setCurrentTestInfo(testInfo);\n    this.dispatchEvent('testBegin', buildTestBeginPayload(testInfo));\n\n    const isSkipped = testInfo.expectedStatus === 'skipped';\n    const hasAfterAllToRunBeforeNextTest = reversedSuites.some(suite => {\n      return this._activeSuites.has(suite) && !nextSuites.has(suite) && suite._hooks.some(hook => hook.type === 'afterAll');\n    });\n    if (isSkipped && nextTest && !hasAfterAllToRunBeforeNextTest) {\n      // Fast path - this test is skipped, and there are more tests that will handle cleanup.\n      testInfo.status = 'skipped';\n      this.dispatchEvent('testEnd', buildTestEndPayload(testInfo));\n      return;\n    }\n\n    this._totalRunningTests++;\n    this._lastRunningTests.push(test);\n    if (this._lastRunningTests.length > 10)\n      this._lastRunningTests.shift();\n    let shouldRunAfterEachHooks = false;\n\n    testInfo._allowSkips = true;\n\n    await (async () => {\n      await testInfo._runWithTimeout({ type: 'test' }, async () => {\n        // Ideally, \"trace\" would be an config-level option belonging to the\n        // test runner instead of a fixture belonging to Playwright.\n        // However, for backwards compatibility, we have to read it from a fixture today.\n        // We decided to not introduce the config-level option just yet.\n        const traceFixtureRegistration = test._pool!.resolve('trace');\n        if (!traceFixtureRegistration)\n          return;\n        if (typeof traceFixtureRegistration.fn === 'function')\n          throw new Error(`\"trace\" option cannot be a function`);\n        await testInfo._tracing.startIfNeeded(traceFixtureRegistration.fn);\n      });\n\n      if (this._isStopped || isSkipped) {\n        // Two reasons to get here:\n        // - Last test is skipped, so we should not run the test, but run the cleanup.\n        // - Worker is requested to stop, but was not able to run full cleanup yet.\n        //   We should skip the test, but run the cleanup.\n        testInfo.status = 'skipped';\n        return;\n      }\n\n      await removeFolders([testInfo.outputDir]);\n\n      let testFunctionParams: object | null = null;\n      await testInfo._runAsStep({ title: 'Before Hooks', category: 'hook' }, async () => {\n        // Run \"beforeAll\" hooks, unless already run during previous tests.\n        for (const suite of suites)\n          await this._runBeforeAllHooksForSuite(suite, testInfo);\n\n        // Run \"beforeEach\" hooks. Once started with \"beforeEach\", we must run all \"afterEach\" hooks as well.\n        shouldRunAfterEachHooks = true;\n        await this._runEachHooksForSuites(suites, 'beforeEach', testInfo);\n\n        // Setup fixtures required by the test.\n        testFunctionParams = await this._fixtureRunner.resolveParametersForFunction(test.fn, testInfo, 'test', { type: 'test' });\n      });\n\n      if (testFunctionParams === null) {\n        // Fixture setup failed or was skipped, we should not run the test now.\n        return;\n      }\n\n      await testInfo._runWithTimeout({ type: 'test' }, async () => {\n        // Now run the test itself.\n        const fn = test.fn; // Extract a variable to get a better stack trace (\"myTest\" vs \"TestCase.myTest [as fn]\").\n        await fn(testFunctionParams, testInfo);\n      });\n    })().catch(() => {});  // Ignore the top-level error, it is already inside TestInfo.errors.\n\n    // Update duration, so it is available in fixture teardown and afterEach hooks.\n    testInfo.duration = testInfo._timeoutManager.defaultSlot().elapsed | 0;\n\n    // No skips in after hooks.\n    testInfo._allowSkips = true;\n\n    // After hooks get an additional timeout.\n    const afterHooksTimeout = calculateMaxTimeout(this._project.project.timeout, testInfo.timeout);\n    const afterHooksSlot = { timeout: afterHooksTimeout, elapsed: 0 };\n    await testInfo._runAsStep({ title: 'After Hooks', category: 'hook' }, async () => {\n      let firstAfterHooksError: Error | undefined;\n\n      try {\n        // Run \"immediately upon test function finish\" callback.\n        await testInfo._runWithTimeout({ type: 'test', slot: afterHooksSlot }, async () => testInfo._onDidFinishTestFunction?.());\n      } catch (error) {\n        firstAfterHooksError = firstAfterHooksError ?? error;\n      }\n\n      try {\n        // Run \"afterEach\" hooks, unless we failed at beforeAll stage.\n        if (shouldRunAfterEachHooks)\n          await this._runEachHooksForSuites(reversedSuites, 'afterEach', testInfo, afterHooksSlot);\n      } catch (error) {\n        firstAfterHooksError = firstAfterHooksError ?? error;\n      }\n\n      testInfo._tracing.didFinishTestFunctionAndAfterEachHooks();\n\n      try {\n        // Teardown test-scoped fixtures. Attribute to 'test' so that users understand\n        // they should probably increase the test timeout to fix this issue.\n        await this._fixtureRunner.teardownScope('test', testInfo, { type: 'test', slot: afterHooksSlot });\n      } catch (error) {\n        firstAfterHooksError = firstAfterHooksError ?? error;\n      }\n\n      // Run \"afterAll\" hooks for suites that are not shared with the next test.\n      // In case of failure the worker will be stopped and we have to make sure that afterAll\n      // hooks run before worker fixtures teardown.\n      for (const suite of reversedSuites) {\n        if (!nextSuites.has(suite) || testInfo._isFailure()) {\n          try {\n            await this._runAfterAllHooksForSuite(suite, testInfo);\n          } catch (error) {\n            // Continue running \"afterAll\" hooks even after some of them timeout.\n            firstAfterHooksError = firstAfterHooksError ?? error;\n          }\n        }\n      }\n      if (firstAfterHooksError)\n        throw firstAfterHooksError;\n    }).catch(() => {});  // Ignore the top-level error, it is already inside TestInfo.errors.\n\n    if (testInfo._isFailure())\n      this._isStopped = true;\n\n    if (this._isStopped) {\n      // Run all remaining \"afterAll\" hooks and teardown all fixtures when worker is shutting down.\n      // Mark as \"cleaned up\" early to avoid running cleanup twice.\n      this._didRunFullCleanup = true;\n\n      await testInfo._runAsStep({ title: 'Worker Cleanup', category: 'hook' }, async () => {\n        let firstWorkerCleanupError: Error | undefined;\n\n        // Give it more time for the full cleanup.\n        const teardownSlot = { timeout: this._project.project.timeout, elapsed: 0 };\n        try {\n          // Attribute to 'test' so that users understand they should probably increate the test timeout to fix this issue.\n          await this._fixtureRunner.teardownScope('test', testInfo, { type: 'test', slot: teardownSlot });\n        } catch (error) {\n          firstWorkerCleanupError = firstWorkerCleanupError ?? error;\n        }\n\n        for (const suite of reversedSuites) {\n          try {\n            await this._runAfterAllHooksForSuite(suite, testInfo);\n          } catch (error) {\n            firstWorkerCleanupError = firstWorkerCleanupError ?? error;\n          }\n        }\n\n        try {\n          // Attribute to 'teardown' because worker fixtures are not perceived as a part of a test.\n          await this._fixtureRunner.teardownScope('worker', testInfo, { type: 'teardown', slot: teardownSlot });\n        } catch (error) {\n          firstWorkerCleanupError = firstWorkerCleanupError ?? error;\n        }\n\n        if (firstWorkerCleanupError)\n          throw firstWorkerCleanupError;\n      }).catch(() => {});  // Ignore the top-level error, it is already inside TestInfo.errors.\n    }\n\n    const tracingSlot = { timeout: this._project.project.timeout, elapsed: 0 };\n    await testInfo._runWithTimeout({ type: 'test', slot: tracingSlot }, async () => {\n      await testInfo._tracing.stopIfNeeded();\n    }).catch(() => {});  // Ignore the top-level error, it is already inside TestInfo.errors.\n\n    testInfo.duration = (testInfo._timeoutManager.defaultSlot().elapsed + afterHooksSlot.elapsed) | 0;\n\n    this._currentTest = null;\n    setCurrentTestInfo(null);\n    this.dispatchEvent('testEnd', buildTestEndPayload(testInfo));\n\n    const preserveOutput = this._config.config.preserveOutput === 'always' ||\n      (this._config.config.preserveOutput === 'failures-only' && testInfo._isFailure());\n    if (!preserveOutput)\n      await removeFolders([testInfo.outputDir]);\n  }\n\n  private _collectHooksAndModifiers(suite: Suite, type: 'beforeAll' | 'beforeEach' | 'afterAll' | 'afterEach', testInfo: TestInfoImpl) {\n    type Runnable = { type: 'beforeEach' | 'afterEach' | 'beforeAll' | 'afterAll' | 'fixme' | 'skip' | 'slow' | 'fail', fn: Function, title: string, location: Location };\n    const runnables: Runnable[] = [];\n    for (const modifier of suite._modifiers) {\n      const modifierType = this._fixtureRunner.dependsOnWorkerFixturesOnly(modifier.fn, modifier.location) ? 'beforeAll' : 'beforeEach';\n      if (modifierType !== type)\n        continue;\n      const fn = async (fixtures: any) => {\n        const result = await modifier.fn(fixtures);\n        testInfo._modifier(modifier.type, modifier.location, [!!result, modifier.description]);\n      };\n      inheritFixtureNames(modifier.fn, fn);\n      runnables.push({\n        title: `${modifier.type} modifier`,\n        location: modifier.location,\n        type: modifier.type,\n        fn,\n      });\n    }\n    // Modifiers first, then hooks.\n    runnables.push(...suite._hooks.filter(hook => hook.type === type));\n    return runnables;\n  }\n\n  private async _runBeforeAllHooksForSuite(suite: Suite, testInfo: TestInfoImpl) {\n    if (this._activeSuites.has(suite))\n      return;\n    const extraAnnotations: TestAnnotation[] = [];\n    this._activeSuites.set(suite, extraAnnotations);\n    await this._runAllHooksForSuite(suite, testInfo, 'beforeAll', extraAnnotations);\n  }\n\n  private async _runAllHooksForSuite(suite: Suite, testInfo: TestInfoImpl, type: 'beforeAll' | 'afterAll', extraAnnotations?: TestAnnotation[]) {\n    // Always run all the hooks, and capture the first error.\n    let firstError: Error | undefined;\n    for (const hook of this._collectHooksAndModifiers(suite, type, testInfo)) {\n      try {\n        await testInfo._runAsStep({ title: hook.title, category: 'hook', location: hook.location }, async () => {\n          // Separate time slot for each beforeAll/afterAll hook.\n          const timeSlot = { timeout: this._project.project.timeout, elapsed: 0 };\n          const runnable = { type: hook.type, slot: timeSlot, location: hook.location };\n          const existingAnnotations = new Set(testInfo.annotations);\n          try {\n            await this._fixtureRunner.resolveParametersAndRunFunction(hook.fn, testInfo, 'all-hooks-only', runnable);\n          } finally {\n            if (extraAnnotations) {\n              // Inherit all annotations defined in the beforeAll/modifer to all tests in the suite.\n              const newAnnotations = testInfo.annotations.filter(a => !existingAnnotations.has(a));\n              extraAnnotations.push(...newAnnotations);\n            }\n            // Each beforeAll/afterAll hook has its own scope for test fixtures. Attribute to the same runnable and timeSlot.\n            // Note: we must teardown even after hook fails, because we'll run more hooks.\n            await this._fixtureRunner.teardownScope('test', testInfo, runnable);\n          }\n        });\n      } catch (error) {\n        firstError = firstError ?? error;\n        // Skip in beforeAll/modifier prevents others from running.\n        if (type === 'beforeAll' && (error instanceof TestSkipError))\n          break;\n        if (type === 'beforeAll' && !this._skipRemainingTestsInSuite) {\n          // This will inform dispatcher that we should not run more tests from this group\n          // because we had a beforeAll error.\n          // This behavior avoids getting the same common error for each test.\n          this._skipRemainingTestsInSuite = suite;\n        }\n      }\n    }\n    if (firstError)\n      throw firstError;\n  }\n\n  private async _runAfterAllHooksForSuite(suite: Suite, testInfo: TestInfoImpl) {\n    if (!this._activeSuites.has(suite))\n      return;\n    this._activeSuites.delete(suite);\n    await this._runAllHooksForSuite(suite, testInfo, 'afterAll');\n  }\n\n  private async _runEachHooksForSuites(suites: Suite[], type: 'beforeEach' | 'afterEach', testInfo: TestInfoImpl, slot?: TimeSlot) {\n    // Always run all the hooks, unless one of the times out, and capture the first error.\n    let firstError: Error | undefined;\n    const hooks = suites.map(suite => this._collectHooksAndModifiers(suite, type, testInfo)).flat();\n    for (const hook of hooks) {\n      const runnable = { type: hook.type, location: hook.location, slot };\n      if (testInfo._timeoutManager.isTimeExhaustedFor(runnable)) {\n        // Do not run hooks that will timeout right away.\n        continue;\n      }\n      try {\n        await testInfo._runAsStep({ title: hook.title, category: 'hook', location: hook.location }, async () => {\n          await this._fixtureRunner.resolveParametersAndRunFunction(hook.fn, testInfo, 'test', runnable);\n        });\n      } catch (error) {\n        firstError = firstError ?? error;\n        // Skip in modifier prevents others from running.\n        if (error instanceof TestSkipError)\n          break;\n      }\n    }\n    if (firstError)\n      throw firstError;\n  }\n}\n\nfunction buildTestBeginPayload(testInfo: TestInfoImpl): TestBeginPayload {\n  return {\n    testId: testInfo.testId,\n    startWallTime: testInfo._startWallTime,\n  };\n}\n\nfunction buildTestEndPayload(testInfo: TestInfoImpl): TestEndPayload {\n  return {\n    testId: testInfo.testId,\n    duration: testInfo.duration,\n    status: testInfo.status!,\n    errors: testInfo.errors,\n    hasNonRetriableError: testInfo._hasNonRetriableError,\n    expectedStatus: testInfo.expectedStatus,\n    annotations: testInfo.annotations,\n    timeout: testInfo.timeout,\n  };\n}\n\nfunction getSuites(test: TestCase | undefined): Suite[] {\n  const suites: Suite[] = [];\n  for (let suite: Suite | undefined = test?.parent; suite; suite = suite.parent)\n    suites.push(suite);\n  suites.reverse();  // Put root suite first.\n  return suites;\n}\n\nfunction formatTestTitle(test: TestCase, projectName: string) {\n  // file, ...describes, test\n  const [, ...titles] = test.titlePath();\n  const location = `${relativeFilePath(test.location.file)}:${test.location.line}:${test.location.column}`;\n  const projectTitle = projectName ? `[${projectName}] \u203A ` : '';\n  return `${projectTitle}${location} \u203A ${titles.join(' \u203A ')}`;\n}\n\nfunction calculateMaxTimeout(t1: number, t2: number) {\n  // Zero means \"no timeout\".\n  return (!t1 || !t2) ? 0 : Math.max(t1, t2);\n}\n\nexport const create = (params: WorkerInitParams) => new WorkerMain(params);\n"],
  "mappings": "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",
  "names": ["import_utils", "import_util"]
}

{
  "version": 3,
  "sources": ["../../src/worker/testInfo.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { captureRawStack, monotonicTime, sanitizeForFilePath, stringifyStackFrames, currentZone, createGuid, escapeWithQuotes } from 'playwright-core/lib/utils';\n\nimport { TimeoutManager, TimeoutManagerError, kMaxDeadline } from './timeoutManager';\nimport { addSuffixToFilePath, filteredStackTrace, getContainedPath, normalizeAndSaveAttachment, sanitizeFilePathBeforeExtension, trimLongString, windowsFilesystemFriendlyLength } from '../util';\nimport { TestTracing } from './testTracing';\nimport { testInfoError } from './util';\nimport { wrapFunctionWithLocation } from '../transform/transform';\n\nimport type { RunnableDescription } from './timeoutManager';\nimport type { FullProject, TestInfo, TestStatus, TestStepInfo, TestAnnotation } from '../../types/test';\nimport type { FullConfig, Location } from '../../types/testReporter';\nimport type { FullConfigInternal, FullProjectInternal } from '../common/config';\nimport type { AttachmentPayload, StepBeginPayload, StepEndPayload, TestInfoErrorImpl, WorkerInitParams } from '../common/ipc';\nimport type { TestCase } from '../common/test';\nimport type { StackFrame } from '@protocol/channels';\n\nexport type TestStepCategory = 'expect' | 'fixture' | 'hook' | 'pw:api' | 'test.step' | 'test.attach';\n\ninterface TestStepData {\n  title: string;\n  category: TestStepCategory;\n  location?: Location;\n  apiName?: string;\n  params?: Record<string, any>;\n  infectParentStepsWithError?: boolean;\n  box?: boolean;\n  // steps with any defined group are hidden from the report\n  // 'internal' steps are hidden from the trace\n  group?: string;\n}\n\nexport interface TestStepInternal extends TestStepData {\n  complete(result: { error?: Error | unknown, suggestedRebaseline?: string }): void;\n  info: TestStepInfoImpl;\n  attachmentIndices: number[];\n  stepId: string;\n  boxedStack?: StackFrame[];\n  steps: TestStepInternal[];\n  endWallTime?: number;\n  error?: TestInfoErrorImpl;\n}\n\ntype SnapshotNames = {\n  lastAnonymousSnapshotIndex: number;\n  lastNamedSnapshotIndex: { [key: string]: number };\n};\n\nexport class TestInfoImpl implements TestInfo {\n  private _onStepBegin: (payload: StepBeginPayload) => void;\n  private _onStepEnd: (payload: StepEndPayload) => void;\n  private _onAttach: (payload: AttachmentPayload) => void;\n  private _snapshotNames: SnapshotNames = { lastAnonymousSnapshotIndex: 0, lastNamedSnapshotIndex: {} };\n  private _ariaSnapshotNames: SnapshotNames = { lastAnonymousSnapshotIndex: 0, lastNamedSnapshotIndex: {} };\n  readonly _timeoutManager: TimeoutManager;\n  readonly _startTime: number;\n  readonly _startWallTime: number;\n  readonly _tracing: TestTracing;\n  readonly _uniqueSymbol;\n\n  _wasInterrupted = false;\n  _lastStepId = 0;\n  private readonly _requireFile: string;\n  readonly _projectInternal: FullProjectInternal;\n  readonly _configInternal: FullConfigInternal;\n  private readonly _steps: TestStepInternal[] = [];\n  private readonly _stepMap = new Map<string, TestStepInternal>();\n  _onDidFinishTestFunction: (() => Promise<void>) | undefined;\n  _hasNonRetriableError = false;\n  _hasUnhandledError = false;\n  _allowSkips = false;\n\n  // ------------ Main methods ------------\n  skip: (arg?: any, description?: string) => void;\n  fixme: (arg?: any, description?: string) => void;\n  fail: (arg?: any, description?: string) => void;\n  slow: (arg?: any, description?: string) => void;\n\n  // ------------ TestInfo fields ------------\n  readonly testId: string;\n  readonly repeatEachIndex: number;\n  readonly retry: number;\n  readonly workerIndex: number;\n  readonly parallelIndex: number;\n  readonly project: FullProject;\n  readonly config: FullConfig;\n  readonly title: string;\n  readonly titlePath: string[];\n  readonly file: string;\n  readonly line: number;\n  readonly tags: string[];\n  readonly column: number;\n  readonly fn: Function;\n  expectedStatus: TestStatus;\n  duration: number = 0;\n  readonly annotations: TestAnnotation[] = [];\n  readonly attachments: TestInfo['attachments'] = [];\n  status: TestStatus = 'passed';\n  snapshotSuffix: string = '';\n  readonly outputDir: string;\n  readonly snapshotDir: string;\n  errors: TestInfoErrorImpl[] = [];\n  readonly _attachmentsPush: (...items: TestInfo['attachments']) => number;\n\n  get error(): TestInfoErrorImpl | undefined {\n    return this.errors[0];\n  }\n\n  set error(e: TestInfoErrorImpl | undefined) {\n    if (e === undefined)\n      throw new Error('Cannot assign testInfo.error undefined value!');\n    this.errors[0] = e;\n  }\n\n  get timeout(): number {\n    return this._timeoutManager.defaultSlot().timeout;\n  }\n\n  set timeout(timeout: number) {\n    // Ignored.\n  }\n\n  _deadlineForMatcher(timeout: number): { deadline: number, timeoutMessage: string } {\n    const startTime = monotonicTime();\n    const matcherDeadline = timeout ? startTime + timeout : kMaxDeadline;\n    const testDeadline = this._timeoutManager.currentSlotDeadline() - 250;\n    const matcherMessage = `Timeout ${timeout}ms exceeded while waiting on the predicate`;\n    const testMessage = `Test timeout of ${this.timeout}ms exceeded`;\n    return { deadline: Math.min(testDeadline, matcherDeadline), timeoutMessage: testDeadline < matcherDeadline ? testMessage : matcherMessage };\n  }\n\n  static _defaultDeadlineForMatcher(timeout: number): { deadline: any; timeoutMessage: any; } {\n    return { deadline: (timeout ? monotonicTime() + timeout : 0), timeoutMessage: `Timeout ${timeout}ms exceeded while waiting on the predicate` };\n  }\n\n  constructor(\n    configInternal: FullConfigInternal,\n    projectInternal: FullProjectInternal,\n    workerParams: WorkerInitParams,\n    test: TestCase | undefined,\n    retry: number,\n    onStepBegin: (payload: StepBeginPayload) => void,\n    onStepEnd: (payload: StepEndPayload) => void,\n    onAttach: (payload: AttachmentPayload) => void,\n  ) {\n    this.testId = test?.id ?? '';\n    this._onStepBegin = onStepBegin;\n    this._onStepEnd = onStepEnd;\n    this._onAttach = onAttach;\n    this._startTime = monotonicTime();\n    this._startWallTime = Date.now();\n    this._requireFile = test?._requireFile ?? '';\n    this._uniqueSymbol = Symbol('testInfoUniqueSymbol');\n\n    this.repeatEachIndex = workerParams.repeatEachIndex;\n    this.retry = retry;\n    this.workerIndex = workerParams.workerIndex;\n    this.parallelIndex =  workerParams.parallelIndex;\n    this._projectInternal = projectInternal;\n    this.project = projectInternal.project;\n    this._configInternal = configInternal;\n    this.config = configInternal.config;\n    this.title = test?.title ?? '';\n    this.titlePath = test?.titlePath() ?? [];\n    this.file = test?.location.file ?? '';\n    this.line = test?.location.line ?? 0;\n    this.column = test?.location.column ?? 0;\n    this.tags = test?.tags ?? [];\n    this.fn = test?.fn ?? (() => {});\n    this.expectedStatus = test?.expectedStatus ?? 'skipped';\n\n    this._timeoutManager = new TimeoutManager(this.project.timeout);\n    if (configInternal.configCLIOverrides.debug)\n      this._setDebugMode();\n\n    this.outputDir = (() => {\n      const relativeTestFilePath = path.relative(this.project.testDir, this._requireFile.replace(/\\.(spec|test)\\.(js|ts|jsx|tsx|mjs|mts|cjs|cts)$/, ''));\n      const sanitizedRelativePath = relativeTestFilePath.replace(process.platform === 'win32' ? new RegExp('\\\\\\\\', 'g') : new RegExp('/', 'g'), '-');\n      const fullTitleWithoutSpec = this.titlePath.slice(1).join(' ');\n\n      let testOutputDir = trimLongString(sanitizedRelativePath + '-' + sanitizeForFilePath(fullTitleWithoutSpec), windowsFilesystemFriendlyLength);\n      if (projectInternal.id)\n        testOutputDir += '-' + sanitizeForFilePath(projectInternal.id);\n      if (this.retry)\n        testOutputDir += '-retry' + this.retry;\n      if (this.repeatEachIndex)\n        testOutputDir += '-repeat' + this.repeatEachIndex;\n      return path.join(this.project.outputDir, testOutputDir);\n    })();\n\n    this.snapshotDir = (() => {\n      const relativeTestFilePath = path.relative(this.project.testDir, this._requireFile);\n      return path.join(this.project.snapshotDir, relativeTestFilePath + '-snapshots');\n    })();\n\n    this._attachmentsPush = this.attachments.push.bind(this.attachments);\n    this.attachments.push = (...attachments: TestInfo['attachments']) => {\n      for (const a of attachments)\n        this._attach(a, this._parentStep()?.stepId);\n      return this.attachments.length;\n    };\n\n    this._tracing = new TestTracing(this, workerParams.artifactsDir);\n\n    this.skip = wrapFunctionWithLocation((location, ...args) => this._modifier('skip', location, args));\n    this.fixme = wrapFunctionWithLocation((location, ...args) => this._modifier('fixme', location, args));\n    this.fail = wrapFunctionWithLocation((location, ...args) => this._modifier('fail', location, args));\n    this.slow = wrapFunctionWithLocation((location, ...args) => this._modifier('slow', location, args));\n  }\n\n  _modifier(type: 'skip' | 'fail' | 'fixme' | 'slow', location: Location, modifierArgs: [arg?: any, description?: string]) {\n    if (typeof modifierArgs[1] === 'function') {\n      throw new Error([\n        'It looks like you are calling test.skip() inside the test and pass a callback.',\n        'Pass a condition instead and optional description instead:',\n        `test('my test', async ({ page, isMobile }) => {`,\n        `  test.skip(isMobile, 'This test is not applicable on mobile');`,\n        `});`,\n      ].join('\\n'));\n    }\n\n    if (modifierArgs.length >= 1 && !modifierArgs[0])\n      return;\n\n    const description = modifierArgs[1];\n    this.annotations.push({ type, description, location });\n    if (type === 'slow') {\n      this._timeoutManager.slow();\n    } else if (type === 'skip' || type === 'fixme') {\n      this.expectedStatus = 'skipped';\n      throw new TestSkipError('Test is skipped: ' + (description || ''));\n    } else if (type === 'fail') {\n      if (this.expectedStatus !== 'skipped')\n        this.expectedStatus = 'failed';\n    }\n  }\n\n  private _findLastPredefinedStep(steps: TestStepInternal[]): TestStepInternal | undefined {\n    // Find the deepest predefined step that has not finished yet.\n    for (let i = steps.length - 1; i >= 0; i--) {\n      const child = this._findLastPredefinedStep(steps[i].steps);\n      if (child)\n        return child;\n      if ((steps[i].category === 'hook' || steps[i].category === 'fixture') && !steps[i].endWallTime)\n        return steps[i];\n    }\n  }\n\n  private _parentStep() {\n    return currentZone().data<TestStepInternal>('stepZone') ?? this._findLastPredefinedStep(this._steps);\n  }\n\n  _addStep(data: Readonly<TestStepData>, parentStep?: TestStepInternal): TestStepInternal {\n    const stepId = `${data.category}@${++this._lastStepId}`;\n\n    if (data.category === 'hook' || data.category === 'fixture') {\n      // Predefined steps form a fixed hierarchy - use the current one as parent.\n      parentStep = this._findLastPredefinedStep(this._steps);\n    } else {\n      if (!parentStep)\n        parentStep = this._parentStep();\n    }\n\n    const filteredStack = filteredStackTrace(captureRawStack());\n    let boxedStack = parentStep?.boxedStack;\n    let location = data.location;\n    if (!boxedStack && data.box) {\n      boxedStack = filteredStack.slice(1);\n      location = location || boxedStack[0];\n    }\n    location = location || filteredStack[0];\n\n    const step: TestStepInternal = {\n      ...data,\n      stepId,\n      group: parentStep?.group ?? data.group,\n      boxedStack,\n      location,\n      steps: [],\n      attachmentIndices: [],\n      info: new TestStepInfoImpl(this, stepId, data.title, parentStep?.info),\n      complete: result => {\n        if (step.endWallTime)\n          return;\n\n        step.endWallTime = Date.now();\n        if (result.error) {\n          if (typeof result.error === 'object' && !(result.error as any)?.[stepSymbol])\n            (result.error as any)[stepSymbol] = step;\n          const error = testInfoError(result.error);\n          if (step.boxedStack)\n            error.stack = `${error.message}\\n${stringifyStackFrames(step.boxedStack).join('\\n')}`;\n          step.error = error;\n        }\n\n        if (!step.error) {\n          // Soft errors inside try/catch will make the test fail.\n          // In order to locate the failing step, we are marking all the parent\n          // steps as failing unconditionally.\n          for (const childStep of step.steps) {\n            if (childStep.error && childStep.infectParentStepsWithError) {\n              step.error = childStep.error;\n              step.infectParentStepsWithError = true;\n              break;\n            }\n          }\n        }\n\n        if (!step.group) {\n          const payload: StepEndPayload = {\n            testId: this.testId,\n            stepId,\n            wallTime: step.endWallTime,\n            error: step.error,\n            suggestedRebaseline: result.suggestedRebaseline,\n            annotations: step.info.annotations,\n          };\n          this._onStepEnd(payload);\n        }\n        if (step.group !== 'internal') {\n          const errorForTrace = step.error ? { name: '', message: step.error.message || '', stack: step.error.stack } : undefined;\n          const attachments = step.attachmentIndices.map(i => this.attachments[i]);\n          this._tracing.appendAfterActionForStep(stepId, errorForTrace, attachments, step.info.annotations);\n        }\n      }\n    };\n    const parentStepList = parentStep ? parentStep.steps : this._steps;\n    parentStepList.push(step);\n    this._stepMap.set(stepId, step);\n\n    if (!step.group) {\n      const payload: StepBeginPayload = {\n        testId: this.testId,\n        stepId,\n        parentStepId: parentStep ? parentStep.stepId : undefined,\n        title: step.title,\n        category: step.category,\n        wallTime: Date.now(),\n        location: step.location,\n      };\n      this._onStepBegin(payload);\n    }\n    if (step.group !== 'internal') {\n      this._tracing.appendBeforeActionForStep({\n        stepId,\n        parentId: parentStep?.stepId,\n        title: step.title,\n        category: step.category,\n        params: step.params,\n        stack: step.location ? [step.location] : [],\n        group: step.group,\n      });\n    }\n\n    return step;\n  }\n\n  _interrupt() {\n    // Mark as interrupted so we can ignore TimeoutError thrown by interrupt() call.\n    this._wasInterrupted = true;\n    this._timeoutManager.interrupt();\n    // Do not overwrite existing failure (for example, unhandled rejection) with \"interrupted\".\n    if (this.status === 'passed')\n      this.status = 'interrupted';\n  }\n\n  _failWithError(error: Error | unknown) {\n    if (this.status === 'passed' || this.status === 'skipped')\n      this.status = error instanceof TimeoutManagerError ? 'timedOut' : 'failed';\n    const serialized = testInfoError(error);\n    const step: TestStepInternal | undefined = typeof error === 'object' ? (error as any)?.[stepSymbol] : undefined;\n    if (step && step.boxedStack)\n      serialized.stack = `${(error as Error).name}: ${(error as Error).message}\\n${stringifyStackFrames(step.boxedStack).join('\\n')}`;\n    this.errors.push(serialized);\n    this._tracing.appendForError(serialized);\n  }\n\n  async _runAsStep(stepInfo: { title: string, category: 'hook' | 'fixture', location?: Location, group?: string }, cb: () => Promise<any>) {\n    const step = this._addStep(stepInfo);\n    try {\n      await cb();\n      step.complete({});\n    } catch (error) {\n      step.complete({ error });\n      throw error;\n    }\n  }\n\n  async _runWithTimeout(runnable: RunnableDescription, cb: () => Promise<any>) {\n    try {\n      await this._timeoutManager.withRunnable(runnable, async () => {\n        try {\n          await cb();\n        } catch (e) {\n          if (this._allowSkips && (e instanceof TestSkipError)) {\n            if (this.status === 'passed')\n              this.status = 'skipped';\n          } else {\n            // Unfortunately, we have to handle user errors and timeout errors differently.\n            // Consider the following scenario:\n            // - locator.click times out\n            // - all steps containing the test function finish with TimeoutManagerError\n            // - test finishes, the page is closed and this triggers locator.click error\n            // - we would like to present the locator.click error to the user\n            // - therefore, we need a try/catch inside the \"run with timeout\" block and capture the error\n            this._failWithError(e);\n          }\n          throw e;\n        }\n      });\n    } catch (error) {\n      // When interrupting, we arrive here with a TimeoutManagerError, but we should not\n      // consider it a timeout.\n      if (!this._wasInterrupted && (error instanceof TimeoutManagerError))\n        this._failWithError(error);\n      throw error;\n    }\n  }\n\n  _isFailure() {\n    return this.status !== 'skipped' && this.status !== this.expectedStatus;\n  }\n\n  _currentHookType() {\n    const type = this._timeoutManager.currentSlotType();\n    return ['beforeAll', 'afterAll', 'beforeEach', 'afterEach'].includes(type) ? type : undefined;\n  }\n\n  _setDebugMode() {\n    this._timeoutManager.setIgnoreTimeouts();\n  }\n\n  // ------------ TestInfo methods ------------\n\n  async attach(name: string, options: { path?: string, body?: string | Buffer, contentType?: string } = {}) {\n    const step = this._addStep({\n      title: `Attach ${escapeWithQuotes(name, '\"')}`,\n      category: 'test.attach',\n    });\n    this._attach(\n        await normalizeAndSaveAttachment(this.outputPath(), name, options),\n        step.group ? undefined : step.stepId\n    );\n    step.complete({});\n  }\n\n  _attach(attachment: TestInfo['attachments'][0], stepId: string | undefined) {\n    const index = this._attachmentsPush(attachment) - 1;\n    if (stepId) {\n      this._stepMap.get(stepId)!.attachmentIndices.push(index);\n    } else {\n      const stepId = `attach@${createGuid()}`;\n      this._tracing.appendBeforeActionForStep({ stepId, title: `Attach ${escapeWithQuotes(attachment.name, '\"')}`, category: 'test.attach', stack: [] });\n      this._tracing.appendAfterActionForStep(stepId, undefined, [attachment]);\n    }\n\n    this._onAttach({\n      testId: this.testId,\n      name: attachment.name,\n      contentType: attachment.contentType,\n      path: attachment.path,\n      body: attachment.body?.toString('base64'),\n      stepId,\n    });\n  }\n\n  outputPath(...pathSegments: string[]){\n    const outputPath = this._getOutputPath(...pathSegments);\n    fs.mkdirSync(this.outputDir, { recursive: true });\n    return outputPath;\n  }\n\n  _getOutputPath(...pathSegments: string[]){\n    const joinedPath = path.join(...pathSegments);\n    const outputPath = getContainedPath(this.outputDir, joinedPath);\n    if (outputPath)\n      return outputPath;\n    throw new Error(`The outputPath is not allowed outside of the parent directory. Please fix the defined path.\\n\\n\\toutputPath: ${joinedPath}`);\n  }\n\n  _fsSanitizedTestName() {\n    const fullTitleWithoutSpec = this.titlePath.slice(1).join(' ');\n    return sanitizeForFilePath(trimLongString(fullTitleWithoutSpec));\n  }\n\n  _resolveSnapshotPaths(kind: 'snapshot' | 'screenshot' | 'aria', name: string | string[] | undefined, updateSnapshotIndex: 'updateSnapshotIndex' | 'dontUpdateSnapshotIndex', anonymousExtension?: string) {\n    // NOTE: snapshot path must not ever change for backwards compatibility!\n\n    const snapshotNames = kind === 'aria' ? this._ariaSnapshotNames : this._snapshotNames;\n    const defaultExtensions = { 'aria': '.aria.yml', 'screenshot': '.png', 'snapshot': '.txt' };\n    const ariaAwareExtname = (filePath: string) => kind === 'aria' && filePath.endsWith('.aria.yml') ? '.aria.yml' : path.extname(filePath);\n\n    let subPath: string;\n    let ext: string;\n    let relativeOutputPath: string;\n\n    if (!name) {\n      // Consider the use case below. We should save actual to different paths, so we use |nextAnonymousSnapshotIndex|.\n      //\n      //   expect.toMatchSnapshot('a.png')\n      //   // noop\n      //   expect.toMatchSnapshot('a.png')\n      const index = snapshotNames.lastAnonymousSnapshotIndex + 1;\n      if (updateSnapshotIndex === 'updateSnapshotIndex')\n        snapshotNames.lastAnonymousSnapshotIndex = index;\n      const fullTitleWithoutSpec = [...this.titlePath.slice(1), index].join(' ');\n      ext = anonymousExtension ?? defaultExtensions[kind];\n      subPath = sanitizeFilePathBeforeExtension(trimLongString(fullTitleWithoutSpec) + ext, ext);\n      // Trim the output file paths more aggressively to avoid hitting Windows filesystem limits.\n      relativeOutputPath = sanitizeFilePathBeforeExtension(trimLongString(fullTitleWithoutSpec, windowsFilesystemFriendlyLength) + ext, ext);\n    } else {\n      if (Array.isArray(name)) {\n        // We intentionally do not sanitize user-provided array of segments,\n        // assuming it is a file system path.\n        // See https://github.com/microsoft/playwright/pull/9156.\n        subPath = path.join(...name);\n        relativeOutputPath = path.join(...name);\n        ext = ariaAwareExtname(subPath);\n      } else {\n        ext = ariaAwareExtname(name);\n        subPath = sanitizeFilePathBeforeExtension(name, ext);\n        // Trim the output file paths more aggressively to avoid hitting Windows filesystem limits.\n        relativeOutputPath = sanitizeFilePathBeforeExtension(trimLongString(name, windowsFilesystemFriendlyLength), ext);\n      }\n      const index = (snapshotNames.lastNamedSnapshotIndex[relativeOutputPath] || 0) + 1;\n      if (updateSnapshotIndex === 'updateSnapshotIndex')\n        snapshotNames.lastNamedSnapshotIndex[relativeOutputPath] = index;\n      if (index > 1)\n        relativeOutputPath = addSuffixToFilePath(relativeOutputPath, `-${index - 1}`);\n    }\n\n    const absoluteSnapshotPath = this._applyPathTemplate(kind, subPath, ext);\n    return { absoluteSnapshotPath, relativeOutputPath };\n  }\n\n  private _applyPathTemplate(kind: 'snapshot' | 'screenshot' | 'aria', relativePath: string, ext: string) {\n    const legacyTemplate = '{snapshotDir}/{testFileDir}/{testFileName}-snapshots/{arg}{-projectName}{-snapshotSuffix}{ext}';\n    let template: string;\n    if (kind === 'screenshot') {\n      template = this._projectInternal.expect?.toHaveScreenshot?.pathTemplate || this._projectInternal.snapshotPathTemplate || legacyTemplate;\n    } else if (kind === 'aria') {\n      const ariaDefaultTemplate = '{snapshotDir}/{testFileDir}/{testFileName}-snapshots/{arg}{ext}';\n      template = this._projectInternal.expect?.toMatchAriaSnapshot?.pathTemplate || this._projectInternal.snapshotPathTemplate || ariaDefaultTemplate;\n    } else {\n      template = this._projectInternal.snapshotPathTemplate || legacyTemplate;\n    }\n\n    const dir = path.dirname(relativePath);\n    const name = path.basename(relativePath, ext);\n    const relativeTestFilePath = path.relative(this.project.testDir, this._requireFile);\n    const parsedRelativeTestFilePath = path.parse(relativeTestFilePath);\n    const projectNamePathSegment = sanitizeForFilePath(this.project.name);\n\n    const snapshotPath = template\n        .replace(/\\{(.)?testDir\\}/g, '$1' + this.project.testDir)\n        .replace(/\\{(.)?snapshotDir\\}/g, '$1' + this.project.snapshotDir)\n        .replace(/\\{(.)?snapshotSuffix\\}/g, this.snapshotSuffix ? '$1' + this.snapshotSuffix : '')\n        .replace(/\\{(.)?testFileDir\\}/g, '$1' + parsedRelativeTestFilePath.dir)\n        .replace(/\\{(.)?platform\\}/g, '$1' + process.platform)\n        .replace(/\\{(.)?projectName\\}/g, projectNamePathSegment ? '$1' + projectNamePathSegment : '')\n        .replace(/\\{(.)?testName\\}/g, '$1' + this._fsSanitizedTestName())\n        .replace(/\\{(.)?testFileName\\}/g, '$1' + parsedRelativeTestFilePath.base)\n        .replace(/\\{(.)?testFilePath\\}/g, '$1' + relativeTestFilePath)\n        .replace(/\\{(.)?arg\\}/g, '$1' + path.join(dir, name))\n        .replace(/\\{(.)?ext\\}/g, ext ? '$1' + ext : '');\n\n    return path.normalize(path.resolve(this._configInternal.configDir, snapshotPath));\n  }\n\n  snapshotPath(...name: string[]): string;\n  snapshotPath(name: string, options: { kind: 'snapshot' | 'screenshot' | 'aria' }): string;\n  snapshotPath(...args: any[]) {\n    let name: string[] = args;\n    let kind: 'snapshot' | 'screenshot' | 'aria' = 'snapshot';\n\n    const options = args[args.length - 1];\n    if (options && typeof options === 'object') {\n      kind = options.kind ?? kind;\n      name = args.slice(0, -1);\n    }\n\n    if (!['snapshot', 'screenshot', 'aria'].includes(kind))\n      throw new Error(`testInfo.snapshotPath: unknown kind \"${kind}\", must be one of \"snapshot\", \"screenshot\" or \"aria\"`);\n\n    // Assume a zero/single path segment corresponds to `toHaveScreenshot(name)`,\n    // while multiple path segments correspond to `toHaveScreenshot([...name])`.\n    return this._resolveSnapshotPaths(kind, name.length <= 1 ? name[0] : name, 'dontUpdateSnapshotIndex').absoluteSnapshotPath;\n  }\n\n  setTimeout(timeout: number) {\n    this._timeoutManager.setTimeout(timeout);\n  }\n}\n\nexport class TestStepInfoImpl implements TestStepInfo {\n  annotations: TestAnnotation[] = [];\n\n  private _testInfo: TestInfoImpl;\n  private _stepId: string;\n  private _title: string;\n  private _parentStep?: TestStepInfoImpl;\n\n  skip: (arg?: any, description?: string) => void;\n\n  constructor(testInfo: TestInfoImpl, stepId: string, title: string, parentStep?: TestStepInfoImpl) {\n    this._testInfo = testInfo;\n    this._stepId = stepId;\n    this._title = title;\n    this._parentStep = parentStep;\n    this.skip = wrapFunctionWithLocation((location: Location, ...args: unknown[]) => {\n      // skip();\n      // skip(condition: boolean, description: string);\n      if (args.length > 0 && !args[0])\n        return;\n      const description = args[1] as (string|undefined);\n      this.annotations.push({ type: 'skip', description, location });\n      throw new StepSkipError(description);\n    });\n  }\n\n  async _runStepBody<T>(skip: boolean, body: (step: TestStepInfo) => T | Promise<T>, location?: Location) {\n    if (skip) {\n      this.annotations.push({ type: 'skip', location });\n      return undefined as T;\n    }\n    try {\n      return await body(this);\n    } catch (e) {\n      if (e instanceof StepSkipError)\n        return undefined as T;\n      throw e;\n    }\n  }\n\n  _attachToStep(attachment: TestInfo['attachments'][0]): void {\n    this._testInfo._attach(attachment, this._stepId);\n  }\n\n  async attach(name: string, options?: { body?: string | Buffer; contentType?: string; path?: string; }): Promise<void> {\n    this._attachToStep(await normalizeAndSaveAttachment(this._testInfo.outputPath(), name, options));\n  }\n\n  get titlePath(): string[] {\n    const parent = this._parentStep ?? this._testInfo;\n    return [...parent.titlePath, this._title];\n  }\n}\n\nexport class TestSkipError extends Error {\n}\n\nexport class StepSkipError extends Error {\n}\n\nconst stepSymbol = Symbol('step');\n"],
  "mappings": "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",
  "names": ["import_util", "path", "stepId", "fs"]
}

{
  "version": 3,
  "sources": ["../../src/client/jsHandle.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChannelOwner } from './channelOwner';\nimport { isTargetClosedError } from './errors';\nimport { parseSerializedValue, serializeValue } from '../protocol/serializers';\n\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\n\n\nexport class JSHandle<T = any> extends ChannelOwner<channels.JSHandleChannel> implements api.JSHandle {\n  private _preview: string;\n\n  static from(handle: channels.JSHandleChannel): JSHandle {\n    return (handle as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer) {\n    super(parent, type, guid, initializer);\n    this._preview = this._initializer.preview;\n    this._channel.on('previewUpdated', ({ preview }) => this._preview = preview);\n  }\n\n  async evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<R> {\n    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async _evaluateFunction(functionDeclaration: string) {\n    const result = await this._channel.evaluateExpression({ expression: functionDeclaration, isFunction: true, arg: serializeArgument(undefined) });\n    return parseResult(result.value);\n  }\n\n  async evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>> {\n    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return JSHandle.from(result.handle) as any as structs.SmartHandle<R>;\n  }\n\n  async getProperty(propertyName: string): Promise<JSHandle> {\n    const result = await this._channel.getProperty({ name: propertyName });\n    return JSHandle.from(result.handle);\n  }\n\n  async getProperties(): Promise<Map<string, JSHandle>> {\n    const map = new Map<string, JSHandle>();\n    for (const { name, value } of (await this._channel.getPropertyList()).properties)\n      map.set(name, JSHandle.from(value));\n    return map;\n  }\n\n  async jsonValue(): Promise<T> {\n    return parseResult((await this._channel.jsonValue()).value);\n  }\n\n  asElement(): T extends Node ? api.ElementHandle<T> : null {\n    return null as any;\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.dispose();\n  }\n\n  async dispose() {\n    try {\n      await this._channel.dispose();\n    } catch (e) {\n      if (isTargetClosedError(e))\n        return;\n      throw e;\n    }\n  }\n\n  override toString(): string {\n    return this._preview;\n  }\n}\n\n// This function takes care of converting all JSHandles to their channels,\n// so that generic channel serializer converts them to guids.\nexport function serializeArgument(arg: any): channels.SerializedArgument {\n  const handles: channels.Channel[] = [];\n  const pushHandle = (channel: channels.Channel): number => {\n    handles.push(channel);\n    return handles.length - 1;\n  };\n  const value = serializeValue(arg, value => {\n    if (value instanceof JSHandle)\n      return { h: pushHandle(value._channel) };\n    return { fallThrough: value };\n  });\n  return { value, handles };\n}\n\nexport function parseResult(value: channels.SerializedValue): any {\n  return parseSerializedValue(value, undefined);\n}\n\nexport function assertMaxArguments(count: number, max: number): asserts count {\n  if (count > max)\n    throw new Error('Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.');\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,0BAA6B;AAC7B,oBAAoC;AACpC,yBAAqD;AAO9C,MAAM,iBAA0B,iCAA+D;AAAA,EAGpG,OAAO,KAAK,QAA4C;AACtD,WAAQ,OAAe;AAAA,EACzB;AAAA,EAEA,YAAY,QAAsB,MAAc,MAAc,aAA2C;AACvG,UAAM,QAAQ,MAAM,MAAM,WAAW;AACrC,SAAK,WAAW,KAAK,aAAa;AAClC,SAAK,SAAS,GAAG,kBAAkB,CAAC,EAAE,QAAQ,MAAM,KAAK,WAAW,OAAO;AAAA,EAC7E;AAAA,EAEA,MAAM,SAAiB,cAAiD,KAAuB;AAC7F,UAAM,SAAS,MAAM,KAAK,SAAS,mBAAmB,EAAE,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,iBAAiB,YAAY,KAAK,kBAAkB,GAAG,EAAE,CAAC;AACvK,WAAO,YAAY,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,MAAM,kBAAkB,qBAA6B;AACnD,UAAM,SAAS,MAAM,KAAK,SAAS,mBAAmB,EAAE,YAAY,qBAAqB,YAAY,MAAM,KAAK,kBAAkB,MAAS,EAAE,CAAC;AAC9I,WAAO,YAAY,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,MAAM,eAAuB,cAAiD,KAA4C;AACxH,UAAM,SAAS,MAAM,KAAK,SAAS,yBAAyB,EAAE,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,iBAAiB,YAAY,KAAK,kBAAkB,GAAG,EAAE,CAAC;AAC7K,WAAO,SAAS,KAAK,OAAO,MAAM;AAAA,EACpC;AAAA,EAEA,MAAM,YAAY,cAAyC;AACzD,UAAM,SAAS,MAAM,KAAK,SAAS,YAAY,EAAE,MAAM,aAAa,CAAC;AACrE,WAAO,SAAS,KAAK,OAAO,MAAM;AAAA,EACpC;AAAA,EAEA,MAAM,gBAAgD;AACpD,UAAM,MAAM,oBAAI,IAAsB;AACtC,eAAW,EAAE,MAAM,MAAM,MAAM,MAAM,KAAK,SAAS,gBAAgB,GAAG;AACpE,UAAI,IAAI,MAAM,SAAS,KAAK,KAAK,CAAC;AACpC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,YAAwB;AAC5B,WAAO,aAAa,MAAM,KAAK,SAAS,UAAU,GAAG,KAAK;AAAA,EAC5D;AAAA,EAEA,YAA0D;AACxD,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,OAAO,YAAY,IAAI;AAC5B,UAAM,KAAK,QAAQ;AAAA,EACrB;AAAA,EAEA,MAAM,UAAU;AACd,QAAI;AACF,YAAM,KAAK,SAAS,QAAQ;AAAA,IAC9B,SAAS,GAAG;AACV,cAAI,mCAAoB,CAAC;AACvB;AACF,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAES,WAAmB;AAC1B,WAAO,KAAK;AAAA,EACd;AACF;AAIO,SAAS,kBAAkB,KAAuC;AACvE,QAAM,UAA8B,CAAC;AACrC,QAAM,aAAa,CAAC,YAAsC;AACxD,YAAQ,KAAK,OAAO;AACpB,WAAO,QAAQ,SAAS;AAAA,EAC1B;AACA,QAAM,YAAQ,mCAAe,KAAK,CAAAA,WAAS;AACzC,QAAIA,kBAAiB;AACnB,aAAO,EAAE,GAAG,WAAWA,OAAM,QAAQ,EAAE;AACzC,WAAO,EAAE,aAAaA,OAAM;AAAA,EAC9B,CAAC;AACD,SAAO,EAAE,OAAO,QAAQ;AAC1B;AAEO,SAAS,YAAY,OAAsC;AAChE,aAAO,yCAAqB,OAAO,MAAS;AAC9C;AAEO,SAAS,mBAAmB,OAAe,KAA4B;AAC5E,MAAI,QAAQ;AACV,UAAM,IAAI,MAAM,sGAAsG;AAC1H;",
  "names": ["value"]
}

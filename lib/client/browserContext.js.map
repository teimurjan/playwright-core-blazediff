{
  "version": 3,
  "sources": ["../../src/client/browserContext.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Artifact } from './artifact';\nimport { Browser } from './browser';\nimport { CDPSession } from './cdpSession';\nimport { ChannelOwner } from './channelOwner';\nimport { evaluationScript } from './clientHelper';\nimport { Clock } from './clock';\nimport { ConsoleMessage } from './consoleMessage';\nimport { Dialog } from './dialog';\nimport { TargetClosedError, parseError } from './errors';\nimport { Events } from './events';\nimport { APIRequestContext } from './fetch';\nimport { Frame } from './frame';\nimport { HarRouter } from './harRouter';\nimport * as network from './network';\nimport { BindingCall, Page } from './page';\nimport { Tracing } from './tracing';\nimport { Waiter } from './waiter';\nimport { WebError } from './webError';\nimport { Worker } from './worker';\nimport { TimeoutSettings } from './timeoutSettings';\nimport { mkdirIfNeeded } from './fileUtils';\nimport { headersObjectToArray } from '../utils/isomorphic/headers';\nimport { urlMatchesEqual } from '../utils/isomorphic/urlMatch';\nimport { isRegExp, isString } from '../utils/isomorphic/rtti';\nimport { rewriteErrorMessage } from '../utils/isomorphic/stackTrace';\n\nimport type { BrowserContextOptions, Headers, SetStorageState, StorageState, WaitForEventOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nimport type * as actions from '@recorder/actions';\n\ninterface RecorderEventSink {\n  actionAdded?(page: Page, actionInContext: actions.ActionInContext, code: string): void;\n  actionUpdated?(page: Page, actionInContext: actions.ActionInContext, code: string): void;\n  signalAdded?(page: Page, signal: actions.SignalInContext): void;\n}\n\nexport class BrowserContext extends ChannelOwner<channels.BrowserContextChannel> implements api.BrowserContext {\n  _pages = new Set<Page>();\n  _routes: network.RouteHandler[] = [];\n  _webSocketRoutes: network.WebSocketRouteHandler[] = [];\n  // Browser is null for browser contexts created outside of normal browser, e.g. android or electron.\n  _browser: Browser | null = null;\n  readonly _bindings = new Map<string, (source: structs.BindingSource, ...args: any[]) => any>();\n  _timeoutSettings: TimeoutSettings;\n  _ownerPage: Page | undefined;\n  _forReuse = false;\n  private _closedPromise: Promise<void>;\n  readonly _options: channels.BrowserNewContextParams;\n\n  readonly request: APIRequestContext;\n  readonly tracing: Tracing;\n  readonly clock: Clock;\n\n  readonly _backgroundPages = new Set<Page>();\n  readonly _serviceWorkers = new Set<Worker>();\n  private _harRecorders = new Map<string, { path: string, content: 'embed' | 'attach' | 'omit' | undefined }>();\n  _closingStatus: 'none' | 'closing' | 'closed' = 'none';\n  private _closeReason: string | undefined;\n  private _harRouters: HarRouter[] = [];\n  private _onRecorderEventSink: RecorderEventSink | undefined;\n\n  static from(context: channels.BrowserContextChannel): BrowserContext {\n    return (context as any)._object;\n  }\n\n  static fromNullable(context: channels.BrowserContextChannel | null): BrowserContext | null {\n    return context ? BrowserContext.from(context) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BrowserContextInitializer) {\n    super(parent, type, guid, initializer);\n    this._options = initializer.options;\n    this._timeoutSettings = new TimeoutSettings(this._platform);\n    this.tracing = Tracing.from(initializer.tracing);\n    this.request = APIRequestContext.from(initializer.requestContext);\n    this.request._timeoutSettings = this._timeoutSettings;\n    this.clock = new Clock(this);\n\n    this._channel.on('bindingCall', ({ binding }) => this._onBinding(BindingCall.from(binding)));\n    this._channel.on('close', () => this._onClose());\n    this._channel.on('page', ({ page }) => this._onPage(Page.from(page)));\n    this._channel.on('route', ({ route }) => this._onRoute(network.Route.from(route)));\n    this._channel.on('webSocketRoute', ({ webSocketRoute }) => this._onWebSocketRoute(network.WebSocketRoute.from(webSocketRoute)));\n    this._channel.on('backgroundPage', ({ page }) => {\n      const backgroundPage = Page.from(page);\n      this._backgroundPages.add(backgroundPage);\n      this.emit(Events.BrowserContext.BackgroundPage, backgroundPage);\n    });\n    this._channel.on('serviceWorker', ({ worker }) => {\n      const serviceWorker = Worker.from(worker);\n      serviceWorker._context = this;\n      this._serviceWorkers.add(serviceWorker);\n      this.emit(Events.BrowserContext.ServiceWorker, serviceWorker);\n    });\n    this._channel.on('console', event => {\n      const consoleMessage = new ConsoleMessage(this._platform, event);\n      this.emit(Events.BrowserContext.Console, consoleMessage);\n      const page = consoleMessage.page();\n      if (page)\n        page.emit(Events.Page.Console, consoleMessage);\n    });\n    this._channel.on('pageError', ({ error, page }) => {\n      const pageObject = Page.from(page);\n      const parsedError = parseError(error);\n      this.emit(Events.BrowserContext.WebError, new WebError(pageObject, parsedError));\n      if (pageObject)\n        pageObject.emit(Events.Page.PageError, parsedError);\n    });\n    this._channel.on('dialog', ({ dialog }) => {\n      const dialogObject = Dialog.from(dialog);\n      let hasListeners = this.emit(Events.BrowserContext.Dialog, dialogObject);\n      const page = dialogObject.page();\n      if (page)\n        hasListeners = page.emit(Events.Page.Dialog, dialogObject) || hasListeners;\n      if (!hasListeners) {\n        // Although we do similar handling on the server side, we still need this logic\n        // on the client side due to a possible race condition between two async calls:\n        // a) removing \"dialog\" listener subscription (client->server)\n        // b) actual \"dialog\" event (server->client)\n        if (dialogObject.type() === 'beforeunload')\n          dialog.accept({}).catch(() => {});\n        else\n          dialog.dismiss().catch(() => {});\n      }\n    });\n    this._channel.on('request', ({ request, page }) => this._onRequest(network.Request.from(request), Page.fromNullable(page)));\n    this._channel.on('requestFailed', ({ request, failureText, responseEndTiming, page }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, Page.fromNullable(page)));\n    this._channel.on('requestFinished', params => this._onRequestFinished(params));\n    this._channel.on('response', ({ response, page }) => this._onResponse(network.Response.from(response), Page.fromNullable(page)));\n    this._channel.on('recorderEvent', ({ event, data, page, code }) => {\n      if (event === 'actionAdded')\n        this._onRecorderEventSink?.actionAdded?.(Page.from(page), data as actions.ActionInContext, code);\n      else if (event === 'actionUpdated')\n        this._onRecorderEventSink?.actionUpdated?.(Page.from(page), data as actions.ActionInContext, code);\n      else if (event === 'signalAdded')\n        this._onRecorderEventSink?.signalAdded?.(Page.from(page), data as actions.SignalInContext);\n    });\n    this._closedPromise = new Promise(f => this.once(Events.BrowserContext.Close, f));\n\n    this._setEventToSubscriptionMapping(new Map<string, channels.BrowserContextUpdateSubscriptionParams['event']>([\n      [Events.BrowserContext.Console, 'console'],\n      [Events.BrowserContext.Dialog, 'dialog'],\n      [Events.BrowserContext.Request, 'request'],\n      [Events.BrowserContext.Response, 'response'],\n      [Events.BrowserContext.RequestFinished, 'requestFinished'],\n      [Events.BrowserContext.RequestFailed, 'requestFailed'],\n    ]));\n  }\n\n  async _initializeHarFromOptions(recordHar: BrowserContextOptions['recordHar']) {\n    if (!recordHar)\n      return;\n    const defaultContent = recordHar.path.endsWith('.zip') ? 'attach' : 'embed';\n    await this._recordIntoHAR(recordHar.path, null, {\n      url: recordHar.urlFilter,\n      updateContent: recordHar.content ?? (recordHar.omitContent ? 'omit' : defaultContent),\n      updateMode: recordHar.mode ?? 'full',\n    });\n  }\n\n  private _onPage(page: Page): void {\n    this._pages.add(page);\n    this.emit(Events.BrowserContext.Page, page);\n    if (page._opener && !page._opener.isClosed())\n      page._opener.emit(Events.Page.Popup, page);\n  }\n\n  private _onRequest(request: network.Request, page: Page | null) {\n    this.emit(Events.BrowserContext.Request, request);\n    if (page)\n      page.emit(Events.Page.Request, request);\n  }\n\n  private _onResponse(response: network.Response, page: Page | null) {\n    this.emit(Events.BrowserContext.Response, response);\n    if (page)\n      page.emit(Events.Page.Response, response);\n  }\n\n  private _onRequestFailed(request: network.Request, responseEndTiming: number, failureText: string | undefined, page: Page | null) {\n    request._failureText = failureText || null;\n    request._setResponseEndTiming(responseEndTiming);\n    this.emit(Events.BrowserContext.RequestFailed, request);\n    if (page)\n      page.emit(Events.Page.RequestFailed, request);\n  }\n\n  private _onRequestFinished(params: channels.BrowserContextRequestFinishedEvent) {\n    const { responseEndTiming } = params;\n    const request = network.Request.from(params.request);\n    const response = network.Response.fromNullable(params.response);\n    const page = Page.fromNullable(params.page);\n    request._setResponseEndTiming(responseEndTiming);\n    this.emit(Events.BrowserContext.RequestFinished, request);\n    if (page)\n      page.emit(Events.Page.RequestFinished, request);\n    if (response)\n      response._finishedPromise.resolve(null);\n  }\n\n  async _onRoute(route: network.Route) {\n    route._context = this;\n    const page = route.request()._safePage();\n    const routeHandlers = this._routes.slice();\n    for (const routeHandler of routeHandlers) {\n      // If the page or the context was closed we stall all requests right away.\n      if (page?._closeWasCalled || this._closingStatus !== 'none')\n        return;\n      if (!routeHandler.matches(route.request().url()))\n        continue;\n      const index = this._routes.indexOf(routeHandler);\n      if (index === -1)\n        continue;\n      if (routeHandler.willExpire())\n        this._routes.splice(index, 1);\n      const handled = await routeHandler.handle(route);\n      if (!this._routes.length)\n        this._updateInterceptionPatterns({ internal: true }).catch(() => {});\n      if (handled)\n        return;\n    }\n    // If the page is closed or unrouteAll() was called without waiting and interception disabled,\n    // the method will throw an error - silence it.\n    await route._innerContinue(true /* isFallback */).catch(() => {});\n  }\n\n  async _onWebSocketRoute(webSocketRoute: network.WebSocketRoute) {\n    const routeHandler = this._webSocketRoutes.find(route => route.matches(webSocketRoute.url()));\n    if (routeHandler)\n      await routeHandler.handle(webSocketRoute);\n    else\n      webSocketRoute.connectToServer();\n  }\n\n  async _onBinding(bindingCall: BindingCall) {\n    const func = this._bindings.get(bindingCall._initializer.name);\n    if (!func)\n      return;\n    await bindingCall.call(func);\n  }\n\n  setDefaultNavigationTimeout(timeout: number | undefined) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n\n  setDefaultTimeout(timeout: number | undefined) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n\n  browser(): Browser | null {\n    return this._browser;\n  }\n\n  pages(): Page[] {\n    return [...this._pages];\n  }\n\n  async newPage(): Promise<Page> {\n    if (this._ownerPage)\n      throw new Error('Please use browser.newContext()');\n    return Page.from((await this._channel.newPage()).page);\n  }\n\n  async cookies(urls?: string | string[]): Promise<network.NetworkCookie[]> {\n    if (!urls)\n      urls = [];\n    if (urls && typeof urls === 'string')\n      urls = [urls];\n    return (await this._channel.cookies({ urls: urls as string[] })).cookies;\n  }\n\n  async addCookies(cookies: network.SetNetworkCookieParam[]): Promise<void> {\n    await this._channel.addCookies({ cookies });\n  }\n\n  async clearCookies(options: network.ClearNetworkCookieOptions = {}): Promise<void> {\n    await this._channel.clearCookies({\n      name: isString(options.name) ? options.name : undefined,\n      nameRegexSource: isRegExp(options.name) ? options.name.source : undefined,\n      nameRegexFlags: isRegExp(options.name) ? options.name.flags : undefined,\n      domain: isString(options.domain) ? options.domain : undefined,\n      domainRegexSource: isRegExp(options.domain) ? options.domain.source : undefined,\n      domainRegexFlags: isRegExp(options.domain) ? options.domain.flags : undefined,\n      path: isString(options.path) ? options.path : undefined,\n      pathRegexSource: isRegExp(options.path) ? options.path.source : undefined,\n      pathRegexFlags: isRegExp(options.path) ? options.path.flags : undefined,\n    });\n  }\n\n  async grantPermissions(permissions: string[], options?: { origin?: string }): Promise<void> {\n    await this._channel.grantPermissions({ permissions, ...options });\n  }\n\n  async clearPermissions(): Promise<void> {\n    await this._channel.clearPermissions();\n  }\n\n  async setGeolocation(geolocation: { longitude: number, latitude: number, accuracy?: number } | null): Promise<void> {\n    await this._channel.setGeolocation({ geolocation: geolocation || undefined });\n  }\n\n  async setExtraHTTPHeaders(headers: Headers): Promise<void> {\n    network.validateHeaders(headers);\n    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });\n  }\n\n  async setOffline(offline: boolean): Promise<void> {\n    await this._channel.setOffline({ offline });\n  }\n\n  async setHTTPCredentials(httpCredentials: { username: string, password: string } | null): Promise<void> {\n    await this._channel.setHTTPCredentials({ httpCredentials: httpCredentials || undefined });\n  }\n\n  async addInitScript(script: Function | string | { path?: string, content?: string }, arg?: any): Promise<void> {\n    const source = await evaluationScript(this._platform, script, arg);\n    await this._channel.addInitScript({ source });\n  }\n\n  async exposeBinding(name: string, callback: (source: structs.BindingSource, ...args: any[]) => any, options: { handle?: boolean } = {}): Promise<void> {\n    await this._channel.exposeBinding({ name, needsHandle: options.handle });\n    this._bindings.set(name, callback);\n  }\n\n  async exposeFunction(name: string, callback: Function): Promise<void> {\n    await this._channel.exposeBinding({ name });\n    const binding = (source: structs.BindingSource, ...args: any[]) => callback(...args);\n    this._bindings.set(name, binding);\n  }\n\n  async route(url: URLMatch, handler: network.RouteHandlerCallback, options: { times?: number } = {}): Promise<void> {\n    this._routes.unshift(new network.RouteHandler(this._platform, this._options.baseURL, url, handler, options.times));\n    await this._updateInterceptionPatterns({ title: 'Route requests' });\n  }\n\n  async routeWebSocket(url: URLMatch, handler: network.WebSocketRouteHandlerCallback): Promise<void> {\n    this._webSocketRoutes.unshift(new network.WebSocketRouteHandler(this._options.baseURL, url, handler));\n    await this._updateWebSocketInterceptionPatterns({ title: 'Route WebSockets' });\n  }\n\n  async _recordIntoHAR(har: string, page: Page | null, options: { url?: string | RegExp, updateContent?: 'attach' | 'embed' | 'omit', updateMode?: 'minimal' | 'full'} = {}): Promise<void> {\n    const { harId } = await this._channel.harStart({\n      page: page?._channel,\n      options: {\n        zip: har.endsWith('.zip'),\n        content: options.updateContent ?? 'attach',\n        urlGlob: isString(options.url) ? options.url : undefined,\n        urlRegexSource: isRegExp(options.url) ? options.url.source : undefined,\n        urlRegexFlags: isRegExp(options.url) ? options.url.flags : undefined,\n        mode: options.updateMode ?? 'minimal',\n      },\n    });\n    this._harRecorders.set(harId, { path: har, content: options.updateContent ?? 'attach' });\n  }\n\n  async routeFromHAR(har: string, options: { url?: string | RegExp, notFound?: 'abort' | 'fallback', update?: boolean, updateContent?: 'attach' | 'embed', updateMode?: 'minimal' | 'full' } = {}): Promise<void> {\n    const localUtils = this._connection.localUtils();\n    if (!localUtils)\n      throw new Error('Route from har is not supported in thin clients');\n    if (options.update) {\n      await this._recordIntoHAR(har, null, options);\n      return;\n    }\n    const harRouter = await HarRouter.create(localUtils, har, options.notFound || 'abort', { urlMatch: options.url });\n    this._harRouters.push(harRouter);\n    await harRouter.addContextRoute(this);\n  }\n\n  private _disposeHarRouters() {\n    this._harRouters.forEach(router => router.dispose());\n    this._harRouters = [];\n  }\n\n  async unrouteAll(options?: { behavior?: 'wait'|'ignoreErrors'|'default' }): Promise<void> {\n    await this._unrouteInternal(this._routes, [], options?.behavior);\n    this._disposeHarRouters();\n  }\n\n  async unroute(url: URLMatch, handler?: network.RouteHandlerCallback): Promise<void> {\n    const removed = [];\n    const remaining = [];\n    for (const route of this._routes) {\n      if (urlMatchesEqual(route.url, url) && (!handler || route.handler === handler))\n        removed.push(route);\n      else\n        remaining.push(route);\n    }\n    await this._unrouteInternal(removed, remaining, 'default');\n  }\n\n  private async _unrouteInternal(removed: network.RouteHandler[], remaining: network.RouteHandler[], behavior?: 'wait'|'ignoreErrors'|'default'): Promise<void> {\n    this._routes = remaining;\n    if (behavior && behavior !== 'default') {\n      const promises = removed.map(routeHandler => routeHandler.stop(behavior));\n      await Promise.all(promises);\n    }\n    await this._updateInterceptionPatterns({ title: 'Unroute requests' });\n  }\n\n  private async _updateInterceptionPatterns(options: { internal: true } | { title: string }) {\n    const patterns = network.RouteHandler.prepareInterceptionPatterns(this._routes);\n    await this._wrapApiCall(() => this._channel.setNetworkInterceptionPatterns({ patterns }), options);\n  }\n\n  private async _updateWebSocketInterceptionPatterns(options: { internal: true } | { title: string }) {\n    const patterns = network.WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);\n    await this._wrapApiCall(() => this._channel.setWebSocketInterceptionPatterns({ patterns }), options);\n  }\n\n  _effectiveCloseReason(): string | undefined {\n    return this._closeReason || this._browser?._closeReason;\n  }\n\n  async waitForEvent(event: string, optionsOrPredicate: WaitForEventOptions = {}): Promise<any> {\n    return await this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function'  ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function'  ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== Events.BrowserContext.Close)\n        waiter.rejectOnEvent(this, Events.BrowserContext.Close, () => new TargetClosedError(this._effectiveCloseReason()));\n      const result = await waiter.waitForEvent(this, event, predicate as any);\n      waiter.dispose();\n      return result;\n    });\n  }\n\n  async storageState(options: { path?: string, indexedDB?: boolean } = {}): Promise<StorageState> {\n    const state = await this._channel.storageState({ indexedDB: options.indexedDB });\n    if (options.path) {\n      await mkdirIfNeeded(this._platform, options.path);\n      await this._platform.fs().promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');\n    }\n    return state;\n  }\n\n  backgroundPages(): Page[] {\n    return [...this._backgroundPages];\n  }\n\n  serviceWorkers(): Worker[] {\n    return [...this._serviceWorkers];\n  }\n\n  async newCDPSession(page: Page | Frame): Promise<api.CDPSession> {\n    // channelOwner.ts's validation messages don't handle the pseudo-union type, so we're explicit here\n    if (!(page instanceof Page) && !(page instanceof Frame))\n      throw new Error('page: expected Page or Frame');\n    const result = await this._channel.newCDPSession(page instanceof Page ? { page: page._channel } : { frame: page._channel });\n    return CDPSession.from(result.session);\n  }\n\n  _onClose() {\n    this._closingStatus = 'closed';\n    this._browser?._contexts.delete(this);\n    this._browser?._browserType._contexts.delete(this);\n    this._browser?._browserType._playwright.selectors._contextsForSelectors.delete(this);\n    this._disposeHarRouters();\n    this.tracing._resetStackCounter();\n    this.emit(Events.BrowserContext.Close, this);\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n\n  async close(options: { reason?: string } = {}): Promise<void> {\n    if (this._closingStatus !== 'none')\n      return;\n    this._closeReason = options.reason;\n    this._closingStatus = 'closing';\n    await this.request.dispose(options);\n    await this._instrumentation.runBeforeCloseBrowserContext(this);\n    await this._wrapApiCall(async () => {\n      for (const [harId, harParams] of this._harRecorders) {\n        const har = await this._channel.harExport({ harId });\n        const artifact = Artifact.from(har.artifact);\n        // Server side will compress artifact if content is attach or if file is .zip.\n        const isCompressed = harParams.content === 'attach' || harParams.path.endsWith('.zip');\n        const needCompressed = harParams.path.endsWith('.zip');\n        if (isCompressed && !needCompressed) {\n          const localUtils = this._connection.localUtils();\n          if (!localUtils)\n            throw new Error('Uncompressed har is not supported in thin clients');\n          await artifact.saveAs(harParams.path + '.tmp');\n          await localUtils.harUnzip({ zipFile: harParams.path + '.tmp', harFile: harParams.path });\n        } else {\n          await artifact.saveAs(harParams.path);\n        }\n        await artifact.delete();\n      }\n    }, { internal: true });\n    await this._channel.close(options);\n    await this._closedPromise;\n  }\n\n  async _enableRecorder(params: channels.BrowserContextEnableRecorderParams, eventSink?: RecorderEventSink) {\n    if (eventSink)\n      this._onRecorderEventSink = eventSink;\n    await this._channel.enableRecorder(params);\n  }\n\n  async _disableRecorder() {\n    this._onRecorderEventSink = undefined;\n    await this._channel.disableRecorder();\n  }\n}\n\nasync function prepareStorageState(platform: Platform, storageState: string | SetStorageState): Promise<NonNullable<channels.BrowserNewContextParams['storageState']>> {\n  if (typeof storageState !== 'string')\n    return storageState as any;\n  try {\n    return JSON.parse(await platform.fs().promises.readFile(storageState, 'utf8'));\n  } catch (e) {\n    rewriteErrorMessage(e, `Error reading storage state from ${storageState}:\\n` + e.message);\n    throw e;\n  }\n}\n\nexport async function prepareBrowserContextParams(platform: Platform, options: BrowserContextOptions): Promise<channels.BrowserNewContextParams> {\n  if (options.videoSize && !options.videosPath)\n    throw new Error(`\"videoSize\" option requires \"videosPath\" to be specified`);\n  if (options.extraHTTPHeaders)\n    network.validateHeaders(options.extraHTTPHeaders);\n  const contextParams: channels.BrowserNewContextParams = {\n    ...options,\n    viewport: options.viewport === null ? undefined : options.viewport,\n    noDefaultViewport: options.viewport === null,\n    extraHTTPHeaders: options.extraHTTPHeaders ? headersObjectToArray(options.extraHTTPHeaders) : undefined,\n    storageState: options.storageState ? await prepareStorageState(platform, options.storageState) : undefined,\n    serviceWorkers: options.serviceWorkers,\n    colorScheme: options.colorScheme === null ? 'no-override' : options.colorScheme,\n    reducedMotion: options.reducedMotion === null ? 'no-override' : options.reducedMotion,\n    forcedColors: options.forcedColors === null ? 'no-override' : options.forcedColors,\n    contrast: options.contrast === null ? 'no-override' : options.contrast,\n    acceptDownloads: toAcceptDownloadsProtocol(options.acceptDownloads),\n    clientCertificates: await toClientCertificatesProtocol(platform, options.clientCertificates),\n  };\n  if (!contextParams.recordVideo && options.videosPath) {\n    contextParams.recordVideo = {\n      dir: options.videosPath,\n      size: options.videoSize\n    };\n  }\n  if (contextParams.recordVideo && contextParams.recordVideo.dir)\n    contextParams.recordVideo.dir = platform.path().resolve(contextParams.recordVideo.dir);\n  return contextParams;\n}\n\nfunction toAcceptDownloadsProtocol(acceptDownloads?: boolean) {\n  if (acceptDownloads === undefined)\n    return undefined;\n  if (acceptDownloads)\n    return 'accept';\n  return 'deny';\n}\n\nexport async function toClientCertificatesProtocol(platform: Platform, certs?: BrowserContextOptions['clientCertificates']): Promise<channels.PlaywrightNewRequestParams['clientCertificates']> {\n  if (!certs)\n    return undefined;\n\n  const bufferizeContent = async (value?: Buffer, path?: string): Promise<Buffer | undefined> => {\n    if (value)\n      return value;\n    if (path)\n      return await platform.fs().promises.readFile(path);\n  };\n\n  return await Promise.all(certs.map(async cert => ({\n    origin: cert.origin,\n    cert: await bufferizeContent(cert.cert, cert.certPath),\n    key: await bufferizeContent(cert.key, cert.keyPath),\n    pfx: await bufferizeContent(cert.pfx, cert.pfxPath),\n    passphrase: cert.passphrase,\n  })));\n}\n"],
  "mappings": "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",
  "names": []
}

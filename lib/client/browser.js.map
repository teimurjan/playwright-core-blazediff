{
  "version": 3,
  "sources": ["../../src/client/browser.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Artifact } from './artifact';\nimport { BrowserContext, prepareBrowserContextParams } from './browserContext';\nimport { CDPSession } from './cdpSession';\nimport { ChannelOwner } from './channelOwner';\nimport { isTargetClosedError } from './errors';\nimport { Events } from './events';\nimport { mkdirIfNeeded } from './fileUtils';\n\nimport type { BrowserType } from './browserType';\nimport type { Page } from './page';\nimport type { BrowserContextOptions, LaunchOptions, LaunchServerOptions, Logger } from './types';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\n\nexport class Browser extends ChannelOwner<channels.BrowserChannel> implements api.Browser {\n  readonly _contexts = new Set<BrowserContext>();\n  private _isConnected = true;\n  private _closedPromise: Promise<void>;\n  _shouldCloseConnectionOnClose = false;\n  _browserType!: BrowserType;\n  _options: LaunchOptions = {};\n  readonly _name: string;\n  private _path: string | undefined;\n  _closeReason: string | undefined;\n\n  static from(browser: channels.BrowserChannel): Browser {\n    return (browser as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BrowserInitializer) {\n    super(parent, type, guid, initializer);\n    this._name = initializer.name;\n    this._channel.on('context', ({ context }) => this._didCreateContext(BrowserContext.from(context)));\n    this._channel.on('close', () => this._didClose());\n    this._closedPromise = new Promise(f => this.once(Events.Browser.Disconnected, f));\n  }\n\n  browserType(): BrowserType {\n    return this._browserType;\n  }\n\n  async newContext(options: BrowserContextOptions = {}): Promise<BrowserContext> {\n    return await this._innerNewContext(options, false);\n  }\n\n  async _newContextForReuse(options: BrowserContextOptions = {}): Promise<BrowserContext> {\n    return await this._innerNewContext(options, true);\n  }\n\n  async _disconnectFromReusedContext(reason: string) {\n    const context = [...this._contexts].find(context => context._forReuse);\n    if (!context)\n      return;\n    await this._instrumentation.runBeforeCloseBrowserContext(context);\n    for (const page of context.pages())\n      page._onClose();\n    context._onClose();\n    await this._channel.disconnectFromReusedContext({ reason });\n  }\n\n  async _innerNewContext(options: BrowserContextOptions = {}, forReuse: boolean): Promise<BrowserContext> {\n    options = this._browserType._playwright.selectors._withSelectorOptions({\n      ...this._browserType._playwright._defaultContextOptions,\n      ...options,\n    });\n    const contextOptions = await prepareBrowserContextParams(this._platform, options);\n    const response = forReuse ? await this._channel.newContextForReuse(contextOptions) : await this._channel.newContext(contextOptions);\n    const context = BrowserContext.from(response.context);\n    if (forReuse)\n      context._forReuse = true;\n    if (options.logger)\n      context._logger = options.logger;\n    await context._initializeHarFromOptions(options.recordHar);\n    await this._instrumentation.runAfterCreateBrowserContext(context);\n    return context;\n  }\n\n  _connectToBrowserType(browserType: BrowserType, browserOptions: LaunchOptions, logger: Logger | undefined) {\n    // Note: when using connect(), `browserType` is different from `this._parent`.\n    // This is why browser type is not wired up in the constructor,\n    // and instead this separate method is called later on.\n    this._browserType = browserType;\n    this._options = browserOptions;\n    this._logger = logger;\n    for (const context of this._contexts)\n      this._setupBrowserContext(context);\n  }\n\n  private _didCreateContext(context: BrowserContext) {\n    context._browser = this;\n    this._contexts.add(context);\n    // Note: when connecting to a browser, initial contexts arrive before `browserType` is set,\n    // and will be configured later in `_connectToBrowserType`.\n    if (this._browserType)\n      this._setupBrowserContext(context);\n  }\n\n  private _setupBrowserContext(context: BrowserContext) {\n    context._logger = this._logger;\n    context.tracing._tracesDir = this._options.tracesDir;\n    this._browserType._contexts.add(context);\n    this._browserType._playwright.selectors._contextsForSelectors.add(context);\n    context.setDefaultTimeout(this._browserType._playwright._defaultContextTimeout);\n    context.setDefaultNavigationTimeout(this._browserType._playwright._defaultContextNavigationTimeout);\n  }\n\n  contexts(): BrowserContext[] {\n    return [...this._contexts];\n  }\n\n  version(): string {\n    return this._initializer.version;\n  }\n\n  async newPage(options: BrowserContextOptions = {}): Promise<Page> {\n    return await this._wrapApiCall(async () => {\n      const context = await this.newContext(options);\n      const page = await context.newPage();\n      page._ownedContext = context;\n      context._ownerPage = page;\n      return page;\n    }, { title: 'Create page' });\n  }\n\n  isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  async newBrowserCDPSession(): Promise<api.CDPSession> {\n    return CDPSession.from((await this._channel.newBrowserCDPSession()).session);\n  }\n\n  async _launchServer(options: LaunchServerOptions = {}) {\n    const serverLauncher = this._browserType._serverLauncher;\n    const browserImpl = this._connection.toImpl?.(this);\n    if (!serverLauncher || !browserImpl)\n      throw new Error('Launching server is not supported');\n    return await serverLauncher.launchServerOnExistingBrowser(browserImpl, {\n      _sharedBrowser: true,\n      ...options,\n    });\n  }\n\n  async startTracing(page?: Page, options: { path?: string; screenshots?: boolean; categories?: string[]; } = {}) {\n    this._path = options.path;\n    await this._channel.startTracing({ ...options, page: page ? page._channel : undefined });\n  }\n\n  async stopTracing(): Promise<Buffer> {\n    const artifact = Artifact.from((await this._channel.stopTracing()).artifact);\n    const buffer = await artifact.readIntoBuffer();\n    await artifact.delete();\n    if (this._path) {\n      await mkdirIfNeeded(this._platform, this._path);\n      await this._platform.fs().promises.writeFile(this._path, buffer);\n      this._path = undefined;\n    }\n    return buffer;\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n\n  async close(options: { reason?: string } = {}): Promise<void> {\n    this._closeReason = options.reason;\n    try {\n      if (this._shouldCloseConnectionOnClose)\n        this._connection.close();\n      else\n        await this._channel.close(options);\n      await this._closedPromise;\n    } catch (e) {\n      if (isTargetClosedError(e))\n        return;\n      throw e;\n    }\n  }\n\n  _didClose() {\n    this._isConnected = false;\n    this.emit(Events.Browser.Disconnected, this);\n  }\n}\n"],
  "mappings": "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",
  "names": ["context"]
}

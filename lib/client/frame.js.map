{
  "version": 3,
  "sources": ["../../src/client/frame.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from './eventEmitter';\nimport { ChannelOwner } from './channelOwner';\nimport { addSourceUrlToScript } from './clientHelper';\nimport { ElementHandle, convertInputFiles, convertSelectOptionValues } from './elementHandle';\nimport { Events } from './events';\nimport { JSHandle, assertMaxArguments, parseResult, serializeArgument } from './jsHandle';\nimport { FrameLocator, Locator, testIdAttributeName } from './locator';\nimport * as network from './network';\nimport { kLifecycleEvents } from './types';\nimport { Waiter } from './waiter';\nimport { assert } from '../utils/isomorphic/assert';\nimport { getByAltTextSelector, getByLabelSelector, getByPlaceholderSelector, getByRoleSelector, getByTestIdSelector, getByTextSelector, getByTitleSelector } from '../utils/isomorphic/locatorUtils';\nimport { urlMatches } from '../utils/isomorphic/urlMatch';\nimport { TimeoutSettings } from './timeoutSettings';\n\nimport type { LocatorOptions } from './locator';\nimport type { Page } from './page';\nimport type { FilePayload, LifecycleEvent, SelectOption, SelectOptionOptions, StrictOptions, TimeoutOptions, WaitForFunctionOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\n\nexport type WaitForNavigationOptions = {\n  timeout?: number,\n  waitUntil?: LifecycleEvent,\n  url?: URLMatch,\n};\n\nexport class Frame extends ChannelOwner<channels.FrameChannel> implements api.Frame {\n  _eventEmitter: EventEmitter;\n  _loadStates: Set<LifecycleEvent>;\n  _parentFrame: Frame | null = null;\n  _url = '';\n  _name = '';\n  _detached = false;\n  _childFrames = new Set<Frame>();\n  _page: Page | undefined;\n\n  static from(frame: channels.FrameChannel): Frame {\n    return (frame as any)._object;\n  }\n\n  static fromNullable(frame: channels.FrameChannel | undefined): Frame | null {\n    return frame ? Frame.from(frame) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.FrameInitializer) {\n    super(parent, type, guid, initializer);\n    this._eventEmitter = new EventEmitter(parent._platform);\n    this._eventEmitter.setMaxListeners(0);\n    this._parentFrame = Frame.fromNullable(initializer.parentFrame);\n    if (this._parentFrame)\n      this._parentFrame._childFrames.add(this);\n    this._name = initializer.name;\n    this._url = initializer.url;\n    this._loadStates = new Set(initializer.loadStates);\n    this._channel.on('loadstate', event => {\n      if (event.add) {\n        this._loadStates.add(event.add);\n        this._eventEmitter.emit('loadstate', event.add);\n      }\n      if (event.remove)\n        this._loadStates.delete(event.remove);\n      if (!this._parentFrame && event.add === 'load' && this._page)\n        this._page.emit(Events.Page.Load, this._page);\n      if (!this._parentFrame && event.add === 'domcontentloaded' && this._page)\n        this._page.emit(Events.Page.DOMContentLoaded, this._page);\n    });\n    this._channel.on('navigated', event => {\n      this._url = event.url;\n      this._name = event.name;\n      this._eventEmitter.emit('navigated', event);\n      if (!event.error && this._page)\n        this._page.emit(Events.Page.FrameNavigated, this);\n    });\n  }\n\n  page(): Page {\n    return this._page!;\n  }\n\n  _timeout(options?: TimeoutOptions): number {\n    const timeoutSettings = this._page?._timeoutSettings || new TimeoutSettings(this._platform);\n    return timeoutSettings.timeout(options || {});\n  }\n\n  _navigationTimeout(options?: TimeoutOptions): number {\n    const timeoutSettings = this._page?._timeoutSettings || new TimeoutSettings(this._platform);\n    return timeoutSettings.navigationTimeout(options || {});\n  }\n\n  async goto(url: string, options: channels.FrameGotoOptions & TimeoutOptions = {}): Promise<network.Response | null> {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return network.Response.fromNullable((await this._channel.goto({ url, ...options, waitUntil, timeout: this._navigationTimeout(options) })).response);\n  }\n\n  private _setupNavigationWaiter(options: { timeout?: number }): Waiter {\n    const waiter = new Waiter(this._page!, '');\n    if (this._page!.isClosed())\n      waiter.rejectImmediately(this._page!._closeErrorWithReason());\n    waiter.rejectOnEvent(this._page!, Events.Page.Close, () => this._page!._closeErrorWithReason());\n    waiter.rejectOnEvent(this._page!, Events.Page.Crash, new Error('Navigation failed because page crashed!'));\n    waiter.rejectOnEvent<Frame>(this._page!, Events.Page.FrameDetached, new Error('Navigating frame was detached!'), frame => frame === this);\n    const timeout = this._page!._timeoutSettings.navigationTimeout(options);\n    waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);\n    return waiter;\n  }\n\n  async waitForNavigation(options: WaitForNavigationOptions = {}): Promise<network.Response | null> {\n    return await this._page!._wrapApiCall(async () => {\n      const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n      const waiter = this._setupNavigationWaiter(options);\n\n      const toUrl = typeof options.url === 'string' ? ` to \"${options.url}\"` : '';\n      waiter.log(`waiting for navigation${toUrl} until \"${waitUntil}\"`);\n\n      const navigatedEvent = await waiter.waitForEvent<channels.FrameNavigatedEvent>(this._eventEmitter, 'navigated', event => {\n        // Any failed navigation results in a rejection.\n        if (event.error)\n          return true;\n        waiter.log(`  navigated to \"${event.url}\"`);\n        return urlMatches(this._page?.context()._options.baseURL, event.url, options.url);\n      });\n      if (navigatedEvent.error) {\n        const e = new Error(navigatedEvent.error);\n        e.stack = '';\n        await waiter.waitForPromise(Promise.reject(e));\n      }\n\n      if (!this._loadStates.has(waitUntil)) {\n        await waiter.waitForEvent<LifecycleEvent>(this._eventEmitter, 'loadstate', s => {\n          waiter.log(`  \"${s}\" event fired`);\n          return s === waitUntil;\n        });\n      }\n\n      const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;\n      const response = request ? await waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;\n      waiter.dispose();\n      return response;\n    }, { title: 'Wait for navigation' });\n  }\n\n  async waitForLoadState(state: LifecycleEvent = 'load', options: { timeout?: number } = {}): Promise<void> {\n    state = verifyLoadState('state', state);\n    return await this._page!._wrapApiCall(async () => {\n      const waiter = this._setupNavigationWaiter(options);\n      if (this._loadStates.has(state)) {\n        waiter.log(`  not waiting, \"${state}\" event already fired`);\n      } else {\n        await waiter.waitForEvent<LifecycleEvent>(this._eventEmitter, 'loadstate', s => {\n          waiter.log(`  \"${s}\" event fired`);\n          return s === state;\n        });\n      }\n      waiter.dispose();\n    }, { title: `Wait for load state \"${state}\"` });\n  }\n\n  async waitForURL(url: URLMatch, options: { waitUntil?: LifecycleEvent, timeout?: number } = {}): Promise<void> {\n    if (urlMatches(this._page?.context()._options.baseURL, this.url(), url))\n      return await this.waitForLoadState(options.waitUntil, options);\n\n    await this.waitForNavigation({ url, ...options });\n  }\n\n  async frameElement(): Promise<ElementHandle> {\n    return ElementHandle.from((await this._channel.frameElement()).element);\n  }\n\n  async evaluateHandle<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>> {\n    assertMaxArguments(arguments.length, 2);\n    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return JSHandle.from(result.handle) as any as structs.SmartHandle<R>;\n  }\n\n  async evaluate<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 2);\n    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async _evaluateFunction(functionDeclaration: string) {\n    const result = await this._channel.evaluateExpression({ expression: functionDeclaration, isFunction: true, arg: serializeArgument(undefined) });\n    return parseResult(result.value);\n  }\n\n  async _evaluateExposeUtilityScript<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 2);\n    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async $(selector: string, options?: { strict?: boolean }): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    const result = await this._channel.querySelector({ selector, ...options });\n    return ElementHandle.fromNullable(result.element) as ElementHandle<SVGElement | HTMLElement> | null;\n  }\n\n  waitForSelector(selector: string, options: channels.FrameWaitForSelectorOptions & TimeoutOptions & { state: 'attached' | 'visible' }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n  waitForSelector(selector: string, options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n  async waitForSelector(selector: string, options: channels.FrameWaitForSelectorOptions & TimeoutOptions = {}): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    if ((options as any).visibility)\n      throw new Error('options.visibility is not supported, did you mean options.state?');\n    if ((options as any).waitFor && (options as any).waitFor !== 'visible')\n      throw new Error('options.waitFor is not supported, did you mean options.state?');\n    const result = await this._channel.waitForSelector({ selector, ...options, timeout: this._timeout(options) });\n    return ElementHandle.fromNullable(result.element) as ElementHandle<SVGElement | HTMLElement> | null;\n  }\n\n  async dispatchEvent(selector: string, type: string, eventInit?: any, options: channels.FrameDispatchEventOptions & TimeoutOptions = {}): Promise<void> {\n    await this._channel.dispatchEvent({ selector, type, eventInit: serializeArgument(eventInit), ...options, timeout: this._timeout(options) });\n  }\n\n  async $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 3);\n    const result = await this._channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 3);\n    const result = await this._channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]> {\n    const result = await this._channel.querySelectorAll({ selector });\n    return result.elements.map(e => ElementHandle.from(e) as ElementHandle<SVGElement | HTMLElement>);\n  }\n\n  async _queryCount(selector: string, options?: {}): Promise<number> {\n    return (await this._channel.queryCount({ selector, ...options })).value;\n  }\n\n  async content(): Promise<string> {\n    return (await this._channel.content()).value;\n  }\n\n  async setContent(html: string, options: channels.FrameSetContentOptions & TimeoutOptions = {}): Promise<void> {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    await this._channel.setContent({ html, ...options, waitUntil, timeout: this._navigationTimeout(options) });\n  }\n\n  name(): string {\n    return this._name || '';\n  }\n\n  url(): string {\n    return this._url;\n  }\n\n  parentFrame(): Frame | null {\n    return this._parentFrame;\n  }\n\n  childFrames(): Frame[] {\n    return Array.from(this._childFrames);\n  }\n\n  isDetached(): boolean {\n    return this._detached;\n  }\n\n  async addScriptTag(options: { url?: string, path?: string, content?: string, type?: string } = {}): Promise<ElementHandle> {\n    const copy = { ...options };\n    if (copy.path) {\n      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();\n      copy.content = addSourceUrlToScript(copy.content, copy.path);\n    }\n    return ElementHandle.from((await this._channel.addScriptTag({ ...copy })).element);\n  }\n\n  async addStyleTag(options: { url?: string; path?: string; content?: string; } = {}): Promise<ElementHandle> {\n    const copy = { ...options };\n    if (copy.path) {\n      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();\n      copy.content += '/*# sourceURL=' + copy.path.replace(/\\n/g, '') + '*/';\n    }\n    return ElementHandle.from((await this._channel.addStyleTag({ ...copy })).element);\n  }\n\n  async click(selector: string, options: channels.FrameClickOptions & TimeoutOptions = {}) {\n    return await this._channel.click({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async dblclick(selector: string, options: channels.FrameDblclickOptions & TimeoutOptions = {}) {\n    return await this._channel.dblclick({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async dragAndDrop(source: string, target: string, options: channels.FrameDragAndDropOptions & TimeoutOptions = {}) {\n    return await this._channel.dragAndDrop({ source, target, ...options, timeout: this._timeout(options) });\n  }\n\n  async tap(selector: string, options: channels.FrameTapOptions & TimeoutOptions = {}) {\n    return await this._channel.tap({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async fill(selector: string, value: string, options: channels.FrameFillOptions & TimeoutOptions = {}) {\n    return await this._channel.fill({ selector, value, ...options, timeout: this._timeout(options) });\n  }\n\n  async _highlight(selector: string) {\n    return await this._channel.highlight({ selector });\n  }\n\n  locator(selector: string, options?: LocatorOptions): Locator {\n    return new Locator(this, selector, options);\n  }\n\n  getByTestId(testId: string | RegExp): Locator {\n    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));\n  }\n\n  getByAltText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByAltTextSelector(text, options));\n  }\n\n  getByLabel(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByLabelSelector(text, options));\n  }\n\n  getByPlaceholder(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByPlaceholderSelector(text, options));\n  }\n\n  getByText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTextSelector(text, options));\n  }\n\n  getByTitle(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTitleSelector(text, options));\n  }\n\n  getByRole(role: string, options: ByRoleOptions = {}): Locator {\n    return this.locator(getByRoleSelector(role, options));\n  }\n\n  frameLocator(selector: string): FrameLocator {\n    return new FrameLocator(this, selector);\n  }\n\n  async focus(selector: string, options: channels.FrameFocusOptions & TimeoutOptions = {}) {\n    await this._channel.focus({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async textContent(selector: string, options: channels.FrameTextContentOptions & TimeoutOptions = {}): Promise<null|string> {\n    const value = (await this._channel.textContent({ selector, ...options, timeout: this._timeout(options) })).value;\n    return value === undefined ? null : value;\n  }\n\n  async innerText(selector: string, options: channels.FrameInnerTextOptions & TimeoutOptions = {}): Promise<string> {\n    return (await this._channel.innerText({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async innerHTML(selector: string, options: channels.FrameInnerHTMLOptions & TimeoutOptions = {}): Promise<string> {\n    return (await this._channel.innerHTML({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async getAttribute(selector: string, name: string, options: channels.FrameGetAttributeOptions & TimeoutOptions = {}): Promise<string | null> {\n    const value = (await this._channel.getAttribute({ selector, name, ...options, timeout: this._timeout(options) })).value;\n    return value === undefined ? null : value;\n  }\n\n  async inputValue(selector: string, options: channels.FrameInputValueOptions & TimeoutOptions = {}): Promise<string> {\n    return (await this._channel.inputValue({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async isChecked(selector: string, options: channels.FrameIsCheckedOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isChecked({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async isDisabled(selector: string, options: channels.FrameIsDisabledOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isDisabled({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async isEditable(selector: string, options: channels.FrameIsEditableOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isEditable({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async isEnabled(selector: string, options: channels.FrameIsEnabledOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isEnabled({ selector, ...options, timeout: this._timeout(options) })).value;\n  }\n\n  async isHidden(selector: string, options: channels.FrameIsHiddenOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isHidden({ selector, ...options })).value;\n  }\n\n  async isVisible(selector: string, options: channels.FrameIsVisibleOptions & TimeoutOptions = {}): Promise<boolean> {\n    return (await this._channel.isVisible({ selector, ...options })).value;\n  }\n\n  async hover(selector: string, options: channels.FrameHoverOptions & TimeoutOptions = {}) {\n    await this._channel.hover({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async selectOption(selector: string, values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options: SelectOptionOptions & StrictOptions = {}): Promise<string[]> {\n    return (await this._channel.selectOption({ selector, ...convertSelectOptionValues(values), ...options, timeout: this._timeout(options) })).values;\n  }\n\n  async setInputFiles(selector: string, files: string | FilePayload | string[] | FilePayload[], options: channels.FrameSetInputFilesOptions & TimeoutOptions = {}): Promise<void> {\n    const converted = await convertInputFiles(this._platform, files, this.page().context());\n    await this._channel.setInputFiles({ selector, ...converted, ...options, timeout: this._timeout(options) });\n  }\n\n  async type(selector: string, text: string, options: channels.FrameTypeOptions & TimeoutOptions = {}) {\n    await this._channel.type({ selector, text, ...options, timeout: this._timeout(options) });\n  }\n\n  async press(selector: string, key: string, options: channels.FramePressOptions & TimeoutOptions = {}) {\n    await this._channel.press({ selector, key, ...options, timeout: this._timeout(options) });\n  }\n\n  async check(selector: string, options: channels.FrameCheckOptions & TimeoutOptions = {}) {\n    await this._channel.check({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async uncheck(selector: string, options: channels.FrameUncheckOptions & TimeoutOptions = {}) {\n    await this._channel.uncheck({ selector, ...options, timeout: this._timeout(options) });\n  }\n\n  async setChecked(selector: string, checked: boolean, options?: channels.FrameCheckOptions) {\n    if (checked)\n      await this.check(selector, options);\n    else\n      await this.uncheck(selector, options);\n  }\n\n  async waitForTimeout(timeout: number) {\n    await this._channel.waitForTimeout({ waitTimeout: timeout });\n  }\n\n  async waitForFunction<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg, options: WaitForFunctionOptions = {}): Promise<structs.SmartHandle<R>> {\n    if (typeof options.polling === 'string')\n      assert(options.polling === 'raf', 'Unknown polling option: ' + options.polling);\n    const result = await this._channel.waitForFunction({\n      ...options,\n      pollingInterval: options.polling === 'raf' ? undefined : options.polling,\n      expression: String(pageFunction),\n      isFunction: typeof pageFunction === 'function',\n      arg: serializeArgument(arg),\n      timeout: this._timeout(options),\n    });\n    return JSHandle.from(result.handle) as any as structs.SmartHandle<R>;\n  }\n\n  async title(): Promise<string> {\n    return (await this._channel.title()).value;\n  }\n\n  async _expect(expression: string, options: Omit<channels.FrameExpectParams, 'expression'>): Promise<{ matches: boolean, received?: any, log?: string[], timedOut?: boolean }> {\n    const params: channels.FrameExpectParams = { expression, ...options, isNot: !!options.isNot };\n    params.expectedValue = serializeArgument(options.expectedValue);\n    const result = (await this._channel.expect(params));\n    if (result.received !== undefined)\n      result.received = parseResult(result.received);\n    return result;\n  }\n}\n\nexport function verifyLoadState(name: string, waitUntil: LifecycleEvent): LifecycleEvent {\n  if (waitUntil as unknown === 'networkidle0')\n    waitUntil = 'networkidle';\n  if (!kLifecycleEvents.has(waitUntil))\n    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);\n  return waitUntil;\n}\n"],
  "mappings": "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",
  "names": []
}

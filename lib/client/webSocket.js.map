{
  "version": 3,
  "sources": ["../../src/client/webSocket.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChannelOwner } from './channelOwner';\nimport { Connection } from './connection';\n\nimport type { HeadersArray } from './types';\nimport type * as channels from '@protocol/channels';\n\nexport async function connectOverWebSocket(parentConnection: Connection, params: channels.LocalUtilsConnectParams): Promise<Connection> {\n  const localUtils = parentConnection.localUtils();\n  const transport = localUtils ? new JsonPipeTransport(localUtils) : new WebSocketTransport();\n  const connectHeaders = await transport.connect(params);\n  const connection = new Connection(parentConnection._platform, localUtils, parentConnection._instrumentation, connectHeaders);\n  connection.markAsRemote();\n  connection.on('close', () => transport.close());\n\n  let closeError: string | undefined;\n  const onTransportClosed = (reason?: string) => {\n    connection.close(reason || closeError);\n  };\n  transport.onClose(reason => onTransportClosed(reason));\n  connection.onmessage = message => transport.send(message).catch(() => onTransportClosed());\n  transport.onMessage(message => {\n    try {\n      connection!.dispatch(message);\n    } catch (e) {\n      closeError = String(e);\n      transport.close().catch(() => {});\n    }\n  });\n  return connection;\n}\n\ninterface Transport {\n  connect(params: channels.LocalUtilsConnectParams): Promise<HeadersArray>;\n  send(message: any): Promise<void>;\n  onMessage(callback: (message: object) => void): void;\n  onClose(callback: (reason?: string) => void): void;\n  close(): Promise<void>;\n}\n\nclass JsonPipeTransport implements Transport {\n  private _pipe: channels.JsonPipeChannel | undefined;\n  private _owner: ChannelOwner<channels.LocalUtilsChannel>;\n\n  constructor(owner: ChannelOwner<channels.LocalUtilsChannel>) {\n    this._owner = owner;\n  }\n\n  async connect(params: channels.LocalUtilsConnectParams) {\n    const { pipe, headers: connectHeaders } = await this._owner._channel.connect(params);\n    this._pipe = pipe;\n    return connectHeaders;\n  }\n\n  async send(message: object) {\n    await this._pipe!.send({ message });\n  }\n\n  onMessage(callback: (message: object) => void) {\n    this._pipe!.on('message', ({ message }) => callback(message));\n  }\n\n  onClose(callback: (reason?: string) => void) {\n    this._pipe!.on('closed', ({ reason }) => callback(reason));\n  }\n\n  async close() {\n    await this._pipe!.close().catch(() => {});\n  }\n}\n\nclass WebSocketTransport implements Transport {\n  private _ws: WebSocket | undefined;\n\n  async connect(params: channels.LocalUtilsConnectParams) {\n    this._ws = new window.WebSocket(params.wsEndpoint);\n    return [];\n  }\n\n  async send(message: object) {\n    this._ws!.send(JSON.stringify(message));\n  }\n\n  onMessage(callback: (message: object) => void) {\n    this._ws!.addEventListener('message', event => callback(JSON.parse(event.data)));\n  }\n\n  onClose(callback: (reason?: string) => void) {\n    this._ws!.addEventListener('close', () => callback());\n  }\n\n  async close() {\n    this._ws!.close();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,wBAA2B;AAK3B,eAAsB,qBAAqB,kBAA8B,QAA+D;AACtI,QAAM,aAAa,iBAAiB,WAAW;AAC/C,QAAM,YAAY,aAAa,IAAI,kBAAkB,UAAU,IAAI,IAAI,mBAAmB;AAC1F,QAAM,iBAAiB,MAAM,UAAU,QAAQ,MAAM;AACrD,QAAM,aAAa,IAAI,6BAAW,iBAAiB,WAAW,YAAY,iBAAiB,kBAAkB,cAAc;AAC3H,aAAW,aAAa;AACxB,aAAW,GAAG,SAAS,MAAM,UAAU,MAAM,CAAC;AAE9C,MAAI;AACJ,QAAM,oBAAoB,CAAC,WAAoB;AAC7C,eAAW,MAAM,UAAU,UAAU;AAAA,EACvC;AACA,YAAU,QAAQ,YAAU,kBAAkB,MAAM,CAAC;AACrD,aAAW,YAAY,aAAW,UAAU,KAAK,OAAO,EAAE,MAAM,MAAM,kBAAkB,CAAC;AACzF,YAAU,UAAU,aAAW;AAC7B,QAAI;AACF,iBAAY,SAAS,OAAO;AAAA,IAC9B,SAAS,GAAG;AACV,mBAAa,OAAO,CAAC;AACrB,gBAAU,MAAM,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA,IAClC;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAUA,MAAM,kBAAuC;AAAA,EAI3C,YAAY,OAAiD;AAC3D,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,QAAQ,QAA0C;AACtD,UAAM,EAAE,MAAM,SAAS,eAAe,IAAI,MAAM,KAAK,OAAO,SAAS,QAAQ,MAAM;AACnF,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,KAAK,SAAiB;AAC1B,UAAM,KAAK,MAAO,KAAK,EAAE,QAAQ,CAAC;AAAA,EACpC;AAAA,EAEA,UAAU,UAAqC;AAC7C,SAAK,MAAO,GAAG,WAAW,CAAC,EAAE,QAAQ,MAAM,SAAS,OAAO,CAAC;AAAA,EAC9D;AAAA,EAEA,QAAQ,UAAqC;AAC3C,SAAK,MAAO,GAAG,UAAU,CAAC,EAAE,OAAO,MAAM,SAAS,MAAM,CAAC;AAAA,EAC3D;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,KAAK,MAAO,MAAM,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EAC1C;AACF;AAEA,MAAM,mBAAwC;AAAA,EAG5C,MAAM,QAAQ,QAA0C;AACtD,SAAK,MAAM,IAAI,OAAO,UAAU,OAAO,UAAU;AACjD,WAAO,CAAC;AAAA,EACV;AAAA,EAEA,MAAM,KAAK,SAAiB;AAC1B,SAAK,IAAK,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EACxC;AAAA,EAEA,UAAU,UAAqC;AAC7C,SAAK,IAAK,iBAAiB,WAAW,WAAS,SAAS,KAAK,MAAM,MAAM,IAAI,CAAC,CAAC;AAAA,EACjF;AAAA,EAEA,QAAQ,UAAqC;AAC3C,SAAK,IAAK,iBAAiB,SAAS,MAAM,SAAS,CAAC;AAAA,EACtD;AAAA,EAEA,MAAM,QAAQ;AACZ,SAAK,IAAK,MAAM;AAAA,EAClB;AACF;",
  "names": []
}

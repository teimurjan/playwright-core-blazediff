{
  "version": 3,
  "sources": ["../../src/client/tracing.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Artifact } from './artifact';\nimport { ChannelOwner } from './channelOwner';\n\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\n\nexport class Tracing extends ChannelOwner<channels.TracingChannel> implements api.Tracing {\n  private _includeSources = false;\n  _tracesDir: string | undefined;\n  private _stacksId: string | undefined;\n  private _isTracing = false;\n\n  static from(channel: channels.TracingChannel): Tracing {\n    return (channel as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.TracingInitializer) {\n    super(parent, type, guid, initializer);\n  }\n\n  async start(options: { name?: string, title?: string, snapshots?: boolean, screenshots?: boolean, sources?: boolean, _live?: boolean } = {}) {\n    await this._wrapApiCall(async () => {\n      this._includeSources = !!options.sources;\n      await this._channel.tracingStart({\n        name: options.name,\n        snapshots: options.snapshots,\n        screenshots: options.screenshots,\n        live: options._live,\n      });\n      const { traceName } = await this._channel.tracingStartChunk({ name: options.name, title: options.title });\n      await this._startCollectingStacks(traceName);\n    });\n  }\n\n  async startChunk(options: { name?: string, title?: string } = {}) {\n    await this._wrapApiCall(async () => {\n      const { traceName } = await this._channel.tracingStartChunk(options);\n      await this._startCollectingStacks(traceName);\n    });\n  }\n\n  async group(name: string, options: { location?: { file: string, line?: number, column?: number } } = {}) {\n    await this._channel.tracingGroup({ name, location: options.location });\n  }\n\n  async groupEnd() {\n    await this._channel.tracingGroupEnd();\n  }\n\n  private async _startCollectingStacks(traceName: string) {\n    if (!this._isTracing) {\n      this._isTracing = true;\n      this._connection.setIsTracing(true);\n    }\n    const result = await this._connection.localUtils()?.tracingStarted({ tracesDir: this._tracesDir, traceName });\n    this._stacksId = result?.stacksId;\n  }\n\n  async stopChunk(options: { path?: string } = {}) {\n    await this._wrapApiCall(async () => {\n      await this._doStopChunk(options.path);\n    });\n  }\n\n  async stop(options: { path?: string } = {}) {\n    await this._wrapApiCall(async () => {\n      await this._doStopChunk(options.path);\n      await this._channel.tracingStop();\n    });\n  }\n\n  private async _doStopChunk(filePath: string | undefined) {\n    this._resetStackCounter();\n\n    if (!filePath) {\n      // Not interested in artifacts.\n      await this._channel.tracingStopChunk({ mode: 'discard' });\n      if (this._stacksId)\n        await this._connection.localUtils()!.traceDiscarded({ stacksId: this._stacksId });\n      return;\n    }\n\n    const localUtils = this._connection.localUtils();\n    if (!localUtils)\n      throw new Error('Cannot save trace in thin clients');\n\n    const isLocal = !this._connection.isRemote();\n\n    if (isLocal) {\n      const result = await this._channel.tracingStopChunk({ mode: 'entries' });\n      await localUtils.zip({ zipFile: filePath, entries: result.entries!, mode: 'write', stacksId: this._stacksId, includeSources: this._includeSources });\n      return;\n    }\n\n    const result = await this._channel.tracingStopChunk({ mode: 'archive' });\n\n    // The artifact may be missing if the browser closed while stopping tracing.\n    if (!result.artifact) {\n      if (this._stacksId)\n        await localUtils.traceDiscarded({ stacksId: this._stacksId });\n      return;\n    }\n\n    // Save trace to the final local file.\n    const artifact = Artifact.from(result.artifact);\n    await artifact.saveAs(filePath);\n    await artifact.delete();\n\n    await localUtils.zip({ zipFile: filePath, entries: [], mode: 'append', stacksId: this._stacksId, includeSources: this._includeSources });\n  }\n\n  _resetStackCounter() {\n    if (this._isTracing) {\n      this._isTracing = false;\n      this._connection.setIsTracing(false);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["result"]
}

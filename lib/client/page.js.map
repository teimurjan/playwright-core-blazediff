{
  "version": 3,
  "sources": ["../../src/client/page.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Accessibility } from './accessibility';\nimport { Artifact } from './artifact';\nimport { ChannelOwner } from './channelOwner';\nimport { evaluationScript } from './clientHelper';\nimport { Coverage } from './coverage';\nimport { Download } from './download';\nimport { ElementHandle, determineScreenshotType } from './elementHandle';\nimport { TargetClosedError, isTargetClosedError, serializeError } from './errors';\nimport { Events } from './events';\nimport { FileChooser } from './fileChooser';\nimport { Frame, verifyLoadState } from './frame';\nimport { HarRouter } from './harRouter';\nimport { Keyboard, Mouse, Touchscreen } from './input';\nimport { JSHandle, assertMaxArguments, parseResult, serializeArgument } from './jsHandle';\nimport { Response, Route, RouteHandler, WebSocket,  WebSocketRoute, WebSocketRouteHandler, validateHeaders } from './network';\nimport { Video } from './video';\nimport { Waiter } from './waiter';\nimport { Worker } from './worker';\nimport { TimeoutSettings } from './timeoutSettings';\nimport { assert } from '../utils/isomorphic/assert';\nimport { mkdirIfNeeded } from './fileUtils';\nimport { headersObjectToArray } from '../utils/isomorphic/headers';\nimport { trimStringWithEllipsis  } from '../utils/isomorphic/stringUtils';\nimport { urlMatches, urlMatchesEqual } from '../utils/isomorphic/urlMatch';\nimport { LongStandingScope } from '../utils/isomorphic/manualPromise';\nimport { isObject, isRegExp, isString } from '../utils/isomorphic/rtti';\n\nimport type { BrowserContext } from './browserContext';\nimport type { Clock } from './clock';\nimport type { APIRequestContext } from './fetch';\nimport type { WaitForNavigationOptions } from './frame';\nimport type { FrameLocator, Locator, LocatorOptions } from './locator';\nimport type { Request, RouteHandlerCallback, WebSocketRouteHandlerCallback } from './network';\nimport type { FilePayload, Headers, LifecycleEvent, SelectOption, SelectOptionOptions, Size, TimeoutOptions, WaitForEventOptions, WaitForFunctionOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\n\ntype PDFOptions = Omit<channels.PagePdfParams, 'width' | 'height' | 'margin'> & {\n  width?: string | number,\n  height?: string | number,\n  margin?: {\n    top?: string | number,\n    bottom?: string | number,\n    left?: string | number,\n    right?: string | number\n  },\n  path?: string,\n};\n\nexport type ExpectScreenshotOptions = Omit<channels.PageExpectScreenshotOptions, 'locator' | 'expected' | 'mask'> & {\n  expected?: Buffer,\n  locator?: api.Locator,\n  timeout: number,\n  isNot: boolean,\n  mask?: api.Locator[],\n};\n\nexport class Page extends ChannelOwner<channels.PageChannel> implements api.Page {\n  private _browserContext: BrowserContext;\n  _ownedContext: BrowserContext | undefined;\n\n  private _mainFrame: Frame;\n  private _frames = new Set<Frame>();\n  _workers = new Set<Worker>();\n  private _closed = false;\n  readonly _closedOrCrashedScope = new LongStandingScope();\n  private _viewportSize: Size | undefined;\n  _routes: RouteHandler[] = [];\n  _webSocketRoutes: WebSocketRouteHandler[] = [];\n\n  readonly accessibility: Accessibility;\n  readonly coverage: Coverage;\n  readonly keyboard: Keyboard;\n  readonly mouse: Mouse;\n  readonly request: APIRequestContext;\n  readonly touchscreen: Touchscreen;\n  readonly clock: Clock;\n\n\n  readonly _bindings = new Map<string, (source: structs.BindingSource, ...args: any[]) => any>();\n  readonly _timeoutSettings: TimeoutSettings;\n  private _video: Video | null = null;\n  readonly _opener: Page | null;\n  private _closeReason: string | undefined;\n  _closeWasCalled: boolean = false;\n  private _harRouters: HarRouter[] = [];\n\n  private _locatorHandlers = new Map<number, { locator: Locator, handler: (locator: Locator) => any, times: number | undefined }>();\n\n  static from(page: channels.PageChannel): Page {\n    return (page as any)._object;\n  }\n\n  static fromNullable(page: channels.PageChannel | undefined): Page | null {\n    return page ? Page.from(page) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.PageInitializer) {\n    super(parent, type, guid, initializer);\n    this._browserContext = parent as unknown as BrowserContext;\n    this._timeoutSettings = new TimeoutSettings(this._platform, this._browserContext._timeoutSettings);\n\n    this.accessibility = new Accessibility(this._channel);\n    this.keyboard = new Keyboard(this);\n    this.mouse = new Mouse(this);\n    this.request = this._browserContext.request;\n    this.touchscreen = new Touchscreen(this);\n    this.clock = this._browserContext.clock;\n\n    this._mainFrame = Frame.from(initializer.mainFrame);\n    this._mainFrame._page = this;\n    this._frames.add(this._mainFrame);\n    this._viewportSize = initializer.viewportSize;\n    this._closed = initializer.isClosed;\n    this._opener = Page.fromNullable(initializer.opener);\n\n    this._channel.on('bindingCall', ({ binding }) => this._onBinding(BindingCall.from(binding)));\n    this._channel.on('close', () => this._onClose());\n    this._channel.on('crash', () => this._onCrash());\n    this._channel.on('download', ({ url, suggestedFilename, artifact }) => {\n      const artifactObject = Artifact.from(artifact);\n      this.emit(Events.Page.Download, new Download(this, url, suggestedFilename, artifactObject));\n    });\n    this._channel.on('fileChooser', ({ element, isMultiple }) => this.emit(Events.Page.FileChooser, new FileChooser(this, ElementHandle.from(element), isMultiple)));\n    this._channel.on('frameAttached', ({ frame }) => this._onFrameAttached(Frame.from(frame)));\n    this._channel.on('frameDetached', ({ frame }) => this._onFrameDetached(Frame.from(frame)));\n    this._channel.on('locatorHandlerTriggered', ({ uid }) => this._onLocatorHandlerTriggered(uid));\n    this._channel.on('route', ({ route }) => this._onRoute(Route.from(route)));\n    this._channel.on('webSocketRoute', ({ webSocketRoute }) => this._onWebSocketRoute(WebSocketRoute.from(webSocketRoute)));\n    this._channel.on('video', ({ artifact }) => {\n      const artifactObject = Artifact.from(artifact);\n      this._forceVideo()._artifactReady(artifactObject);\n    });\n    this._channel.on('viewportSizeChanged', ({ viewportSize }) => this._viewportSize = viewportSize);\n    this._channel.on('webSocket', ({ webSocket }) => this.emit(Events.Page.WebSocket, WebSocket.from(webSocket)));\n    this._channel.on('worker', ({ worker }) => this._onWorker(Worker.from(worker)));\n\n    this.coverage = new Coverage(this._channel);\n\n    this.once(Events.Page.Close, () => this._closedOrCrashedScope.close(this._closeErrorWithReason()));\n    this.once(Events.Page.Crash, () => this._closedOrCrashedScope.close(new TargetClosedError()));\n\n    this._setEventToSubscriptionMapping(new Map<string, channels.PageUpdateSubscriptionParams['event']>([\n      [Events.Page.Console, 'console'],\n      [Events.Page.Dialog, 'dialog'],\n      [Events.Page.Request, 'request'],\n      [Events.Page.Response, 'response'],\n      [Events.Page.RequestFinished, 'requestFinished'],\n      [Events.Page.RequestFailed, 'requestFailed'],\n      [Events.Page.FileChooser, 'fileChooser'],\n    ]));\n  }\n\n  private _onFrameAttached(frame: Frame) {\n    frame._page = this;\n    this._frames.add(frame);\n    if (frame._parentFrame)\n      frame._parentFrame._childFrames.add(frame);\n    this.emit(Events.Page.FrameAttached, frame);\n  }\n\n  private _onFrameDetached(frame: Frame) {\n    this._frames.delete(frame);\n    frame._detached = true;\n    if (frame._parentFrame)\n      frame._parentFrame._childFrames.delete(frame);\n    this.emit(Events.Page.FrameDetached, frame);\n  }\n\n  private async _onRoute(route: Route) {\n    route._context = this.context();\n    const routeHandlers = this._routes.slice();\n    for (const routeHandler of routeHandlers) {\n      // If the page was closed we stall all requests right away.\n      if (this._closeWasCalled || this._browserContext._closingStatus !== 'none')\n        return;\n      if (!routeHandler.matches(route.request().url()))\n        continue;\n      const index = this._routes.indexOf(routeHandler);\n      if (index === -1)\n        continue;\n      if (routeHandler.willExpire())\n        this._routes.splice(index, 1);\n      const handled = await routeHandler.handle(route);\n      if (!this._routes.length)\n        this._updateInterceptionPatterns({ internal: true }).catch(() => {});\n      if (handled)\n        return;\n    }\n\n    await this._browserContext._onRoute(route);\n  }\n\n  private async _onWebSocketRoute(webSocketRoute: WebSocketRoute) {\n    const routeHandler = this._webSocketRoutes.find(route => route.matches(webSocketRoute.url()));\n    if (routeHandler)\n      await routeHandler.handle(webSocketRoute);\n    else\n      await this._browserContext._onWebSocketRoute(webSocketRoute);\n  }\n\n  async _onBinding(bindingCall: BindingCall) {\n    const func = this._bindings.get(bindingCall._initializer.name);\n    if (func) {\n      await bindingCall.call(func);\n      return;\n    }\n    await this._browserContext._onBinding(bindingCall);\n  }\n\n  _onWorker(worker: Worker): void {\n    this._workers.add(worker);\n    worker._page = this;\n    this.emit(Events.Page.Worker, worker);\n  }\n\n  _onClose() {\n    this._closed = true;\n    this._browserContext._pages.delete(this);\n    this._browserContext._backgroundPages.delete(this);\n    this._disposeHarRouters();\n    this.emit(Events.Page.Close, this);\n  }\n\n  private _onCrash() {\n    this.emit(Events.Page.Crash, this);\n  }\n\n  context(): BrowserContext {\n    return this._browserContext;\n  }\n\n  async opener(): Promise<Page | null> {\n    if (!this._opener || this._opener.isClosed())\n      return null;\n    return this._opener;\n  }\n\n  mainFrame(): Frame {\n    return this._mainFrame;\n  }\n\n  frame(frameSelector: string | { name?: string, url?: URLMatch }): Frame | null {\n    const name = isString(frameSelector) ? frameSelector : frameSelector.name;\n    const url = isObject(frameSelector) ? frameSelector.url : undefined;\n    assert(name || url, 'Either name or url matcher should be specified');\n    return this.frames().find(f => {\n      if (name)\n        return f.name() === name;\n      return urlMatches(this._browserContext._options.baseURL, f.url(), url);\n    }) || null;\n  }\n\n  frames(): Frame[] {\n    return [...this._frames];\n  }\n\n  setDefaultNavigationTimeout(timeout: number) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n\n  setDefaultTimeout(timeout: number) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n\n  private _forceVideo(): Video {\n    if (!this._video)\n      this._video = new Video(this, this._connection);\n    return this._video;\n  }\n\n  video(): Video | null {\n    // Note: we are creating Video object lazily, because we do not know\n    // BrowserContextOptions when constructing the page - it is assigned\n    // too late during launchPersistentContext.\n    if (!this._browserContext._options.recordVideo)\n      return null;\n    return this._forceVideo();\n  }\n\n  async $(selector: string, options?: { strict?: boolean }): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    return await this._mainFrame.$(selector, options);\n  }\n\n  waitForSelector(selector: string, options: channels.FrameWaitForSelectorOptions & TimeoutOptions & { state: 'attached' | 'visible' }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n  waitForSelector(selector: string, options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n  async waitForSelector(selector: string, options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    return await this._mainFrame.waitForSelector(selector, options);\n  }\n\n  async dispatchEvent(selector: string, type: string, eventInit?: any, options?: channels.FrameDispatchEventOptions): Promise<void> {\n    return await this._mainFrame.dispatchEvent(selector, type, eventInit, options);\n  }\n\n  async evaluateHandle<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>> {\n    assertMaxArguments(arguments.length, 2);\n    return await this._mainFrame.evaluateHandle(pageFunction, arg);\n  }\n\n  async $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 3);\n    return await this._mainFrame.$eval(selector, pageFunction, arg);\n  }\n\n  async $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 3);\n    return await this._mainFrame.$$eval(selector, pageFunction, arg);\n  }\n\n  async $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]> {\n    return await this._mainFrame.$$(selector);\n  }\n\n  async addScriptTag(options: { url?: string; path?: string; content?: string; type?: string; } = {}): Promise<ElementHandle> {\n    return await this._mainFrame.addScriptTag(options);\n  }\n\n  async addStyleTag(options: { url?: string; path?: string; content?: string; } = {}): Promise<ElementHandle> {\n    return await this._mainFrame.addStyleTag(options);\n  }\n\n  async exposeFunction(name: string, callback: Function) {\n    await this._channel.exposeBinding({ name });\n    const binding = (source: structs.BindingSource, ...args: any[]) => callback(...args);\n    this._bindings.set(name, binding);\n  }\n\n  async exposeBinding(name: string, callback: (source: structs.BindingSource, ...args: any[]) => any, options: { handle?: boolean } = {}) {\n    await this._channel.exposeBinding({ name, needsHandle: options.handle });\n    this._bindings.set(name, callback);\n  }\n\n  async setExtraHTTPHeaders(headers: Headers) {\n    validateHeaders(headers);\n    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });\n  }\n\n  url(): string {\n    return this._mainFrame.url();\n  }\n\n  async content(): Promise<string> {\n    return await this._mainFrame.content();\n  }\n\n  async setContent(html: string, options?: channels.FrameSetContentOptions & TimeoutOptions): Promise<void> {\n    return await this._mainFrame.setContent(html, options);\n  }\n\n  async goto(url: string, options?: channels.FrameGotoOptions & TimeoutOptions): Promise<Response | null> {\n    return await this._mainFrame.goto(url, options);\n  }\n\n  async reload(options: channels.PageReloadOptions & TimeoutOptions = {}): Promise<Response | null> {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return Response.fromNullable((await this._channel.reload({ ...options, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options) })).response);\n  }\n\n  async addLocatorHandler(locator: Locator, handler: (locator: Locator) => any, options: { times?: number, noWaitAfter?: boolean } = {}): Promise<void> {\n    if (locator._frame !== this._mainFrame)\n      throw new Error(`Locator must belong to the main frame of this page`);\n    if (options.times === 0)\n      return;\n    const { uid } = await this._channel.registerLocatorHandler({ selector: locator._selector, noWaitAfter: options.noWaitAfter });\n    this._locatorHandlers.set(uid, { locator, handler, times: options.times });\n  }\n\n  private async _onLocatorHandlerTriggered(uid: number) {\n    let remove = false;\n    try {\n      const handler = this._locatorHandlers.get(uid);\n      if (handler && handler.times !== 0) {\n        if (handler.times !== undefined)\n          handler.times--;\n        await handler.handler(handler.locator);\n      }\n      remove = handler?.times === 0;\n    } finally {\n      if (remove)\n        this._locatorHandlers.delete(uid);\n      this._channel.resolveLocatorHandlerNoReply({ uid, remove }).catch(() => {});\n    }\n  }\n\n  async removeLocatorHandler(locator: Locator): Promise<void> {\n    for (const [uid, data] of this._locatorHandlers) {\n      if (data.locator._equals(locator)) {\n        this._locatorHandlers.delete(uid);\n        await this._channel.unregisterLocatorHandler({ uid }).catch(() => {});\n      }\n    }\n  }\n\n  async waitForLoadState(state?: LifecycleEvent, options?: TimeoutOptions): Promise<void> {\n    return await this._mainFrame.waitForLoadState(state, options);\n  }\n\n  async waitForNavigation(options?: WaitForNavigationOptions): Promise<Response | null> {\n    return await this._mainFrame.waitForNavigation(options);\n  }\n\n  async waitForURL(url: URLMatch, options?: TimeoutOptions & { waitUntil?: LifecycleEvent }): Promise<void> {\n    return await this._mainFrame.waitForURL(url, options);\n  }\n\n  async waitForRequest(urlOrPredicate: string | RegExp | ((r: Request) => boolean | Promise<boolean>), options: TimeoutOptions = {}): Promise<Request> {\n    const predicate = async (request: Request) => {\n      if (isString(urlOrPredicate) || isRegExp(urlOrPredicate))\n        return urlMatches(this._browserContext._options.baseURL, request.url(), urlOrPredicate);\n      return await urlOrPredicate(request);\n    };\n    const trimmedUrl = trimUrl(urlOrPredicate);\n    const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : undefined;\n    return await this._waitForEvent(Events.Page.Request, { predicate, timeout: options.timeout }, logLine);\n  }\n\n  async waitForResponse(urlOrPredicate: string | RegExp | ((r: Response) => boolean | Promise<boolean>), options: TimeoutOptions = {}): Promise<Response> {\n    const predicate = async (response: Response) => {\n      if (isString(urlOrPredicate) || isRegExp(urlOrPredicate))\n        return urlMatches(this._browserContext._options.baseURL, response.url(), urlOrPredicate);\n      return await urlOrPredicate(response);\n    };\n    const trimmedUrl = trimUrl(urlOrPredicate);\n    const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : undefined;\n    return await this._waitForEvent(Events.Page.Response, { predicate, timeout: options.timeout }, logLine);\n  }\n\n  async waitForEvent(event: string, optionsOrPredicate: WaitForEventOptions = {}): Promise<any> {\n    return await this._waitForEvent(event, optionsOrPredicate, `waiting for event \"${event}\"`);\n  }\n\n  _closeErrorWithReason(): TargetClosedError {\n    return new TargetClosedError(this._closeReason || this._browserContext._effectiveCloseReason());\n  }\n\n  private async _waitForEvent(event: string, optionsOrPredicate: WaitForEventOptions, logLine?: string): Promise<any> {\n    return await this._wrapApiCall(async () => {\n      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = Waiter.createForEvent(this, event);\n      if (logLine)\n        waiter.log(logLine);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== Events.Page.Crash)\n        waiter.rejectOnEvent(this, Events.Page.Crash, new Error('Page crashed'));\n      if (event !== Events.Page.Close)\n        waiter.rejectOnEvent(this, Events.Page.Close, () => this._closeErrorWithReason());\n      const result = await waiter.waitForEvent(this, event, predicate as any);\n      waiter.dispose();\n      return result;\n    });\n  }\n\n  async goBack(options: channels.PageGoBackOptions & TimeoutOptions = {}): Promise<Response | null> {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return Response.fromNullable((await this._channel.goBack({ ...options, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options) })).response);\n  }\n\n  async goForward(options: channels.PageGoForwardOptions & TimeoutOptions = {}): Promise<Response | null> {\n    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    return Response.fromNullable((await this._channel.goForward({ ...options, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options) })).response);\n  }\n\n  async requestGC() {\n    await this._channel.requestGC();\n  }\n\n  async emulateMedia(options: { media?: 'screen' | 'print' | null, colorScheme?: 'dark' | 'light' | 'no-preference' | null, reducedMotion?: 'reduce' | 'no-preference' | null, forcedColors?: 'active' | 'none' | null, contrast?: 'no-preference' | 'more' | null } = {}) {\n    await this._channel.emulateMedia({\n      media: options.media === null ? 'no-override' : options.media,\n      colorScheme: options.colorScheme === null ? 'no-override' : options.colorScheme,\n      reducedMotion: options.reducedMotion === null ? 'no-override' : options.reducedMotion,\n      forcedColors: options.forcedColors === null ? 'no-override' : options.forcedColors,\n      contrast: options.contrast === null ? 'no-override' : options.contrast,\n    });\n  }\n\n  async setViewportSize(viewportSize: Size) {\n    this._viewportSize = viewportSize;\n    await this._channel.setViewportSize({ viewportSize });\n  }\n\n  viewportSize(): Size | null {\n    return this._viewportSize || null;\n  }\n\n  async evaluate<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R> {\n    assertMaxArguments(arguments.length, 2);\n    return await this._mainFrame.evaluate(pageFunction, arg);\n  }\n\n  async _evaluateFunction(functionDeclaration: string) {\n    return this._mainFrame._evaluateFunction(functionDeclaration);\n  }\n\n  async addInitScript(script: Function | string | { path?: string, content?: string }, arg?: any) {\n    const source = await evaluationScript(this._platform, script, arg);\n    await this._channel.addInitScript({ source });\n  }\n\n  async route(url: URLMatch, handler: RouteHandlerCallback, options: { times?: number } = {}): Promise<void> {\n    this._routes.unshift(new RouteHandler(this._platform, this._browserContext._options.baseURL, url, handler, options.times));\n    await this._updateInterceptionPatterns({ title: 'Route requests' });\n  }\n\n  async routeFromHAR(har: string, options: { url?: string | RegExp, notFound?: 'abort' | 'fallback', update?: boolean, updateContent?: 'attach' | 'embed', updateMode?: 'minimal' | 'full'} = {}): Promise<void> {\n    const localUtils = this._connection.localUtils();\n    if (!localUtils)\n      throw new Error('Route from har is not supported in thin clients');\n    if (options.update) {\n      await this._browserContext._recordIntoHAR(har, this, options);\n      return;\n    }\n    const harRouter = await HarRouter.create(localUtils, har, options.notFound || 'abort', { urlMatch: options.url });\n    this._harRouters.push(harRouter);\n    await harRouter.addPageRoute(this);\n  }\n\n  async routeWebSocket(url: URLMatch, handler: WebSocketRouteHandlerCallback): Promise<void> {\n    this._webSocketRoutes.unshift(new WebSocketRouteHandler(this._browserContext._options.baseURL, url, handler));\n    await this._updateWebSocketInterceptionPatterns({ title: 'Route WebSockets' });\n  }\n\n  private _disposeHarRouters() {\n    this._harRouters.forEach(router => router.dispose());\n    this._harRouters = [];\n  }\n\n  async unrouteAll(options?: { behavior?: 'wait'|'ignoreErrors'|'default' }): Promise<void> {\n    await this._unrouteInternal(this._routes, [], options?.behavior);\n    this._disposeHarRouters();\n  }\n\n  async unroute(url: URLMatch, handler?: RouteHandlerCallback): Promise<void> {\n    const removed = [];\n    const remaining = [];\n    for (const route of this._routes) {\n      if (urlMatchesEqual(route.url, url) && (!handler || route.handler === handler))\n        removed.push(route);\n      else\n        remaining.push(route);\n    }\n    await this._unrouteInternal(removed, remaining, 'default');\n  }\n\n  private async _unrouteInternal(removed: RouteHandler[], remaining: RouteHandler[], behavior?: 'wait'|'ignoreErrors'|'default'): Promise<void> {\n    this._routes = remaining;\n    if (behavior && behavior !== 'default') {\n      const promises = removed.map(routeHandler => routeHandler.stop(behavior));\n      await Promise.all(promises);\n    }\n    await this._updateInterceptionPatterns({ title: 'Unroute requests' });\n  }\n\n  private async _updateInterceptionPatterns(options: { internal: true } | { title: string }) {\n    const patterns = RouteHandler.prepareInterceptionPatterns(this._routes);\n    await this._wrapApiCall(() => this._channel.setNetworkInterceptionPatterns({ patterns }), options);\n  }\n\n  private async _updateWebSocketInterceptionPatterns(options: { internal: true } | { title: string }) {\n    const patterns = WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);\n    await this._wrapApiCall(() => this._channel.setWebSocketInterceptionPatterns({ patterns }), options);\n  }\n\n  async screenshot(options: Omit<channels.PageScreenshotOptions, 'mask'> & TimeoutOptions & { path?: string, mask?: api.Locator[] } = {}): Promise<Buffer> {\n    const mask = options.mask as Locator[] | undefined;\n    const copy: channels.PageScreenshotParams = { ...options, mask: undefined, timeout: this._timeoutSettings.timeout(options) };\n    if (!copy.type)\n      copy.type = determineScreenshotType(options);\n    if (mask) {\n      copy.mask = mask.map(locator => ({\n        frame: locator._frame._channel,\n        selector: locator._selector,\n      }));\n    }\n    const result = await this._channel.screenshot(copy);\n    if (options.path) {\n      await mkdirIfNeeded(this._platform, options.path);\n      await this._platform.fs().promises.writeFile(options.path, result.binary);\n    }\n    return result.binary;\n  }\n\n  async _expectScreenshot(options: ExpectScreenshotOptions): Promise<{ actual?: Buffer, previous?: Buffer, diff?: Buffer, errorMessage?: string, log?: string[], timedOut?: boolean}> {\n    const mask = options?.mask ? options?.mask.map(locator => ({\n      frame: (locator as Locator)._frame._channel,\n      selector: (locator as Locator)._selector,\n    })) : undefined;\n    const locator = options.locator ? {\n      frame: (options.locator as Locator)._frame._channel,\n      selector: (options.locator as Locator)._selector,\n    } : undefined;\n    return await this._channel.expectScreenshot({\n      ...options,\n      isNot: !!options.isNot,\n      locator,\n      mask,\n    });\n  }\n\n  async title(): Promise<string> {\n    return await this._mainFrame.title();\n  }\n\n  async bringToFront(): Promise<void> {\n    await this._channel.bringToFront();\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n\n  async close(options: { runBeforeUnload?: boolean, reason?: string } = {}) {\n    this._closeReason = options.reason;\n    this._closeWasCalled = true;\n    try {\n      if (this._ownedContext)\n        await this._ownedContext.close();\n      else\n        await this._channel.close(options);\n    } catch (e) {\n      if (isTargetClosedError(e) && !options.runBeforeUnload)\n        return;\n      throw e;\n    }\n  }\n\n  isClosed(): boolean {\n    return this._closed;\n  }\n\n  async click(selector: string, options?: channels.FrameClickOptions & TimeoutOptions) {\n    return await this._mainFrame.click(selector, options);\n  }\n\n  async dragAndDrop(source: string, target: string, options?: channels.FrameDragAndDropOptions & TimeoutOptions) {\n    return await this._mainFrame.dragAndDrop(source, target, options);\n  }\n\n  async dblclick(selector: string, options?: channels.FrameDblclickOptions & TimeoutOptions) {\n    await this._mainFrame.dblclick(selector, options);\n  }\n\n  async tap(selector: string, options?: channels.FrameTapOptions & TimeoutOptions) {\n    return await this._mainFrame.tap(selector, options);\n  }\n\n  async fill(selector: string, value: string, options?: channels.FrameFillOptions & TimeoutOptions) {\n    return await this._mainFrame.fill(selector, value, options);\n  }\n\n  locator(selector: string, options?: LocatorOptions): Locator {\n    return this.mainFrame().locator(selector, options);\n  }\n\n  getByTestId(testId: string | RegExp): Locator {\n    return this.mainFrame().getByTestId(testId);\n  }\n\n  getByAltText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.mainFrame().getByAltText(text, options);\n  }\n\n  getByLabel(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.mainFrame().getByLabel(text, options);\n  }\n\n  getByPlaceholder(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.mainFrame().getByPlaceholder(text, options);\n  }\n\n  getByText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.mainFrame().getByText(text, options);\n  }\n\n  getByTitle(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.mainFrame().getByTitle(text, options);\n  }\n\n  getByRole(role: string, options: ByRoleOptions = {}): Locator {\n    return this.mainFrame().getByRole(role, options);\n  }\n\n  frameLocator(selector: string): FrameLocator {\n    return this.mainFrame().frameLocator(selector);\n  }\n\n  async focus(selector: string, options?: channels.FrameFocusOptions & TimeoutOptions) {\n    return await this._mainFrame.focus(selector, options);\n  }\n\n  async textContent(selector: string, options?: channels.FrameTextContentOptions & TimeoutOptions): Promise<null|string> {\n    return await this._mainFrame.textContent(selector, options);\n  }\n\n  async innerText(selector: string, options?: channels.FrameInnerTextOptions & TimeoutOptions): Promise<string> {\n    return await this._mainFrame.innerText(selector, options);\n  }\n\n  async innerHTML(selector: string, options?: channels.FrameInnerHTMLOptions & TimeoutOptions): Promise<string> {\n    return await this._mainFrame.innerHTML(selector, options);\n  }\n\n  async getAttribute(selector: string, name: string, options?: channels.FrameGetAttributeOptions & TimeoutOptions): Promise<string | null> {\n    return await this._mainFrame.getAttribute(selector, name, options);\n  }\n\n  async inputValue(selector: string, options?: channels.FrameInputValueOptions & TimeoutOptions): Promise<string> {\n    return await this._mainFrame.inputValue(selector, options);\n  }\n\n  async isChecked(selector: string, options?: channels.FrameIsCheckedOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isChecked(selector, options);\n  }\n\n  async isDisabled(selector: string, options?: channels.FrameIsDisabledOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isDisabled(selector, options);\n  }\n\n  async isEditable(selector: string, options?: channels.FrameIsEditableOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isEditable(selector, options);\n  }\n\n  async isEnabled(selector: string, options?: channels.FrameIsEnabledOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isEnabled(selector, options);\n  }\n\n  async isHidden(selector: string, options?: channels.FrameIsHiddenOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isHidden(selector, options);\n  }\n\n  async isVisible(selector: string, options?: channels.FrameIsVisibleOptions & TimeoutOptions): Promise<boolean> {\n    return await this._mainFrame.isVisible(selector, options);\n  }\n\n  async hover(selector: string, options?: channels.FrameHoverOptions & TimeoutOptions) {\n    return await this._mainFrame.hover(selector, options);\n  }\n\n  async selectOption(selector: string, values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options?: SelectOptionOptions): Promise<string[]> {\n    return await this._mainFrame.selectOption(selector, values, options);\n  }\n\n  async setInputFiles(selector: string, files: string | FilePayload | string[] | FilePayload[], options?: channels.FrameSetInputFilesOptions & TimeoutOptions): Promise<void> {\n    return await this._mainFrame.setInputFiles(selector, files, options);\n  }\n\n  async type(selector: string, text: string, options?: channels.FrameTypeOptions & TimeoutOptions) {\n    return await this._mainFrame.type(selector, text, options);\n  }\n\n  async press(selector: string, key: string, options?: channels.FramePressOptions & TimeoutOptions) {\n    return await this._mainFrame.press(selector, key, options);\n  }\n\n  async check(selector: string, options?: channels.FrameCheckOptions & TimeoutOptions) {\n    return await this._mainFrame.check(selector, options);\n  }\n\n  async uncheck(selector: string, options?: channels.FrameUncheckOptions & TimeoutOptions) {\n    return await this._mainFrame.uncheck(selector, options);\n  }\n\n  async setChecked(selector: string, checked: boolean, options?: channels.FrameCheckOptions & TimeoutOptions) {\n    return await this._mainFrame.setChecked(selector, checked, options);\n  }\n\n  async waitForTimeout(timeout: number) {\n    return await this._mainFrame.waitForTimeout(timeout);\n  }\n\n  async waitForFunction<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg, options?: WaitForFunctionOptions): Promise<structs.SmartHandle<R>> {\n    return await this._mainFrame.waitForFunction(pageFunction, arg, options);\n  }\n\n  workers(): Worker[] {\n    return [...this._workers];\n  }\n\n  async pause(_options?: { __testHookKeepTestTimeout: boolean }) {\n    if (this._platform.isJSDebuggerAttached())\n      return;\n    const defaultNavigationTimeout = this._browserContext._timeoutSettings.defaultNavigationTimeout();\n    const defaultTimeout = this._browserContext._timeoutSettings.defaultTimeout();\n    this._browserContext.setDefaultNavigationTimeout(0);\n    this._browserContext.setDefaultTimeout(0);\n    this._instrumentation?.onWillPause({ keepTestTimeout: !!_options?.__testHookKeepTestTimeout });\n    await this._closedOrCrashedScope.safeRace(this.context()._channel.pause());\n    this._browserContext.setDefaultNavigationTimeout(defaultNavigationTimeout);\n    this._browserContext.setDefaultTimeout(defaultTimeout);\n  }\n\n  async pdf(options: PDFOptions = {}): Promise<Buffer> {\n    const transportOptions: channels.PagePdfParams = { ...options } as channels.PagePdfParams;\n    if (transportOptions.margin)\n      transportOptions.margin = { ...transportOptions.margin };\n    if (typeof options.width === 'number')\n      transportOptions.width = options.width + 'px';\n    if (typeof options.height === 'number')\n      transportOptions.height  = options.height + 'px';\n    for (const margin of ['top', 'right', 'bottom', 'left']) {\n      const index = margin as 'top' | 'right' | 'bottom' | 'left';\n      if (options.margin && typeof options.margin[index] === 'number')\n        transportOptions.margin![index] = transportOptions.margin![index] + 'px';\n    }\n    const result = await this._channel.pdf(transportOptions);\n    if (options.path) {\n      const platform = this._platform;\n      await platform.fs().promises.mkdir(platform.path().dirname(options.path), { recursive: true });\n      await platform.fs().promises.writeFile(options.path, result.pdf);\n    }\n    return result.pdf;\n  }\n\n  async _snapshotForAI(options: TimeoutOptions = {}): Promise<string> {\n    const result = await this._channel.snapshotForAI({ timeout: this._timeoutSettings.timeout(options) });\n    return result.snapshot;\n  }\n}\n\nexport class BindingCall extends ChannelOwner<channels.BindingCallChannel> {\n  static from(channel: channels.BindingCallChannel): BindingCall {\n    return (channel as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BindingCallInitializer) {\n    super(parent, type, guid, initializer);\n  }\n\n  async call(func: (source: structs.BindingSource, ...args: any[]) => any) {\n    try {\n      const frame = Frame.from(this._initializer.frame);\n      const source = {\n        context: frame._page!.context(),\n        page: frame._page!,\n        frame\n      };\n      let result: any;\n      if (this._initializer.handle)\n        result = await func(source, JSHandle.from(this._initializer.handle));\n      else\n        result = await func(source, ...this._initializer.args!.map(parseResult));\n      this._channel.resolve({ result: serializeArgument(result) }).catch(() => {});\n    } catch (e) {\n      this._channel.reject({ error: serializeError(e) }).catch(() => {});\n    }\n  }\n}\n\nfunction trimUrl(param: any): string | undefined {\n  if (isRegExp(param))\n    return `/${trimStringWithEllipsis(param.source, 50)}/${param.flags}`;\n  if (isString(param))\n    return `\"${trimStringWithEllipsis(param, 50)}\"`;\n}\n"],
  "mappings": "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",
  "names": ["locator"]
}

{
  "version": 3,
  "sources": ["../../src/client/elementHandle.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Frame } from './frame';\nimport { JSHandle, parseResult, serializeArgument } from './jsHandle';\nimport { assert } from '../utils/isomorphic/assert';\nimport { fileUploadSizeLimit, mkdirIfNeeded } from './fileUtils';\nimport { isString } from '../utils/isomorphic/rtti';\nimport { WritableStream } from './writableStream';\nimport { getMimeTypeForPath } from '../utils/isomorphic/mimeType';\n\nimport type { BrowserContext } from './browserContext';\nimport type { ChannelOwner } from './channelOwner';\nimport type { Locator } from './locator';\nimport type { FilePayload, Rect, SelectOption, SelectOptionOptions, TimeoutOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\n\nexport class ElementHandle<T extends Node = Node> extends JSHandle<T> implements api.ElementHandle {\n  private _frame: Frame;\n  readonly _elementChannel: channels.ElementHandleChannel;\n\n  static override from(handle: channels.ElementHandleChannel): ElementHandle {\n    return (handle as any)._object;\n  }\n\n  static fromNullable(handle: channels.ElementHandleChannel | undefined): ElementHandle | null {\n    return handle ? ElementHandle.from(handle) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer) {\n    super(parent, type, guid, initializer);\n    this._frame = parent as Frame;\n    this._elementChannel = this._channel as channels.ElementHandleChannel;\n  }\n\n  override asElement(): T extends Node ? ElementHandle<T> : null {\n    return this as any;\n  }\n\n  async ownerFrame(): Promise<Frame | null> {\n    return Frame.fromNullable((await this._elementChannel.ownerFrame()).frame);\n  }\n\n  async contentFrame(): Promise<Frame | null> {\n    return Frame.fromNullable((await this._elementChannel.contentFrame()).frame);\n  }\n\n  async getAttribute(name: string): Promise<string | null> {\n    const value = (await this._elementChannel.getAttribute({ name })).value;\n    return value === undefined ? null : value;\n  }\n\n  async inputValue(): Promise<string> {\n    return (await this._elementChannel.inputValue()).value;\n  }\n\n  async textContent(): Promise<string | null> {\n    const value = (await this._elementChannel.textContent()).value;\n    return value === undefined ? null : value;\n  }\n\n  async innerText(): Promise<string> {\n    return (await this._elementChannel.innerText()).value;\n  }\n\n  async innerHTML(): Promise<string> {\n    return (await this._elementChannel.innerHTML()).value;\n  }\n\n  async isChecked(): Promise<boolean> {\n    return (await this._elementChannel.isChecked()).value;\n  }\n\n  async isDisabled(): Promise<boolean> {\n    return (await this._elementChannel.isDisabled()).value;\n  }\n\n  async isEditable(): Promise<boolean> {\n    return (await this._elementChannel.isEditable()).value;\n  }\n\n  async isEnabled(): Promise<boolean> {\n    return (await this._elementChannel.isEnabled()).value;\n  }\n\n  async isHidden(): Promise<boolean> {\n    return (await this._elementChannel.isHidden()).value;\n  }\n\n  async isVisible(): Promise<boolean> {\n    return (await this._elementChannel.isVisible()).value;\n  }\n\n  async dispatchEvent(type: string, eventInit: Object = {}) {\n    await this._elementChannel.dispatchEvent({ type, eventInit: serializeArgument(eventInit) });\n  }\n\n  async scrollIntoViewIfNeeded(options: channels.ElementHandleScrollIntoViewIfNeededOptions & TimeoutOptions = {}) {\n    await this._elementChannel.scrollIntoViewIfNeeded({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async hover(options: channels.ElementHandleHoverOptions & TimeoutOptions = {}): Promise<void> {\n    await this._elementChannel.hover({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async click(options: channels.ElementHandleClickOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._elementChannel.click({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async dblclick(options: channels.ElementHandleDblclickOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._elementChannel.dblclick({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async tap(options: channels.ElementHandleTapOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._elementChannel.tap({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async selectOption(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options: SelectOptionOptions = {}): Promise<string[]> {\n    const result = await this._elementChannel.selectOption({ ...convertSelectOptionValues(values), ...options, timeout: this._frame._timeout(options) });\n    return result.values;\n  }\n\n  async fill(value: string, options: channels.ElementHandleFillOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._elementChannel.fill({ value, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async selectText(options: channels.ElementHandleSelectTextOptions & TimeoutOptions = {}): Promise<void> {\n    await this._elementChannel.selectText({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async setInputFiles(files: string | FilePayload | string[] | FilePayload[], options: channels.ElementHandleSetInputFilesOptions & TimeoutOptions = {}) {\n    const frame = await this.ownerFrame();\n    if (!frame)\n      throw new Error('Cannot set input files to detached element');\n    const converted = await convertInputFiles(this._platform, files, frame.page().context());\n    await this._elementChannel.setInputFiles({ ...converted, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async focus(): Promise<void> {\n    await this._elementChannel.focus();\n  }\n\n  async type(text: string, options: channels.ElementHandleTypeOptions & TimeoutOptions = {}): Promise<void> {\n    await this._elementChannel.type({ text, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async press(key: string, options: channels.ElementHandlePressOptions & TimeoutOptions = {}): Promise<void> {\n    await this._elementChannel.press({ key, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async check(options: channels.ElementHandleCheckOptions & TimeoutOptions = {}) {\n    return await this._elementChannel.check({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async uncheck(options: channels.ElementHandleUncheckOptions & TimeoutOptions = {}) {\n    return await this._elementChannel.uncheck({ ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async setChecked(checked: boolean, options?: channels.ElementHandleCheckOptions) {\n    if (checked)\n      await this.check(options);\n    else\n      await this.uncheck(options);\n  }\n\n  async boundingBox(): Promise<Rect | null> {\n    const value = (await this._elementChannel.boundingBox()).value;\n    return value === undefined ? null : value;\n  }\n\n  async screenshot(options: Omit<channels.ElementHandleScreenshotOptions, 'mask'> & TimeoutOptions & { path?: string, mask?: api.Locator[] } = {}): Promise<Buffer> {\n    const mask = options.mask as Locator[] | undefined;\n    const copy: channels.ElementHandleScreenshotParams = { ...options, mask: undefined, timeout: this._frame._timeout(options) };\n    if (!copy.type)\n      copy.type = determineScreenshotType(options);\n    if (mask) {\n      copy.mask = mask.map(locator => ({\n        frame: locator._frame._channel,\n        selector: locator._selector,\n      }));\n    }\n    const result = await this._elementChannel.screenshot(copy);\n    if (options.path) {\n      await mkdirIfNeeded(this._platform, options.path);\n      await this._platform.fs().promises.writeFile(options.path, result.binary);\n    }\n    return result.binary;\n  }\n\n  async $(selector: string): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    return ElementHandle.fromNullable((await this._elementChannel.querySelector({ selector })).element) as ElementHandle<SVGElement | HTMLElement> | null;\n  }\n\n  async $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]> {\n    const result = await this._elementChannel.querySelectorAll({ selector });\n    return result.elements.map(h => ElementHandle.from(h) as ElementHandle<SVGElement | HTMLElement>);\n  }\n\n  async $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R> {\n    const result = await this._elementChannel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R> {\n    const result = await this._elementChannel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === 'function', arg: serializeArgument(arg) });\n    return parseResult(result.value);\n  }\n\n  async waitForElementState(state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled', options: TimeoutOptions = {}): Promise<void> {\n    return await this._elementChannel.waitForElementState({ state, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  waitForSelector(selector: string, options: channels.ElementHandleWaitForSelectorOptions & TimeoutOptions & { state: 'attached' | 'visible' }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n  waitForSelector(selector: string, options?: channels.ElementHandleWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n  async waitForSelector(selector: string, options: channels.ElementHandleWaitForSelectorOptions & TimeoutOptions = {}): Promise<ElementHandle<SVGElement | HTMLElement> | null> {\n    const result = await this._elementChannel.waitForSelector({ selector, ...options, timeout: this._frame._timeout(options) });\n    return ElementHandle.fromNullable(result.element) as ElementHandle<SVGElement | HTMLElement> | null;\n  }\n}\n\nexport function convertSelectOptionValues(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null): { elements?: channels.ElementHandleChannel[], options?: SelectOption[] } {\n  if (values === null)\n    return {};\n  if (!Array.isArray(values))\n    values = [values as any];\n  if (!values.length)\n    return {};\n  for (let i = 0; i < values.length; i++)\n    assert(values[i] !== null, `options[${i}]: expected object, got null`);\n  if (values[0] instanceof ElementHandle)\n    return { elements: (values as ElementHandle[]).map((v: ElementHandle) => v._elementChannel) };\n  if (isString(values[0]))\n    return { options: (values as string[]).map(valueOrLabel => ({ valueOrLabel })) };\n  return { options: values as SelectOption[] };\n}\n\ntype SetInputFilesFiles = Pick<channels.ElementHandleSetInputFilesParams, 'payloads' | 'localPaths' | 'localDirectory' | 'streams' | 'directoryStream'>;\n\nfunction filePayloadExceedsSizeLimit(payloads: FilePayload[]) {\n  return payloads.reduce((size, item) => size + (item.buffer ? item.buffer.byteLength : 0), 0) >= fileUploadSizeLimit;\n}\n\nasync function resolvePathsAndDirectoryForInputFiles(platform: Platform, items: string[]): Promise<[string[] | undefined, string | undefined]> {\n  let localPaths: string[] | undefined;\n  let localDirectory: string | undefined;\n  for (const item of items) {\n    const stat = await platform.fs().promises.stat(item as string);\n    if (stat.isDirectory()) {\n      if (localDirectory)\n        throw new Error('Multiple directories are not supported');\n      localDirectory = platform.path().resolve(item as string);\n    } else {\n      localPaths ??= [];\n      localPaths.push(platform.path().resolve(item as string));\n    }\n  }\n  if (localPaths?.length && localDirectory)\n    throw new Error('File paths must be all files or a single directory');\n  return [localPaths, localDirectory];\n}\n\nexport async function convertInputFiles(platform: Platform, files: string | FilePayload | string[] | FilePayload[], context: BrowserContext): Promise<SetInputFilesFiles> {\n  const items: (string | FilePayload)[] = Array.isArray(files) ? files.slice() : [files];\n\n  if (items.some(item => typeof item === 'string')) {\n    if (!items.every(item => typeof item === 'string'))\n      throw new Error('File paths cannot be mixed with buffers');\n\n    const [localPaths, localDirectory] = await resolvePathsAndDirectoryForInputFiles(platform, items);\n\n    if (context._connection.isRemote()) {\n      const files = localDirectory ? (await platform.fs().promises.readdir(localDirectory, { withFileTypes: true, recursive: true })).filter(f => f.isFile()).map(f => platform.path().join(f.path, f.name)) : localPaths!;\n      const { writableStreams, rootDir } = await context._wrapApiCall(async () => context._channel.createTempFiles({\n        rootDirName: localDirectory ? platform.path().basename(localDirectory) : undefined,\n        items: await Promise.all(files.map(async file => {\n          const lastModifiedMs = (await platform.fs().promises.stat(file)).mtimeMs;\n          return {\n            name: localDirectory ? platform.path().relative(localDirectory, file) : platform.path().basename(file),\n            lastModifiedMs\n          };\n        })),\n      }), { internal: true });\n      for (let i = 0; i < files.length; i++) {\n        const writable = WritableStream.from(writableStreams[i]);\n        await platform.streamFile(files[i], writable.stream());\n      }\n      return {\n        directoryStream: rootDir,\n        streams: localDirectory ? undefined : writableStreams,\n      };\n    }\n    return {\n      localPaths,\n      localDirectory,\n    };\n  }\n\n  const payloads = items as FilePayload[];\n  if (filePayloadExceedsSizeLimit(payloads))\n    throw new Error('Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.');\n  return { payloads };\n}\n\nexport function determineScreenshotType(options: { path?: string, type?: 'png' | 'jpeg' }): 'png' | 'jpeg' | undefined {\n  if (options.path) {\n    const mimeType = getMimeTypeForPath(options.path);\n    if (mimeType === 'image/png')\n      return 'png';\n    else if (mimeType === 'image/jpeg')\n      return 'jpeg';\n    throw new Error(`path: unsupported mime type \"${mimeType}\"`);\n  }\n  return options.type;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,mBAAsB;AACtB,sBAAyD;AACzD,oBAAuB;AACvB,uBAAmD;AACnD,kBAAyB;AACzB,4BAA+B;AAC/B,sBAAmC;AAW5B,MAAM,sBAA6C,yBAAyC;AAAA,EAIjG,OAAgB,KAAK,QAAsD;AACzE,WAAQ,OAAe;AAAA,EACzB;AAAA,EAEA,OAAO,aAAa,QAAyE;AAC3F,WAAO,SAAS,cAAc,KAAK,MAAM,IAAI;AAAA,EAC/C;AAAA,EAEA,YAAY,QAAsB,MAAc,MAAc,aAA2C;AACvG,UAAM,QAAQ,MAAM,MAAM,WAAW;AACrC,SAAK,SAAS;AACd,SAAK,kBAAkB,KAAK;AAAA,EAC9B;AAAA,EAES,YAAsD;AAC7D,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,aAAoC;AACxC,WAAO,mBAAM,cAAc,MAAM,KAAK,gBAAgB,WAAW,GAAG,KAAK;AAAA,EAC3E;AAAA,EAEA,MAAM,eAAsC;AAC1C,WAAO,mBAAM,cAAc,MAAM,KAAK,gBAAgB,aAAa,GAAG,KAAK;AAAA,EAC7E;AAAA,EAEA,MAAM,aAAa,MAAsC;AACvD,UAAM,SAAS,MAAM,KAAK,gBAAgB,aAAa,EAAE,KAAK,CAAC,GAAG;AAClE,WAAO,UAAU,SAAY,OAAO;AAAA,EACtC;AAAA,EAEA,MAAM,aAA8B;AAClC,YAAQ,MAAM,KAAK,gBAAgB,WAAW,GAAG;AAAA,EACnD;AAAA,EAEA,MAAM,cAAsC;AAC1C,UAAM,SAAS,MAAM,KAAK,gBAAgB,YAAY,GAAG;AACzD,WAAO,UAAU,SAAY,OAAO;AAAA,EACtC;AAAA,EAEA,MAAM,YAA6B;AACjC,YAAQ,MAAM,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAClD;AAAA,EAEA,MAAM,YAA6B;AACjC,YAAQ,MAAM,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAClD;AAAA,EAEA,MAAM,YAA8B;AAClC,YAAQ,MAAM,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAClD;AAAA,EAEA,MAAM,aAA+B;AACnC,YAAQ,MAAM,KAAK,gBAAgB,WAAW,GAAG;AAAA,EACnD;AAAA,EAEA,MAAM,aAA+B;AACnC,YAAQ,MAAM,KAAK,gBAAgB,WAAW,GAAG;AAAA,EACnD;AAAA,EAEA,MAAM,YAA8B;AAClC,YAAQ,MAAM,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAClD;AAAA,EAEA,MAAM,WAA6B;AACjC,YAAQ,MAAM,KAAK,gBAAgB,SAAS,GAAG;AAAA,EACjD;AAAA,EAEA,MAAM,YAA8B;AAClC,YAAQ,MAAM,KAAK,gBAAgB,UAAU,GAAG;AAAA,EAClD;AAAA,EAEA,MAAM,cAAc,MAAc,YAAoB,CAAC,GAAG;AACxD,UAAM,KAAK,gBAAgB,cAAc,EAAE,MAAM,eAAW,mCAAkB,SAAS,EAAE,CAAC;AAAA,EAC5F;AAAA,EAEA,MAAM,uBAAuB,UAAgF,CAAC,GAAG;AAC/G,UAAM,KAAK,gBAAgB,uBAAuB,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC1G;AAAA,EAEA,MAAM,MAAM,UAA+D,CAAC,GAAkB;AAC5F,UAAM,KAAK,gBAAgB,MAAM,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EACzF;AAAA,EAEA,MAAM,MAAM,UAA+D,CAAC,GAAkB;AAC5F,WAAO,MAAM,KAAK,gBAAgB,MAAM,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAChG;AAAA,EAEA,MAAM,SAAS,UAAkE,CAAC,GAAkB;AAClG,WAAO,MAAM,KAAK,gBAAgB,SAAS,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EACnG;AAAA,EAEA,MAAM,IAAI,UAA6D,CAAC,GAAkB;AACxF,WAAO,MAAM,KAAK,gBAAgB,IAAI,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC9F;AAAA,EAEA,MAAM,aAAa,QAA4G,UAA+B,CAAC,GAAsB;AACnL,UAAM,SAAS,MAAM,KAAK,gBAAgB,aAAa,EAAE,GAAG,0BAA0B,MAAM,GAAG,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AACnJ,WAAO,OAAO;AAAA,EAChB;AAAA,EAEA,MAAM,KAAK,OAAe,UAA8D,CAAC,GAAkB;AACzG,WAAO,MAAM,KAAK,gBAAgB,KAAK,EAAE,OAAO,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EACtG;AAAA,EAEA,MAAM,WAAW,UAAoE,CAAC,GAAkB;AACtG,UAAM,KAAK,gBAAgB,WAAW,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC9F;AAAA,EAEA,MAAM,cAAc,OAAwD,UAAuE,CAAC,GAAG;AACrJ,UAAM,QAAQ,MAAM,KAAK,WAAW;AACpC,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,4CAA4C;AAC9D,UAAM,YAAY,MAAM,kBAAkB,KAAK,WAAW,OAAO,MAAM,KAAK,EAAE,QAAQ,CAAC;AACvF,UAAM,KAAK,gBAAgB,cAAc,EAAE,GAAG,WAAW,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC/G;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,KAAK,gBAAgB,MAAM;AAAA,EACnC;AAAA,EAEA,MAAM,KAAK,MAAc,UAA8D,CAAC,GAAkB;AACxG,UAAM,KAAK,gBAAgB,KAAK,EAAE,MAAM,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC9F;AAAA,EAEA,MAAM,MAAM,KAAa,UAA+D,CAAC,GAAkB;AACzG,UAAM,KAAK,gBAAgB,MAAM,EAAE,KAAK,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAC9F;AAAA,EAEA,MAAM,MAAM,UAA+D,CAAC,GAAG;AAC7E,WAAO,MAAM,KAAK,gBAAgB,MAAM,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAChG;AAAA,EAEA,MAAM,QAAQ,UAAiE,CAAC,GAAG;AACjF,WAAO,MAAM,KAAK,gBAAgB,QAAQ,EAAE,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EAClG;AAAA,EAEA,MAAM,WAAW,SAAkB,SAA8C;AAC/E,QAAI;AACF,YAAM,KAAK,MAAM,OAAO;AAAA;AAExB,YAAM,KAAK,QAAQ,OAAO;AAAA,EAC9B;AAAA,EAEA,MAAM,cAAoC;AACxC,UAAM,SAAS,MAAM,KAAK,gBAAgB,YAAY,GAAG;AACzD,WAAO,UAAU,SAAY,OAAO;AAAA,EACtC;AAAA,EAEA,MAAM,WAAW,UAA4H,CAAC,GAAoB;AAChK,UAAM,OAAO,QAAQ;AACrB,UAAM,OAA+C,EAAE,GAAG,SAAS,MAAM,QAAW,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE;AAC3H,QAAI,CAAC,KAAK;AACR,WAAK,OAAO,wBAAwB,OAAO;AAC7C,QAAI,MAAM;AACR,WAAK,OAAO,KAAK,IAAI,cAAY;AAAA,QAC/B,OAAO,QAAQ,OAAO;AAAA,QACtB,UAAU,QAAQ;AAAA,MACpB,EAAE;AAAA,IACJ;AACA,UAAM,SAAS,MAAM,KAAK,gBAAgB,WAAW,IAAI;AACzD,QAAI,QAAQ,MAAM;AAChB,gBAAM,gCAAc,KAAK,WAAW,QAAQ,IAAI;AAChD,YAAM,KAAK,UAAU,GAAG,EAAE,SAAS,UAAU,QAAQ,MAAM,OAAO,MAAM;AAAA,IAC1E;AACA,WAAO,OAAO;AAAA,EAChB;AAAA,EAEA,MAAM,EAAE,UAA2E;AACjF,WAAO,cAAc,cAAc,MAAM,KAAK,gBAAgB,cAAc,EAAE,SAAS,CAAC,GAAG,OAAO;AAAA,EACpG;AAAA,EAEA,MAAM,GAAG,UAAsE;AAC7E,UAAM,SAAS,MAAM,KAAK,gBAAgB,iBAAiB,EAAE,SAAS,CAAC;AACvE,WAAO,OAAO,SAAS,IAAI,OAAK,cAAc,KAAK,CAAC,CAA4C;AAAA,EAClG;AAAA,EAEA,MAAM,MAAc,UAAkB,cAAuD,KAAuB;AAClH,UAAM,SAAS,MAAM,KAAK,gBAAgB,eAAe,EAAE,UAAU,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,iBAAiB,YAAY,SAAK,mCAAkB,GAAG,EAAE,CAAC;AACpL,eAAO,6BAAY,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,MAAM,OAAe,UAAkB,cAAyD,KAAuB;AACrH,UAAM,SAAS,MAAM,KAAK,gBAAgB,kBAAkB,EAAE,UAAU,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,iBAAiB,YAAY,SAAK,mCAAkB,GAAG,EAAE,CAAC;AACvL,eAAO,6BAAY,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,MAAM,oBAAoB,OAAiE,UAA0B,CAAC,GAAkB;AACtI,WAAO,MAAM,KAAK,gBAAgB,oBAAoB,EAAE,OAAO,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAAA,EACrH;AAAA,EAIA,MAAM,gBAAgB,UAAkB,UAAyE,CAAC,GAA4D;AAC5K,UAAM,SAAS,MAAM,KAAK,gBAAgB,gBAAgB,EAAE,UAAU,GAAG,SAAS,SAAS,KAAK,OAAO,SAAS,OAAO,EAAE,CAAC;AAC1H,WAAO,cAAc,aAAa,OAAO,OAAO;AAAA,EAClD;AACF;AAEO,SAAS,0BAA0B,QAAsL;AAC9N,MAAI,WAAW;AACb,WAAO,CAAC;AACV,MAAI,CAAC,MAAM,QAAQ,MAAM;AACvB,aAAS,CAAC,MAAa;AACzB,MAAI,CAAC,OAAO;AACV,WAAO,CAAC;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ;AACjC,8BAAO,OAAO,CAAC,MAAM,MAAM,WAAW,CAAC,8BAA8B;AACvE,MAAI,OAAO,CAAC,aAAa;AACvB,WAAO,EAAE,UAAW,OAA2B,IAAI,CAAC,MAAqB,EAAE,eAAe,EAAE;AAC9F,UAAI,sBAAS,OAAO,CAAC,CAAC;AACpB,WAAO,EAAE,SAAU,OAAoB,IAAI,mBAAiB,EAAE,aAAa,EAAE,EAAE;AACjF,SAAO,EAAE,SAAS,OAAyB;AAC7C;AAIA,SAAS,4BAA4B,UAAyB;AAC5D,SAAO,SAAS,OAAO,CAAC,MAAM,SAAS,QAAQ,KAAK,SAAS,KAAK,OAAO,aAAa,IAAI,CAAC,KAAK;AAClG;AAEA,eAAe,sCAAsC,UAAoB,OAAsE;AAC7I,MAAI;AACJ,MAAI;AACJ,aAAW,QAAQ,OAAO;AACxB,UAAM,OAAO,MAAM,SAAS,GAAG,EAAE,SAAS,KAAK,IAAc;AAC7D,QAAI,KAAK,YAAY,GAAG;AACtB,UAAI;AACF,cAAM,IAAI,MAAM,wCAAwC;AAC1D,uBAAiB,SAAS,KAAK,EAAE,QAAQ,IAAc;AAAA,IACzD,OAAO;AACL,qBAAe,CAAC;AAChB,iBAAW,KAAK,SAAS,KAAK,EAAE,QAAQ,IAAc,CAAC;AAAA,IACzD;AAAA,EACF;AACA,MAAI,YAAY,UAAU;AACxB,UAAM,IAAI,MAAM,oDAAoD;AACtE,SAAO,CAAC,YAAY,cAAc;AACpC;AAEA,eAAsB,kBAAkB,UAAoB,OAAwD,SAAsD;AACxK,QAAM,QAAkC,MAAM,QAAQ,KAAK,IAAI,MAAM,MAAM,IAAI,CAAC,KAAK;AAErF,MAAI,MAAM,KAAK,UAAQ,OAAO,SAAS,QAAQ,GAAG;AAChD,QAAI,CAAC,MAAM,MAAM,UAAQ,OAAO,SAAS,QAAQ;AAC/C,YAAM,IAAI,MAAM,yCAAyC;AAE3D,UAAM,CAAC,YAAY,cAAc,IAAI,MAAM,sCAAsC,UAAU,KAAK;AAEhG,QAAI,QAAQ,YAAY,SAAS,GAAG;AAClC,YAAMA,SAAQ,kBAAkB,MAAM,SAAS,GAAG,EAAE,SAAS,QAAQ,gBAAgB,EAAE,eAAe,MAAM,WAAW,KAAK,CAAC,GAAG,OAAO,OAAK,EAAE,OAAO,CAAC,EAAE,IAAI,OAAK,SAAS,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,IAAI;AACzM,YAAM,EAAE,iBAAiB,QAAQ,IAAI,MAAM,QAAQ,aAAa,YAAY,QAAQ,SAAS,gBAAgB;AAAA,QAC3G,aAAa,iBAAiB,SAAS,KAAK,EAAE,SAAS,cAAc,IAAI;AAAA,QACzE,OAAO,MAAM,QAAQ,IAAIA,OAAM,IAAI,OAAM,SAAQ;AAC/C,gBAAM,kBAAkB,MAAM,SAAS,GAAG,EAAE,SAAS,KAAK,IAAI,GAAG;AACjE,iBAAO;AAAA,YACL,MAAM,iBAAiB,SAAS,KAAK,EAAE,SAAS,gBAAgB,IAAI,IAAI,SAAS,KAAK,EAAE,SAAS,IAAI;AAAA,YACrG;AAAA,UACF;AAAA,QACF,CAAC,CAAC;AAAA,MACJ,CAAC,GAAG,EAAE,UAAU,KAAK,CAAC;AACtB,eAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,KAAK;AACrC,cAAM,WAAW,qCAAe,KAAK,gBAAgB,CAAC,CAAC;AACvD,cAAM,SAAS,WAAWA,OAAM,CAAC,GAAG,SAAS,OAAO,CAAC;AAAA,MACvD;AACA,aAAO;AAAA,QACL,iBAAiB;AAAA,QACjB,SAAS,iBAAiB,SAAY;AAAA,MACxC;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAW;AACjB,MAAI,4BAA4B,QAAQ;AACtC,UAAM,IAAI,MAAM,0FAA0F;AAC5G,SAAO,EAAE,SAAS;AACpB;AAEO,SAAS,wBAAwB,SAA+E;AACrH,MAAI,QAAQ,MAAM;AAChB,UAAM,eAAW,oCAAmB,QAAQ,IAAI;AAChD,QAAI,aAAa;AACf,aAAO;AAAA,aACA,aAAa;AACpB,aAAO;AACT,UAAM,IAAI,MAAM,gCAAgC,QAAQ,GAAG;AAAA,EAC7D;AACA,SAAO,QAAQ;AACjB;",
  "names": ["files"]
}

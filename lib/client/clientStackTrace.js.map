{
  "version": 3,
  "sources": ["../../src/client/clientStackTrace.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { captureRawStack, parseStackFrame } from '../utils/isomorphic/stackTrace';\n\nimport type { Platform } from './platform';\nimport type { StackFrame } from '@isomorphic/stackTrace';\n\nexport function captureLibraryStackTrace(platform: Platform): { frames: StackFrame[], apiName: string } {\n  const stack = captureRawStack();\n\n  type ParsedFrame = {\n    frame: StackFrame;\n    frameText: string;\n    isPlaywrightLibrary: boolean;\n  };\n  let parsedFrames = stack.map(line => {\n    const frame = parseStackFrame(line, platform.pathSeparator, platform.showInternalStackFrames());\n    if (!frame || !frame.file)\n      return null;\n    const isPlaywrightLibrary = !!platform.coreDir && frame.file.startsWith(platform.coreDir);\n    const parsed: ParsedFrame = {\n      frame,\n      frameText: line,\n      isPlaywrightLibrary\n    };\n    return parsed;\n  }).filter(Boolean) as ParsedFrame[];\n\n  let apiName = '';\n\n  // Deepest transition between non-client code calling into client\n  // code is the api entry.\n  for (let i = 0; i < parsedFrames.length - 1; i++) {\n    const parsedFrame = parsedFrames[i];\n    if (parsedFrame.isPlaywrightLibrary && !parsedFrames[i + 1].isPlaywrightLibrary) {\n      apiName = apiName || normalizeAPIName(parsedFrame.frame.function);\n      break;\n    }\n  }\n\n  function normalizeAPIName(name?: string): string {\n    if (!name)\n      return '';\n    const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);\n    if (!match)\n      return name;\n    return match[1].toLowerCase() + match[2];\n  }\n\n  // This is for the inspector so that it did not include the test runner stack frames.\n  const filterPrefixes = platform.boxedStackPrefixes();\n  parsedFrames = parsedFrames.filter(f => {\n    if (filterPrefixes.some(prefix => f.frame.file.startsWith(prefix)))\n      return false;\n    return true;\n  });\n\n  return {\n    frames: parsedFrames.map(p => p.frame),\n    apiName\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,wBAAiD;AAK1C,SAAS,yBAAyB,UAA+D;AACtG,QAAM,YAAQ,mCAAgB;AAO9B,MAAI,eAAe,MAAM,IAAI,UAAQ;AACnC,UAAM,YAAQ,mCAAgB,MAAM,SAAS,eAAe,SAAS,wBAAwB,CAAC;AAC9F,QAAI,CAAC,SAAS,CAAC,MAAM;AACnB,aAAO;AACT,UAAM,sBAAsB,CAAC,CAAC,SAAS,WAAW,MAAM,KAAK,WAAW,SAAS,OAAO;AACxF,UAAM,SAAsB;AAAA,MAC1B;AAAA,MACA,WAAW;AAAA,MACX;AAAA,IACF;AACA,WAAO;AAAA,EACT,CAAC,EAAE,OAAO,OAAO;AAEjB,MAAI,UAAU;AAId,WAAS,IAAI,GAAG,IAAI,aAAa,SAAS,GAAG,KAAK;AAChD,UAAM,cAAc,aAAa,CAAC;AAClC,QAAI,YAAY,uBAAuB,CAAC,aAAa,IAAI,CAAC,EAAE,qBAAqB;AAC/E,gBAAU,WAAW,iBAAiB,YAAY,MAAM,QAAQ;AAChE;AAAA,IACF;AAAA,EACF;AAEA,WAAS,iBAAiB,MAAuB;AAC/C,QAAI,CAAC;AACH,aAAO;AACT,UAAM,QAAQ,KAAK,MAAM,wBAAwB;AACjD,QAAI,CAAC;AACH,aAAO;AACT,WAAO,MAAM,CAAC,EAAE,YAAY,IAAI,MAAM,CAAC;AAAA,EACzC;AAGA,QAAM,iBAAiB,SAAS,mBAAmB;AACnD,iBAAe,aAAa,OAAO,OAAK;AACtC,QAAI,eAAe,KAAK,YAAU,EAAE,MAAM,KAAK,WAAW,MAAM,CAAC;AAC/D,aAAO;AACT,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AAAA,IACL,QAAQ,aAAa,IAAI,OAAK,EAAE,KAAK;AAAA,IACrC;AAAA,EACF;AACF;",
  "names": []
}

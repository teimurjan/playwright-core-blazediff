{
  "version": 3,
  "sources": ["../../src/client/fetch.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { toClientCertificatesProtocol } from './browserContext';\nimport { ChannelOwner } from './channelOwner';\nimport { TargetClosedError, isTargetClosedError } from './errors';\nimport { RawHeaders } from './network';\nimport { Tracing } from './tracing';\nimport { assert } from '../utils/isomorphic/assert';\nimport { mkdirIfNeeded } from './fileUtils';\nimport { headersObjectToArray } from '../utils/isomorphic/headers';\nimport { isString } from '../utils/isomorphic/rtti';\nimport { TimeoutSettings } from './timeoutSettings';\n\nimport type { Playwright } from './playwright';\nimport type { ClientCertificate, FilePayload, Headers, SetStorageState, StorageState, TimeoutOptions } from './types';\nimport type { Serializable } from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { HeadersArray, NameValue } from '../utils/isomorphic/types';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nimport type * as fs from 'fs';\n\nexport type FetchOptions = {\n  params?: { [key: string]: string | number | boolean; } | URLSearchParams | string,\n  method?: string,\n  headers?: Headers,\n  data?: string | Buffer | Serializable,\n  form?: { [key: string]: string|number|boolean; } | FormData;\n  multipart?: { [key: string]: string|number|boolean|fs.ReadStream|FilePayload; } | FormData;\n  timeout?: number,\n  failOnStatusCode?: boolean,\n  ignoreHTTPSErrors?: boolean,\n  maxRedirects?: number,\n  maxRetries?: number,\n};\n\ntype NewContextOptions = Omit<channels.PlaywrightNewRequestOptions, 'extraHTTPHeaders' | 'clientCertificates' | 'storageState' | 'tracesDir'> & {\n  extraHTTPHeaders?: Headers,\n  storageState?: string | SetStorageState,\n  clientCertificates?: ClientCertificate[];\n};\n\ntype RequestWithBodyOptions = Omit<FetchOptions, 'method'>;\n\nexport class APIRequest implements api.APIRequest {\n  private _playwright: Playwright;\n  readonly _contexts = new Set<APIRequestContext>();\n\n  constructor(playwright: Playwright) {\n    this._playwright = playwright;\n  }\n\n  async newContext(options: NewContextOptions & TimeoutOptions = {}): Promise<APIRequestContext> {\n    options = {\n      ...this._playwright._defaultContextOptions,\n      ...options,\n    };\n    const storageState = typeof options.storageState === 'string' ?\n      JSON.parse(await this._playwright._platform.fs().promises.readFile(options.storageState, 'utf8')) :\n      options.storageState;\n    const context = APIRequestContext.from((await this._playwright._channel.newRequest({\n      ...options,\n      extraHTTPHeaders: options.extraHTTPHeaders ? headersObjectToArray(options.extraHTTPHeaders) : undefined,\n      storageState,\n      tracesDir: this._playwright._defaultLaunchOptions?.tracesDir, // We do not expose tracesDir in the API, so do not allow options to accidentally override it.\n      clientCertificates: await toClientCertificatesProtocol(this._playwright._platform, options.clientCertificates),\n    })).request);\n    this._contexts.add(context);\n    context._request = this;\n    context._timeoutSettings.setDefaultTimeout(options.timeout ?? this._playwright._defaultContextTimeout);\n    context._tracing._tracesDir = this._playwright._defaultLaunchOptions?.tracesDir;\n    await context._instrumentation.runAfterCreateRequestContext(context);\n    return context;\n  }\n}\n\nexport class APIRequestContext extends ChannelOwner<channels.APIRequestContextChannel> implements api.APIRequestContext {\n  _request?: APIRequest;\n  readonly _tracing: Tracing;\n  private _closeReason: string | undefined;\n  _timeoutSettings: TimeoutSettings;\n\n  static from(channel: channels.APIRequestContextChannel): APIRequestContext {\n    return (channel as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.APIRequestContextInitializer) {\n    super(parent, type, guid, initializer);\n    this._tracing = Tracing.from(initializer.tracing);\n    this._timeoutSettings = new TimeoutSettings(this._platform);\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.dispose();\n  }\n\n  async dispose(options: { reason?: string } = {}): Promise<void> {\n    this._closeReason = options.reason;\n    await this._instrumentation.runBeforeCloseRequestContext(this);\n    try {\n      await this._channel.dispose(options);\n    } catch (e) {\n      if (isTargetClosedError(e))\n        return;\n      throw e;\n    }\n    this._tracing._resetStackCounter();\n    this._request?._contexts.delete(this);\n  }\n\n  async delete(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'DELETE',\n    });\n  }\n\n  async head(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'HEAD',\n    });\n  }\n\n  async get(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'GET',\n    });\n  }\n\n  async patch(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'PATCH',\n    });\n  }\n\n  async post(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'POST',\n    });\n  }\n\n  async put(url: string, options?: RequestWithBodyOptions): Promise<APIResponse> {\n    return await this.fetch(url, {\n      ...options,\n      method: 'PUT',\n    });\n  }\n\n  async fetch(urlOrRequest: string | api.Request, options: FetchOptions = {}): Promise<APIResponse> {\n    const url = isString(urlOrRequest) ? urlOrRequest : undefined;\n    const request = isString(urlOrRequest) ? undefined : urlOrRequest;\n    return await this._innerFetch({ url, request, ...options });\n  }\n\n  async _innerFetch(options: FetchOptions & { url?: string, request?: api.Request } = {}): Promise<APIResponse> {\n    return await this._wrapApiCall(async () => {\n      if (this._closeReason)\n        throw new TargetClosedError(this._closeReason);\n      assert(options.request || typeof options.url === 'string', 'First argument must be either URL string or Request');\n      assert((options.data === undefined ? 0 : 1) + (options.form === undefined ? 0 : 1) + (options.multipart === undefined ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);\n      assert(options.maxRedirects === undefined || options.maxRedirects >= 0, `'maxRedirects' must be greater than or equal to '0'`);\n      assert(options.maxRetries === undefined || options.maxRetries >= 0, `'maxRetries' must be greater than or equal to '0'`);\n      const url = options.url !== undefined ? options.url : options.request!.url();\n      const method = options.method || options.request?.method();\n      let encodedParams = undefined;\n      if (typeof options.params === 'string')\n        encodedParams = options.params;\n      else if (options.params instanceof URLSearchParams)\n        encodedParams = options.params.toString();\n      // Cannot call allHeaders() here as the request may be paused inside route handler.\n      const headersObj = options.headers || options.request?.headers();\n      const headers = headersObj ? headersObjectToArray(headersObj) : undefined;\n      let jsonData: any;\n      let formData: channels.NameValue[] | undefined;\n      let multipartData: channels.FormField[] | undefined;\n      let postDataBuffer: Buffer | undefined;\n      if (options.data !== undefined) {\n        if (isString(options.data)) {\n          if (isJsonContentType(headers))\n            jsonData = isJsonParsable(options.data) ? options.data : JSON.stringify(options.data);\n          else\n            postDataBuffer = Buffer.from(options.data, 'utf8');\n        } else if (Buffer.isBuffer(options.data)) {\n          postDataBuffer = options.data;\n        } else if (typeof options.data === 'object' || typeof options.data === 'number' || typeof options.data === 'boolean') {\n          jsonData = JSON.stringify(options.data);\n        } else {\n          throw new Error(`Unexpected 'data' type`);\n        }\n      } else if (options.form) {\n        if (globalThis.FormData && options.form instanceof FormData) {\n          formData = [];\n          for (const [name, value] of options.form.entries()) {\n            if (typeof value !== 'string')\n              throw new Error(`Expected string for options.form[\"${name}\"], found File. Please use options.multipart instead.`);\n            formData.push({ name, value });\n          }\n        } else {\n          formData = objectToArray(options.form);\n        }\n      } else if (options.multipart) {\n        multipartData = [];\n        if (globalThis.FormData && options.multipart instanceof FormData) {\n          const form = options.multipart;\n          for (const [name, value] of form.entries()) {\n            if (isString(value)) {\n              multipartData.push({ name, value });\n            } else {\n              const file: ServerFilePayload = {\n                name: value.name,\n                mimeType: value.type,\n                buffer: Buffer.from(await value.arrayBuffer()),\n              };\n              multipartData.push({ name, file });\n            }\n          }\n        } else {\n          // Convert file-like values to ServerFilePayload structs.\n          for (const [name, value] of Object.entries(options.multipart))\n            multipartData.push(await toFormField(this._platform, name, value));\n        }\n      }\n      if (postDataBuffer === undefined && jsonData === undefined && formData === undefined && multipartData === undefined)\n        postDataBuffer = options.request?.postDataBuffer() || undefined;\n      const fixtures = {\n        __testHookLookup: (options as any).__testHookLookup\n      };\n      const result = await this._channel.fetch({\n        url,\n        params: typeof options.params === 'object' ? objectToArray(options.params) : undefined,\n        encodedParams,\n        method,\n        headers,\n        postData: postDataBuffer,\n        jsonData,\n        formData,\n        multipartData,\n        timeout: this._timeoutSettings.timeout(options),\n        failOnStatusCode: options.failOnStatusCode,\n        ignoreHTTPSErrors: options.ignoreHTTPSErrors,\n        maxRedirects: options.maxRedirects,\n        maxRetries: options.maxRetries,\n        ...fixtures\n      });\n      return new APIResponse(this, result.response);\n    });\n  }\n\n  async storageState(options: { path?: string, indexedDB?: boolean } = {}): Promise<StorageState> {\n    const state = await this._channel.storageState({ indexedDB: options.indexedDB });\n    if (options.path) {\n      await mkdirIfNeeded(this._platform, options.path);\n      await this._platform.fs().promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');\n    }\n    return state;\n  }\n}\n\nasync function toFormField(platform: Platform, name: string, value: string | number | boolean | fs.ReadStream | FilePayload): Promise<channels.FormField> {\n  const typeOfValue = typeof value;\n  if (isFilePayload(value)) {\n    const payload = value as FilePayload;\n    if (!Buffer.isBuffer(payload.buffer))\n      throw new Error(`Unexpected buffer type of 'data.${name}'`);\n    return { name, file: filePayloadToJson(payload) };\n  } else if (typeOfValue === 'string' || typeOfValue === 'number' || typeOfValue === 'boolean') {\n    return { name, value: String(value) };\n  } else {\n    return { name, file: await readStreamToJson(platform, value as fs.ReadStream) };\n  }\n}\n\nfunction isJsonParsable(value: any) {\n  if (typeof value !== 'string')\n    return false;\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (e) {\n    if (e instanceof SyntaxError)\n      return false;\n    else\n      throw e;\n  }\n}\n\nexport class APIResponse implements api.APIResponse {\n  private readonly _initializer: channels.APIResponse;\n  private readonly _headers: RawHeaders;\n  readonly _request: APIRequestContext;\n\n  constructor(context: APIRequestContext, initializer: channels.APIResponse) {\n    this._request = context;\n    this._initializer = initializer;\n    this._headers = new RawHeaders(this._initializer.headers);\n\n    if (context._platform.inspectCustom)\n      (this as any)[context._platform.inspectCustom] = () => this._inspect();\n  }\n\n  ok(): boolean {\n    return this._initializer.status >= 200 && this._initializer.status <= 299;\n  }\n\n  url(): string {\n    return this._initializer.url;\n  }\n\n  status(): number {\n    return this._initializer.status;\n  }\n\n  statusText(): string {\n    return this._initializer.statusText;\n  }\n\n  headers(): Headers {\n    return this._headers.headers();\n  }\n\n  headersArray(): HeadersArray {\n    return this._headers.headersArray();\n  }\n\n  async body(): Promise<Buffer> {\n    return await this._request._wrapApiCall(async () => {\n      try {\n        const result = await this._request._channel.fetchResponseBody({ fetchUid: this._fetchUid() });\n        if (result.binary === undefined)\n          throw new Error('Response has been disposed');\n        return result.binary;\n      } catch (e) {\n        if (isTargetClosedError(e))\n          throw new Error('Response has been disposed');\n        throw e;\n      }\n    }, { internal: true });\n  }\n\n  async text(): Promise<string> {\n    const content = await this.body();\n    return content.toString('utf8');\n  }\n\n  async json(): Promise<object> {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.dispose();\n  }\n\n  async dispose(): Promise<void> {\n    await this._request._channel.disposeAPIResponse({ fetchUid: this._fetchUid() });\n  }\n\n  private _inspect() {\n    const headers = this.headersArray().map(({ name, value }) => `  ${name}: ${value}`);\n    return `APIResponse: ${this.status()} ${this.statusText()}\\n${headers.join('\\n')}`;\n  }\n\n  _fetchUid(): string {\n    return this._initializer.fetchUid;\n  }\n\n  async _fetchLog(): Promise<string[]> {\n    const { log } = await this._request._channel.fetchLog({ fetchUid: this._fetchUid() });\n    return log;\n  }\n}\n\ntype ServerFilePayload = NonNullable<channels.FormField['file']>;\n\nfunction filePayloadToJson(payload: FilePayload): ServerFilePayload {\n  return {\n    name: payload.name,\n    mimeType: payload.mimeType,\n    buffer: payload.buffer,\n  };\n}\n\nasync function readStreamToJson(platform: Platform, stream: fs.ReadStream): Promise<ServerFilePayload> {\n  const buffer = await new Promise<Buffer>((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    stream.on('data', chunk => chunks.push(chunk as Buffer));\n    stream.on('end', () => resolve(Buffer.concat(chunks)));\n    stream.on('error', err => reject(err));\n  });\n  const streamPath: string = Buffer.isBuffer(stream.path) ? stream.path.toString('utf8') : stream.path;\n  return {\n    name: platform.path().basename(streamPath),\n    buffer,\n  };\n}\n\nfunction isJsonContentType(headers?: HeadersArray): boolean {\n  if (!headers)\n    return false;\n  for (const { name, value } of headers) {\n    if (name.toLocaleLowerCase() === 'content-type')\n      return value === 'application/json';\n  }\n  return false;\n}\n\nfunction objectToArray(map?: { [key: string]: any }): NameValue[] | undefined {\n  if (!map)\n    return undefined;\n  const result = [];\n  for (const [name, value] of Object.entries(map)) {\n    if (value !== undefined)\n      result.push({ name, value: String(value) });\n  }\n  return result;\n}\n\nfunction isFilePayload(value: any): boolean {\n  return typeof value === 'object' && value['name'] && value['mimeType'] && value['buffer'];\n}\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../src/client/localUtils.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChannelOwner } from './channelOwner';\n\nimport type { Size } from './types';\nimport type * as channels from '@protocol/channels';\n\ntype DeviceDescriptor = {\n  userAgent: string,\n  viewport: Size,\n  deviceScaleFactor: number,\n  isMobile: boolean,\n  hasTouch: boolean,\n  defaultBrowserType: 'chromium' | 'firefox' | 'webkit'\n};\ntype Devices = { [name: string]: DeviceDescriptor };\n\nexport class LocalUtils extends ChannelOwner<channels.LocalUtilsChannel> {\n  readonly devices: Devices;\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.LocalUtilsInitializer) {\n    super(parent, type, guid, initializer);\n    this.devices = {};\n    for (const { name, descriptor } of initializer.deviceDescriptors)\n      this.devices[name] = descriptor;\n  }\n\n  async zip(params: channels.LocalUtilsZipParams): Promise<void> {\n    return await this._channel.zip(params);\n  }\n\n  async harOpen(params: channels.LocalUtilsHarOpenParams): Promise<channels.LocalUtilsHarOpenResult> {\n    return await this._channel.harOpen(params);\n  }\n\n  async harLookup(params: channels.LocalUtilsHarLookupParams): Promise<channels.LocalUtilsHarLookupResult> {\n    return await this._channel.harLookup(params);\n  }\n\n  async harClose(params: channels.LocalUtilsHarCloseParams): Promise<void> {\n    return await this._channel.harClose(params);\n  }\n\n  async harUnzip(params: channels.LocalUtilsHarUnzipParams): Promise<void> {\n    return await this._channel.harUnzip(params);\n  }\n\n  async tracingStarted(params: channels.LocalUtilsTracingStartedParams): Promise<channels.LocalUtilsTracingStartedResult> {\n    return await this._channel.tracingStarted(params);\n  }\n\n  async traceDiscarded(params: channels.LocalUtilsTraceDiscardedParams): Promise<void> {\n    return await this._channel.traceDiscarded(params);\n  }\n\n  async addStackToTracingNoReply(params: channels.LocalUtilsAddStackToTracingNoReplyParams): Promise<void> {\n    return await this._channel.addStackToTracingNoReply(params);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,0BAA6B;AAetB,MAAM,mBAAmB,iCAAyC;AAAA,EAGvE,YAAY,QAAsB,MAAc,MAAc,aAA6C;AACzG,UAAM,QAAQ,MAAM,MAAM,WAAW;AACrC,SAAK,UAAU,CAAC;AAChB,eAAW,EAAE,MAAM,WAAW,KAAK,YAAY;AAC7C,WAAK,QAAQ,IAAI,IAAI;AAAA,EACzB;AAAA,EAEA,MAAM,IAAI,QAAqD;AAC7D,WAAO,MAAM,KAAK,SAAS,IAAI,MAAM;AAAA,EACvC;AAAA,EAEA,MAAM,QAAQ,QAAqF;AACjG,WAAO,MAAM,KAAK,SAAS,QAAQ,MAAM;AAAA,EAC3C;AAAA,EAEA,MAAM,UAAU,QAAyF;AACvG,WAAO,MAAM,KAAK,SAAS,UAAU,MAAM;AAAA,EAC7C;AAAA,EAEA,MAAM,SAAS,QAA0D;AACvE,WAAO,MAAM,KAAK,SAAS,SAAS,MAAM;AAAA,EAC5C;AAAA,EAEA,MAAM,SAAS,QAA0D;AACvE,WAAO,MAAM,KAAK,SAAS,SAAS,MAAM;AAAA,EAC5C;AAAA,EAEA,MAAM,eAAe,QAAmG;AACtH,WAAO,MAAM,KAAK,SAAS,eAAe,MAAM;AAAA,EAClD;AAAA,EAEA,MAAM,eAAe,QAAgE;AACnF,WAAO,MAAM,KAAK,SAAS,eAAe,MAAM;AAAA,EAClD;AAAA,EAEA,MAAM,yBAAyB,QAA0E;AACvG,WAAO,MAAM,KAAK,SAAS,yBAAyB,MAAM;AAAA,EAC5D;AACF;",
  "names": []
}

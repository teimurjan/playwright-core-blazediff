{
  "version": 3,
  "sources": ["../../src/client/network.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChannelOwner } from './channelOwner';\nimport { isTargetClosedError } from './errors';\nimport { Events } from './events';\nimport { APIResponse } from './fetch';\nimport { Frame } from './frame';\nimport { Waiter } from './waiter';\nimport { Worker } from './worker';\nimport { assert } from '../utils/isomorphic/assert';\nimport { headersObjectToArray } from '../utils/isomorphic/headers';\nimport { urlMatches } from '../utils/isomorphic/urlMatch';\nimport { LongStandingScope, ManualPromise } from '../utils/isomorphic/manualPromise';\nimport { MultiMap } from '../utils/isomorphic/multimap';\nimport { isRegExp, isString } from '../utils/isomorphic/rtti';\nimport { rewriteErrorMessage } from '../utils/isomorphic/stackTrace';\nimport { getMimeTypeForPath } from '../utils/isomorphic/mimeType';\n\nimport type { BrowserContext } from './browserContext';\nimport type { Page } from './page';\nimport type { Headers, RemoteAddr, SecurityDetails, WaitForEventOptions } from './types';\nimport type { Serializable } from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { HeadersArray } from '../utils/isomorphic/types';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\nimport type { Platform, Zone } from './platform';\n\nexport type NetworkCookie = {\n  name: string,\n  value: string,\n  domain: string,\n  path: string,\n  expires: number,\n  httpOnly: boolean,\n  secure: boolean,\n  sameSite: 'Strict' | 'Lax' | 'None'\n};\n\nexport type SetNetworkCookieParam = {\n  name: string,\n  value: string,\n  url?: string,\n  domain?: string,\n  path?: string,\n  expires?: number,\n  httpOnly?: boolean,\n  secure?: boolean,\n  sameSite?: 'Strict' | 'Lax' | 'None'\n};\n\nexport type ClearNetworkCookieOptions = {\n  name?: string | RegExp,\n  domain?: string | RegExp,\n  path?: string | RegExp,\n};\n\ntype SerializedFallbackOverrides = {\n  url?: string;\n  method?: string;\n  headers?: Headers;\n  postDataBuffer?: Buffer;\n};\n\ntype FallbackOverrides = {\n  url?: string;\n  method?: string;\n  headers?: Headers;\n  postData?: string | Buffer | Serializable;\n};\n\nexport class Request extends ChannelOwner<channels.RequestChannel> implements api.Request {\n  private _redirectedFrom: Request | null = null;\n  private _redirectedTo: Request | null = null;\n  _failureText: string | null = null;\n  private _provisionalHeaders: RawHeaders;\n  private _actualHeadersPromise: Promise<RawHeaders> | undefined;\n  _timing: ResourceTiming;\n  private _fallbackOverrides: SerializedFallbackOverrides = {};\n\n  static from(request: channels.RequestChannel): Request {\n    return (request as any)._object;\n  }\n\n  static fromNullable(request: channels.RequestChannel | undefined): Request | null {\n    return request ? Request.from(request) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.RequestInitializer) {\n    super(parent, type, guid, initializer);\n    this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);\n    if (this._redirectedFrom)\n      this._redirectedFrom._redirectedTo = this;\n    this._provisionalHeaders = new RawHeaders(initializer.headers);\n    this._timing = {\n      startTime: 0,\n      domainLookupStart: -1,\n      domainLookupEnd: -1,\n      connectStart: -1,\n      secureConnectionStart: -1,\n      connectEnd: -1,\n      requestStart: -1,\n      responseStart: -1,\n      responseEnd: -1,\n    };\n  }\n\n  url(): string {\n    return this._fallbackOverrides.url || this._initializer.url;\n  }\n\n  resourceType(): string {\n    return this._initializer.resourceType;\n  }\n\n  method(): string {\n    return this._fallbackOverrides.method || this._initializer.method;\n  }\n\n  postData(): string | null {\n    return (this._fallbackOverrides.postDataBuffer || this._initializer.postData)?.toString('utf-8') || null;\n  }\n\n  postDataBuffer(): Buffer | null {\n    return this._fallbackOverrides.postDataBuffer || this._initializer.postData || null;\n  }\n\n  postDataJSON(): Object | null {\n    const postData = this.postData();\n    if (!postData)\n      return null;\n\n    const contentType = this.headers()['content-type'];\n    if (contentType?.includes('application/x-www-form-urlencoded')) {\n      const entries: Record<string, string> = {};\n      const parsed = new URLSearchParams(postData);\n      for (const [k, v] of parsed.entries())\n        entries[k] = v;\n      return entries;\n    }\n\n    try {\n      return JSON.parse(postData);\n    } catch (e) {\n      throw new Error('POST data is not a valid JSON object: ' + postData);\n    }\n  }\n\n  /**\n   * @deprecated\n   */\n  headers(): Headers {\n    if (this._fallbackOverrides.headers)\n      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();\n    return this._provisionalHeaders.headers();\n  }\n\n  async _actualHeaders(): Promise<RawHeaders> {\n    if (this._fallbackOverrides.headers)\n      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers);\n\n    if (!this._actualHeadersPromise) {\n      this._actualHeadersPromise = this._wrapApiCall(async () => {\n        return new RawHeaders((await this._channel.rawRequestHeaders()).headers);\n      }, { internal: true });\n    }\n    return await this._actualHeadersPromise;\n  }\n\n  async allHeaders(): Promise<Headers> {\n    return (await this._actualHeaders()).headers();\n  }\n\n  async headersArray(): Promise<HeadersArray> {\n    return (await this._actualHeaders()).headersArray();\n  }\n\n  async headerValue(name: string): Promise<string | null> {\n    return (await this._actualHeaders()).get(name);\n  }\n\n  async response(): Promise<Response | null> {\n    return Response.fromNullable((await this._channel.response()).response);\n  }\n\n  async _internalResponse(): Promise<Response | null> {\n    return Response.fromNullable((await this._channel.response()).response);\n  }\n\n  frame(): Frame {\n    if (!this._initializer.frame) {\n      assert(this.serviceWorker());\n      throw new Error('Service Worker requests do not have an associated frame.');\n    }\n    const frame = Frame.from(this._initializer.frame);\n    if (!frame._page) {\n      throw new Error([\n        'Frame for this navigation request is not available, because the request',\n        'was issued before the frame is created. You can check whether the request',\n        'is a navigation request by calling isNavigationRequest() method.',\n      ].join('\\n'));\n    }\n    return frame;\n  }\n\n  _safePage(): Page | null {\n    return Frame.fromNullable(this._initializer.frame)?._page || null;\n  }\n\n  serviceWorker(): Worker | null {\n    return this._initializer.serviceWorker ? Worker.from(this._initializer.serviceWorker) : null;\n  }\n\n  isNavigationRequest(): boolean {\n    return this._initializer.isNavigationRequest;\n  }\n\n  redirectedFrom(): Request | null {\n    return this._redirectedFrom;\n  }\n\n  redirectedTo(): Request | null {\n    return this._redirectedTo;\n  }\n\n  failure(): { errorText: string; } | null {\n    if (this._failureText === null)\n      return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n\n  timing(): ResourceTiming {\n    return this._timing;\n  }\n\n  async sizes(): Promise<RequestSizes> {\n    const response = await this.response();\n    if (!response)\n      throw new Error('Unable to fetch sizes for failed request');\n    return (await response._channel.sizes()).sizes;\n  }\n\n  _setResponseEndTiming(responseEndTiming: number) {\n    this._timing.responseEnd = responseEndTiming;\n    if (this._timing.responseStart === -1)\n      this._timing.responseStart = responseEndTiming;\n  }\n\n  _finalRequest(): Request {\n    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;\n  }\n\n  _applyFallbackOverrides(overrides: FallbackOverrides) {\n    if (overrides.url)\n      this._fallbackOverrides.url = overrides.url;\n    if (overrides.method)\n      this._fallbackOverrides.method = overrides.method;\n    if (overrides.headers)\n      this._fallbackOverrides.headers = overrides.headers;\n\n    if (isString(overrides.postData))\n      this._fallbackOverrides.postDataBuffer = Buffer.from(overrides.postData, 'utf-8');\n    else if (overrides.postData instanceof Buffer)\n      this._fallbackOverrides.postDataBuffer = overrides.postData;\n    else if (overrides.postData)\n      this._fallbackOverrides.postDataBuffer = Buffer.from(JSON.stringify(overrides.postData), 'utf-8');\n  }\n\n  _fallbackOverridesForContinue() {\n    return this._fallbackOverrides;\n  }\n\n  _targetClosedScope(): LongStandingScope {\n    return this.serviceWorker()?._closedScope || this._safePage()?._closedOrCrashedScope || new LongStandingScope();\n  }\n}\n\nexport class Route extends ChannelOwner<channels.RouteChannel> implements api.Route {\n  private _handlingPromise: ManualPromise<boolean> | null = null;\n  _context!: BrowserContext;\n  _didThrow: boolean = false;\n\n  static from(route: channels.RouteChannel): Route {\n    return (route as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.RouteInitializer) {\n    super(parent, type, guid, initializer);\n  }\n\n  request(): Request {\n    return Request.from(this._initializer.request);\n  }\n\n  private async _raceWithTargetClose(promise: Promise<any>): Promise<void> {\n    // When page closes or crashes, we catch any potential rejects from this Route.\n    // Note that page could be missing when routing popup's initial request that\n    // does not have a Page initialized just yet.\n    return await this.request()._targetClosedScope().safeRace(promise);\n  }\n\n  async _startHandling(): Promise<boolean> {\n    this._handlingPromise = new ManualPromise();\n    return await this._handlingPromise;\n  }\n\n  async fallback(options: FallbackOverrides = {}) {\n    this._checkNotHandled();\n    this.request()._applyFallbackOverrides(options);\n    this._reportHandled(false);\n  }\n\n  async abort(errorCode?: string) {\n    await this._handleRoute(async () => {\n      await this._raceWithTargetClose(this._channel.abort({ errorCode }));\n    });\n  }\n\n  async _redirectNavigationRequest(url: string) {\n    await this._handleRoute(async () => {\n      await this._raceWithTargetClose(this._channel.redirectNavigationRequest({ url }));\n    });\n  }\n\n  async fetch(options: FallbackOverrides & { maxRedirects?: number, maxRetries?: number, timeout?: number } = {}): Promise<APIResponse> {\n    return await this._wrapApiCall(async () => {\n      return await this._context.request._innerFetch({ request: this.request(), data: options.postData, ...options });\n    });\n  }\n\n  async fulfill(options: { response?: api.APIResponse, status?: number, headers?: Headers, contentType?: string, body?: string | Buffer, json?: any, path?: string } = {}) {\n    await this._handleRoute(async () => {\n      await this._innerFulfill(options);\n    });\n  }\n\n  private async _handleRoute(callback: () => Promise<void>) {\n    this._checkNotHandled();\n    try {\n      await callback();\n      this._reportHandled(true);\n    } catch (e) {\n      this._didThrow = true;\n      throw e;\n    }\n  }\n\n  private async _innerFulfill(options: { response?: api.APIResponse, status?: number, headers?: Headers, contentType?: string, body?: string | Buffer, json?: any, path?: string } = {}): Promise<void> {\n    let fetchResponseUid;\n    let { status: statusOption, headers: headersOption, body } = options;\n\n    if (options.json !== undefined) {\n      assert(options.body === undefined, 'Can specify either body or json parameters');\n      body = JSON.stringify(options.json);\n    }\n\n    if (options.response instanceof APIResponse) {\n      statusOption ??= options.response.status();\n      headersOption ??= options.response.headers();\n      if (body === undefined && options.path === undefined) {\n        if (options.response._request._connection === this._connection)\n          fetchResponseUid = (options.response as APIResponse)._fetchUid();\n        else\n          body = await options.response.body();\n      }\n    }\n\n    let isBase64 = false;\n    let length = 0;\n    if (options.path) {\n      const buffer = await this._platform.fs().promises.readFile(options.path);\n      body = buffer.toString('base64');\n      isBase64 = true;\n      length = buffer.length;\n    } else if (isString(body)) {\n      isBase64 = false;\n      length = Buffer.byteLength(body);\n    } else if (body) {\n      length = body.length;\n      body = body.toString('base64');\n      isBase64 = true;\n    }\n\n    const headers: Headers = {};\n    for (const header of Object.keys(headersOption || {}))\n      headers[header.toLowerCase()] = String(headersOption![header]);\n    if (options.contentType)\n      headers['content-type'] = String(options.contentType);\n    else if (options.json)\n      headers['content-type'] = 'application/json';\n    else if (options.path)\n      headers['content-type'] = getMimeTypeForPath(options.path) || 'application/octet-stream';\n    if (length && !('content-length' in headers))\n      headers['content-length'] = String(length);\n\n    await this._raceWithTargetClose(this._channel.fulfill({\n      status: statusOption || 200,\n      headers: headersObjectToArray(headers),\n      body,\n      isBase64,\n      fetchResponseUid\n    }));\n  }\n\n  async continue(options: FallbackOverrides = {}) {\n    await this._handleRoute(async () => {\n      this.request()._applyFallbackOverrides(options);\n      await this._innerContinue(false /* isFallback */);\n    });\n  }\n\n  _checkNotHandled() {\n    if (!this._handlingPromise)\n      throw new Error('Route is already handled!');\n  }\n\n  _reportHandled(done: boolean) {\n    const chain = this._handlingPromise!;\n    this._handlingPromise = null;\n    chain.resolve(done);\n  }\n\n  async _innerContinue(isFallback: boolean) {\n    const options = this.request()._fallbackOverridesForContinue();\n    return await this._raceWithTargetClose(this._channel.continue({\n      url: options.url,\n      method: options.method,\n      headers: options.headers ? headersObjectToArray(options.headers) : undefined,\n      postData: options.postDataBuffer,\n      isFallback,\n    }));\n  }\n}\n\nexport class WebSocketRoute extends ChannelOwner<channels.WebSocketRouteChannel> implements api.WebSocketRoute {\n  static from(route: channels.WebSocketRouteChannel): WebSocketRoute {\n    return (route as any)._object;\n  }\n\n  private _onPageMessage?: (message: string | Buffer) => any;\n  private _onPageClose?: (code: number | undefined, reason: string | undefined) => any;\n  private _onServerMessage?: (message: string | Buffer) => any;\n  private _onServerClose?: (code: number | undefined, reason: string | undefined) => any;\n  private _server: api.WebSocketRoute;\n  private _connected = false;\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WebSocketRouteInitializer) {\n    super(parent, type, guid, initializer);\n\n    this._server = {\n      onMessage: (handler: (message: string | Buffer) => any) => {\n        this._onServerMessage = handler;\n      },\n\n      onClose: (handler: (code: number | undefined, reason: string | undefined) => any) => {\n        this._onServerClose = handler;\n      },\n\n      connectToServer: () => {\n        throw new Error(`connectToServer must be called on the page-side WebSocketRoute`);\n      },\n\n      url: () => {\n        return this._initializer.url;\n      },\n\n      close: async (options: { code?: number, reason?: string } = {}) => {\n        await this._channel.closeServer({ ...options, wasClean: true }).catch(() => {});\n      },\n\n      send: (message: string | Buffer) => {\n        if (isString(message))\n          this._channel.sendToServer({ message, isBase64: false }).catch(() => {});\n        else\n          this._channel.sendToServer({ message: message.toString('base64'), isBase64: true }).catch(() => {});\n      },\n\n      async [Symbol.asyncDispose]() {\n        await this.close();\n      },\n    };\n\n    this._channel.on('messageFromPage', ({ message, isBase64 }) => {\n      if (this._onPageMessage)\n        this._onPageMessage(isBase64 ? Buffer.from(message, 'base64') : message);\n      else if (this._connected)\n        this._channel.sendToServer({ message, isBase64 }).catch(() => {});\n    });\n\n    this._channel.on('messageFromServer', ({ message, isBase64 }) => {\n      if (this._onServerMessage)\n        this._onServerMessage(isBase64 ? Buffer.from(message, 'base64') : message);\n      else\n        this._channel.sendToPage({ message, isBase64 }).catch(() => {});\n    });\n\n    this._channel.on('closePage', ({ code, reason, wasClean }) => {\n      if (this._onPageClose)\n        this._onPageClose(code, reason);\n      else\n        this._channel.closeServer({ code, reason, wasClean }).catch(() => {});\n    });\n\n    this._channel.on('closeServer', ({ code, reason, wasClean }) => {\n      if (this._onServerClose)\n        this._onServerClose(code, reason);\n      else\n        this._channel.closePage({ code, reason, wasClean }).catch(() => {});\n    });\n  }\n\n  url() {\n    return this._initializer.url;\n  }\n\n  async close(options: { code?: number, reason?: string } = {}) {\n    await this._channel.closePage({ ...options, wasClean: true }).catch(() => {});\n  }\n\n  connectToServer() {\n    if (this._connected)\n      throw new Error('Already connected to the server');\n    this._connected = true;\n    this._channel.connect().catch(() => {});\n    return this._server;\n  }\n\n  send(message: string | Buffer) {\n    if (isString(message))\n      this._channel.sendToPage({ message, isBase64: false }).catch(() => {});\n    else\n      this._channel.sendToPage({ message: message.toString('base64'), isBase64: true }).catch(() => {});\n  }\n\n  onMessage(handler: (message: string | Buffer) => any) {\n    this._onPageMessage = handler;\n  }\n\n  onClose(handler: (code: number | undefined, reason: string | undefined) => any) {\n    this._onPageClose = handler;\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n\n  async _afterHandle() {\n    if (this._connected)\n      return;\n    // Ensure that websocket is \"open\" and can send messages without an actual server connection.\n    // If this happens after the page has been closed, ignore the error.\n    await this._channel.ensureOpened().catch(() => {});\n  }\n}\n\nexport class WebSocketRouteHandler {\n  private readonly _baseURL: string | undefined;\n  readonly url: URLMatch;\n  readonly handler: WebSocketRouteHandlerCallback;\n\n  constructor(baseURL: string | undefined, url: URLMatch, handler: WebSocketRouteHandlerCallback) {\n    this._baseURL = baseURL;\n    this.url = url;\n    this.handler = handler;\n  }\n\n  static prepareInterceptionPatterns(handlers: WebSocketRouteHandler[]) {\n    const patterns: channels.BrowserContextSetWebSocketInterceptionPatternsParams['patterns'] = [];\n    let all = false;\n    for (const handler of handlers) {\n      if (isString(handler.url))\n        patterns.push({ glob: handler.url });\n      else if (isRegExp(handler.url))\n        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });\n      else\n        all = true;\n    }\n    if (all)\n      return [{ glob: '**/*' }];\n    return patterns;\n  }\n\n  public matches(wsURL: string): boolean {\n    return urlMatches(this._baseURL, wsURL, this.url, true);\n  }\n\n  public async handle(webSocketRoute: WebSocketRoute) {\n    const handler = this.handler;\n    await handler(webSocketRoute);\n    await webSocketRoute._afterHandle();\n  }\n}\n\nexport type RouteHandlerCallback = (route: Route, request: Request) => Promise<any> | void;\nexport type WebSocketRouteHandlerCallback = (ws: WebSocketRoute) => Promise<any> | void;\n\nexport type ResourceTiming = {\n  startTime: number;\n  domainLookupStart: number;\n  domainLookupEnd: number;\n  connectStart: number;\n  secureConnectionStart: number;\n  connectEnd: number;\n  requestStart: number;\n  responseStart: number;\n  responseEnd: number;\n};\n\nexport type RequestSizes = {\n  requestBodySize: number;\n  requestHeadersSize: number;\n  responseBodySize: number;\n  responseHeadersSize: number;\n};\n\nexport class Response extends ChannelOwner<channels.ResponseChannel> implements api.Response {\n  private _provisionalHeaders: RawHeaders;\n  private _actualHeadersPromise: Promise<RawHeaders> | undefined;\n  private _request: Request;\n  readonly _finishedPromise = new ManualPromise<null>();\n\n  static from(response: channels.ResponseChannel): Response {\n    return (response as any)._object;\n  }\n\n  static fromNullable(response: channels.ResponseChannel | undefined): Response | null {\n    return response ? Response.from(response) : null;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.ResponseInitializer) {\n    super(parent, type, guid, initializer);\n    this._provisionalHeaders = new RawHeaders(initializer.headers);\n    this._request = Request.from(this._initializer.request);\n    Object.assign(this._request._timing, this._initializer.timing);\n  }\n\n  url(): string {\n    return this._initializer.url;\n  }\n\n  ok(): boolean {\n    // Status 0 is for file:// URLs\n    return this._initializer.status === 0 || (this._initializer.status >= 200 && this._initializer.status <= 299);\n  }\n\n  status(): number {\n    return this._initializer.status;\n  }\n\n  statusText(): string {\n    return this._initializer.statusText;\n  }\n\n  fromServiceWorker(): boolean {\n    return this._initializer.fromServiceWorker;\n  }\n\n  /**\n   * @deprecated\n   */\n  headers(): Headers {\n    return this._provisionalHeaders.headers();\n  }\n\n  async _actualHeaders(): Promise<RawHeaders> {\n    if (!this._actualHeadersPromise) {\n      this._actualHeadersPromise = (async () => {\n        return new RawHeaders((await this._channel.rawResponseHeaders()).headers);\n      })();\n    }\n    return await this._actualHeadersPromise;\n  }\n\n  async allHeaders(): Promise<Headers> {\n    return (await this._actualHeaders()).headers();\n  }\n\n  async headersArray(): Promise<HeadersArray> {\n    return (await this._actualHeaders()).headersArray().slice();\n  }\n\n  async headerValue(name: string): Promise<string | null> {\n    return (await this._actualHeaders()).get(name);\n  }\n\n  async headerValues(name: string): Promise<string[]> {\n    return (await this._actualHeaders()).getAll(name);\n  }\n\n  async finished(): Promise<null> {\n    return await this.request()._targetClosedScope().race(this._finishedPromise);\n  }\n\n  async body(): Promise<Buffer> {\n    return (await this._channel.body()).binary;\n  }\n\n  async text(): Promise<string> {\n    const content = await this.body();\n    return content.toString('utf8');\n  }\n\n  async json(): Promise<object> {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  request(): Request {\n    return this._request;\n  }\n\n  frame(): Frame {\n    return this._request.frame();\n  }\n\n  async serverAddr(): Promise<RemoteAddr|null> {\n    return (await this._channel.serverAddr()).value || null;\n  }\n\n  async securityDetails(): Promise<SecurityDetails|null> {\n    return (await this._channel.securityDetails()).value || null;\n  }\n}\n\nexport class WebSocket extends ChannelOwner<channels.WebSocketChannel> implements api.WebSocket {\n  private _page: Page;\n  private _isClosed: boolean;\n\n  static from(webSocket: channels.WebSocketChannel): WebSocket {\n    return (webSocket as any)._object;\n  }\n\n  constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WebSocketInitializer) {\n    super(parent, type, guid, initializer);\n    this._isClosed = false;\n    this._page = parent as Page;\n    this._channel.on('frameSent', event => {\n      if (event.opcode === 1)\n        this.emit(Events.WebSocket.FrameSent, { payload: event.data });\n      else if (event.opcode === 2)\n        this.emit(Events.WebSocket.FrameSent, { payload: Buffer.from(event.data, 'base64') });\n    });\n    this._channel.on('frameReceived', event => {\n      if (event.opcode === 1)\n        this.emit(Events.WebSocket.FrameReceived, { payload: event.data });\n      else if (event.opcode === 2)\n        this.emit(Events.WebSocket.FrameReceived, { payload: Buffer.from(event.data, 'base64') });\n    });\n    this._channel.on('socketError', ({ error }) => this.emit(Events.WebSocket.Error, error));\n    this._channel.on('close', () => {\n      this._isClosed = true;\n      this.emit(Events.WebSocket.Close, this);\n    });\n  }\n\n  url(): string {\n    return this._initializer.url;\n  }\n\n  isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  async waitForEvent(event: string, optionsOrPredicate: WaitForEventOptions = {}): Promise<any> {\n    return await this._wrapApiCall(async () => {\n      const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);\n      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;\n      const waiter = Waiter.createForEvent(this, event);\n      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event \"${event}\"`);\n      if (event !== Events.WebSocket.Error)\n        waiter.rejectOnEvent(this, Events.WebSocket.Error, new Error('Socket error'));\n      if (event !== Events.WebSocket.Close)\n        waiter.rejectOnEvent(this, Events.WebSocket.Close, new Error('Socket closed'));\n      waiter.rejectOnEvent(this._page, Events.Page.Close, () => this._page._closeErrorWithReason());\n      const result = await waiter.waitForEvent(this, event, predicate as any);\n      waiter.dispose();\n      return result;\n    });\n  }\n}\n\nexport function validateHeaders(headers: Headers) {\n  for (const key of Object.keys(headers)) {\n    const value = headers[key];\n    if (!Object.is(value, undefined) && !isString(value))\n      throw new Error(`Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n  }\n}\n\nexport class RouteHandler {\n  private handledCount = 0;\n  private readonly _baseURL: string | undefined;\n  private readonly _times: number;\n  readonly url: URLMatch;\n  readonly handler: RouteHandlerCallback;\n  private _ignoreException: boolean = false;\n  private _activeInvocations: Set<{ complete: Promise<void>, route: Route }> = new Set();\n  private _savedZone: Zone;\n\n  constructor(platform: Platform, baseURL: string | undefined, url: URLMatch, handler: RouteHandlerCallback, times: number = Number.MAX_SAFE_INTEGER) {\n    this._baseURL = baseURL;\n    this._times = times;\n    this.url = url;\n    this.handler = handler;\n    this._savedZone = platform.zones.current().pop();\n  }\n\n  static prepareInterceptionPatterns(handlers: RouteHandler[]) {\n    const patterns: channels.BrowserContextSetNetworkInterceptionPatternsParams['patterns'] = [];\n    let all = false;\n    for (const handler of handlers) {\n      if (isString(handler.url))\n        patterns.push({ glob: handler.url });\n      else if (isRegExp(handler.url))\n        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });\n      else\n        all = true;\n    }\n    if (all)\n      return [{ glob: '**/*' }];\n    return patterns;\n  }\n\n  public matches(requestURL: string): boolean {\n    return urlMatches(this._baseURL, requestURL, this.url);\n  }\n\n  public async handle(route: Route): Promise<boolean> {\n    return await this._savedZone.run(async () => this._handleImpl(route));\n  }\n\n  private async _handleImpl(route: Route): Promise<boolean> {\n    const handlerInvocation = { complete: new ManualPromise(), route } ;\n    this._activeInvocations.add(handlerInvocation);\n    try {\n      return await this._handleInternal(route);\n    } catch (e) {\n      // If the handler was stopped (without waiting for completion), we ignore all exceptions.\n      if (this._ignoreException)\n        return false;\n      if (isTargetClosedError(e)) {\n        // We are failing in the handler because the target close closed.\n        // Give user a hint!\n        rewriteErrorMessage(e, `\"${e.message}\" while running route callback.\\nConsider awaiting \\`await page.unrouteAll({ behavior: 'ignoreErrors' })\\`\\nbefore the end of the test to ignore remaining routes in flight.`);\n      }\n      throw e;\n    } finally {\n      handlerInvocation.complete.resolve();\n      this._activeInvocations.delete(handlerInvocation);\n    }\n  }\n\n  async stop(behavior: 'wait' | 'ignoreErrors') {\n    // When a handler is manually unrouted or its page/context is closed we either\n    // - wait for the current handler invocations to finish\n    // - or do not wait, if the user opted out of it, but swallow all exceptions\n    //   that happen after the unroute/close.\n    if (behavior === 'ignoreErrors') {\n      this._ignoreException = true;\n    } else {\n      const promises = [];\n      for (const activation of this._activeInvocations) {\n        if (!activation.route._didThrow)\n          promises.push(activation.complete);\n      }\n      await Promise.all(promises);\n    }\n  }\n\n  private async _handleInternal(route: Route): Promise<boolean> {\n    ++this.handledCount;\n    const handledPromise = route._startHandling();\n    // Extract handler into a variable to avoid [RouteHandler.handler] in the stack.\n    const handler = this.handler;\n    const [handled] = await Promise.all([\n      handledPromise,\n      handler(route, route.request()),\n    ]);\n    return handled;\n  }\n\n  public willExpire(): boolean {\n    return this.handledCount + 1 >= this._times;\n  }\n}\n\nexport class RawHeaders {\n  private _headersArray: HeadersArray;\n  private _headersMap = new MultiMap<string, string>();\n\n  static _fromHeadersObjectLossy(headers: Headers): RawHeaders {\n    const headersArray: HeadersArray = Object.entries(headers).map(([name, value]) => ({\n      name, value\n    })).filter(header => header.value !== undefined);\n    return new RawHeaders(headersArray);\n  }\n\n  constructor(headers: HeadersArray) {\n    this._headersArray = headers;\n    for (const header of headers)\n      this._headersMap.set(header.name.toLowerCase(), header.value);\n  }\n\n  get(name: string): string | null {\n    const values = this.getAll(name);\n    if (!values || !values.length)\n      return null;\n    return values.join(name.toLowerCase() === 'set-cookie' ? '\\n' : ', ');\n  }\n\n  getAll(name: string): string[] {\n    return [...this._headersMap.get(name.toLowerCase())];\n  }\n\n  headers(): Headers {\n    const result: Headers = {};\n    for (const name of this._headersMap.keys())\n      result[name] = this.get(name)!;\n    return result;\n  }\n\n  headersArray(): HeadersArray {\n    return this._headersArray;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,0BAA6B;AAC7B,oBAAoC;AACpC,oBAAuB;AACvB,mBAA4B;AAC5B,mBAAsB;AACtB,oBAAuB;AACvB,oBAAuB;AACvB,oBAAuB;AACvB,qBAAqC;AACrC,sBAA2B;AAC3B,2BAAiD;AACjD,sBAAyB;AACzB,kBAAmC;AACnC,wBAAoC;AACpC,sBAAmC;AAuD5B,MAAM,gBAAgB,iCAA6D;AAAA,EAiBxF,YAAY,QAAsB,MAAc,MAAc,aAA0C;AACtG,UAAM,QAAQ,MAAM,MAAM,WAAW;AAjBvC,SAAQ,kBAAkC;AAC1C,SAAQ,gBAAgC;AACxC,wBAA8B;AAI9B,SAAQ,qBAAkD,CAAC;AAYzD,SAAK,kBAAkB,QAAQ,aAAa,YAAY,cAAc;AACtE,QAAI,KAAK;AACP,WAAK,gBAAgB,gBAAgB;AACvC,SAAK,sBAAsB,IAAI,WAAW,YAAY,OAAO;AAC7D,SAAK,UAAU;AAAA,MACb,WAAW;AAAA,MACX,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,uBAAuB;AAAA,MACvB,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,eAAe;AAAA,MACf,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EAzBA,OAAO,KAAK,SAA2C;AACrD,WAAQ,QAAgB;AAAA,EAC1B;AAAA,EAEA,OAAO,aAAa,SAA8D;AAChF,WAAO,UAAU,QAAQ,KAAK,OAAO,IAAI;AAAA,EAC3C;AAAA,EAqBA,MAAc;AACZ,WAAO,KAAK,mBAAmB,OAAO,KAAK,aAAa;AAAA,EAC1D;AAAA,EAEA,eAAuB;AACrB,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,SAAiB;AACf,WAAO,KAAK,mBAAmB,UAAU,KAAK,aAAa;AAAA,EAC7D;AAAA,EAEA,WAA0B;AACxB,YAAQ,KAAK,mBAAmB,kBAAkB,KAAK,aAAa,WAAW,SAAS,OAAO,KAAK;AAAA,EACtG;AAAA,EAEA,iBAAgC;AAC9B,WAAO,KAAK,mBAAmB,kBAAkB,KAAK,aAAa,YAAY;AAAA,EACjF;AAAA,EAEA,eAA8B;AAC5B,UAAM,WAAW,KAAK,SAAS;AAC/B,QAAI,CAAC;AACH,aAAO;AAET,UAAM,cAAc,KAAK,QAAQ,EAAE,cAAc;AACjD,QAAI,aAAa,SAAS,mCAAmC,GAAG;AAC9D,YAAM,UAAkC,CAAC;AACzC,YAAM,SAAS,IAAI,gBAAgB,QAAQ;AAC3C,iBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ;AAClC,gBAAQ,CAAC,IAAI;AACf,aAAO;AAAA,IACT;AAEA,QAAI;AACF,aAAO,KAAK,MAAM,QAAQ;AAAA,IAC5B,SAAS,GAAG;AACV,YAAM,IAAI,MAAM,2CAA2C,QAAQ;AAAA,IACrE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,UAAmB;AACjB,QAAI,KAAK,mBAAmB;AAC1B,aAAO,WAAW,wBAAwB,KAAK,mBAAmB,OAAO,EAAE,QAAQ;AACrF,WAAO,KAAK,oBAAoB,QAAQ;AAAA,EAC1C;AAAA,EAEA,MAAM,iBAAsC;AAC1C,QAAI,KAAK,mBAAmB;AAC1B,aAAO,WAAW,wBAAwB,KAAK,mBAAmB,OAAO;AAE3E,QAAI,CAAC,KAAK,uBAAuB;AAC/B,WAAK,wBAAwB,KAAK,aAAa,YAAY;AACzD,eAAO,IAAI,YAAY,MAAM,KAAK,SAAS,kBAAkB,GAAG,OAAO;AAAA,MACzE,GAAG,EAAE,UAAU,KAAK,CAAC;AAAA,IACvB;AACA,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA,EAEA,MAAM,aAA+B;AACnC,YAAQ,MAAM,KAAK,eAAe,GAAG,QAAQ;AAAA,EAC/C;AAAA,EAEA,MAAM,eAAsC;AAC1C,YAAQ,MAAM,KAAK,eAAe,GAAG,aAAa;AAAA,EACpD;AAAA,EAEA,MAAM,YAAY,MAAsC;AACtD,YAAQ,MAAM,KAAK,eAAe,GAAG,IAAI,IAAI;AAAA,EAC/C;AAAA,EAEA,MAAM,WAAqC;AACzC,WAAO,SAAS,cAAc,MAAM,KAAK,SAAS,SAAS,GAAG,QAAQ;AAAA,EACxE;AAAA,EAEA,MAAM,oBAA8C;AAClD,WAAO,SAAS,cAAc,MAAM,KAAK,SAAS,SAAS,GAAG,QAAQ;AAAA,EACxE;AAAA,EAEA,QAAe;AACb,QAAI,CAAC,KAAK,aAAa,OAAO;AAC5B,gCAAO,KAAK,cAAc,CAAC;AAC3B,YAAM,IAAI,MAAM,0DAA0D;AAAA,IAC5E;AACA,UAAM,QAAQ,mBAAM,KAAK,KAAK,aAAa,KAAK;AAChD,QAAI,CAAC,MAAM,OAAO;AAChB,YAAM,IAAI,MAAM;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE,KAAK,IAAI,CAAC;AAAA,IACd;AACA,WAAO;AAAA,EACT;AAAA,EAEA,YAAyB;AACvB,WAAO,mBAAM,aAAa,KAAK,aAAa,KAAK,GAAG,SAAS;AAAA,EAC/D;AAAA,EAEA,gBAA+B;AAC7B,WAAO,KAAK,aAAa,gBAAgB,qBAAO,KAAK,KAAK,aAAa,aAAa,IAAI;AAAA,EAC1F;AAAA,EAEA,sBAA+B;AAC7B,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,iBAAiC;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,eAA+B;AAC7B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,UAAyC;AACvC,QAAI,KAAK,iBAAiB;AACxB,aAAO;AACT,WAAO;AAAA,MACL,WAAW,KAAK;AAAA,IAClB;AAAA,EACF;AAAA,EAEA,SAAyB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,QAA+B;AACnC,UAAM,WAAW,MAAM,KAAK,SAAS;AACrC,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,0CAA0C;AAC5D,YAAQ,MAAM,SAAS,SAAS,MAAM,GAAG;AAAA,EAC3C;AAAA,EAEA,sBAAsB,mBAA2B;AAC/C,SAAK,QAAQ,cAAc;AAC3B,QAAI,KAAK,QAAQ,kBAAkB;AACjC,WAAK,QAAQ,gBAAgB;AAAA,EACjC;AAAA,EAEA,gBAAyB;AACvB,WAAO,KAAK,gBAAgB,KAAK,cAAc,cAAc,IAAI;AAAA,EACnE;AAAA,EAEA,wBAAwB,WAA8B;AACpD,QAAI,UAAU;AACZ,WAAK,mBAAmB,MAAM,UAAU;AAC1C,QAAI,UAAU;AACZ,WAAK,mBAAmB,SAAS,UAAU;AAC7C,QAAI,UAAU;AACZ,WAAK,mBAAmB,UAAU,UAAU;AAE9C,YAAI,sBAAS,UAAU,QAAQ;AAC7B,WAAK,mBAAmB,iBAAiB,OAAO,KAAK,UAAU,UAAU,OAAO;AAAA,aACzE,UAAU,oBAAoB;AACrC,WAAK,mBAAmB,iBAAiB,UAAU;AAAA,aAC5C,UAAU;AACjB,WAAK,mBAAmB,iBAAiB,OAAO,KAAK,KAAK,UAAU,UAAU,QAAQ,GAAG,OAAO;AAAA,EACpG;AAAA,EAEA,gCAAgC;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,qBAAwC;AACtC,WAAO,KAAK,cAAc,GAAG,gBAAgB,KAAK,UAAU,GAAG,yBAAyB,IAAI,uCAAkB;AAAA,EAChH;AACF;AAEO,MAAM,cAAc,iCAAyD;AAAA,EASlF,YAAY,QAAsB,MAAc,MAAc,aAAwC;AACpG,UAAM,QAAQ,MAAM,MAAM,WAAW;AATvC,SAAQ,mBAAkD;AAE1D,qBAAqB;AAAA,EAQrB;AAAA,EANA,OAAO,KAAK,OAAqC;AAC/C,WAAQ,MAAc;AAAA,EACxB;AAAA,EAMA,UAAmB;AACjB,WAAO,QAAQ,KAAK,KAAK,aAAa,OAAO;AAAA,EAC/C;AAAA,EAEA,MAAc,qBAAqB,SAAsC;AAIvE,WAAO,MAAM,KAAK,QAAQ,EAAE,mBAAmB,EAAE,SAAS,OAAO;AAAA,EACnE;AAAA,EAEA,MAAM,iBAAmC;AACvC,SAAK,mBAAmB,IAAI,mCAAc;AAC1C,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA,EAEA,MAAM,SAAS,UAA6B,CAAC,GAAG;AAC9C,SAAK,iBAAiB;AACtB,SAAK,QAAQ,EAAE,wBAAwB,OAAO;AAC9C,SAAK,eAAe,KAAK;AAAA,EAC3B;AAAA,EAEA,MAAM,MAAM,WAAoB;AAC9B,UAAM,KAAK,aAAa,YAAY;AAClC,YAAM,KAAK,qBAAqB,KAAK,SAAS,MAAM,EAAE,UAAU,CAAC,CAAC;AAAA,IACpE,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,2BAA2B,KAAa;AAC5C,UAAM,KAAK,aAAa,YAAY;AAClC,YAAM,KAAK,qBAAqB,KAAK,SAAS,0BAA0B,EAAE,IAAI,CAAC,CAAC;AAAA,IAClF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,MAAM,UAAgG,CAAC,GAAyB;AACpI,WAAO,MAAM,KAAK,aAAa,YAAY;AACzC,aAAO,MAAM,KAAK,SAAS,QAAQ,YAAY,EAAE,SAAS,KAAK,QAAQ,GAAG,MAAM,QAAQ,UAAU,GAAG,QAAQ,CAAC;AAAA,IAChH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ,UAAuJ,CAAC,GAAG;AACvK,UAAM,KAAK,aAAa,YAAY;AAClC,YAAM,KAAK,cAAc,OAAO;AAAA,IAClC,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,aAAa,UAA+B;AACxD,SAAK,iBAAiB;AACtB,QAAI;AACF,YAAM,SAAS;AACf,WAAK,eAAe,IAAI;AAAA,IAC1B,SAAS,GAAG;AACV,WAAK,YAAY;AACjB,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,cAAc,UAAuJ,CAAC,GAAkB;AACpM,QAAI;AACJ,QAAI,EAAE,QAAQ,cAAc,SAAS,eAAe,KAAK,IAAI;AAE7D,QAAI,QAAQ,SAAS,QAAW;AAC9B,gCAAO,QAAQ,SAAS,QAAW,4CAA4C;AAC/E,aAAO,KAAK,UAAU,QAAQ,IAAI;AAAA,IACpC;AAEA,QAAI,QAAQ,oBAAoB,0BAAa;AAC3C,uBAAiB,QAAQ,SAAS,OAAO;AACzC,wBAAkB,QAAQ,SAAS,QAAQ;AAC3C,UAAI,SAAS,UAAa,QAAQ,SAAS,QAAW;AACpD,YAAI,QAAQ,SAAS,SAAS,gBAAgB,KAAK;AACjD,6BAAoB,QAAQ,SAAyB,UAAU;AAAA;AAE/D,iBAAO,MAAM,QAAQ,SAAS,KAAK;AAAA,MACvC;AAAA,IACF;AAEA,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,QAAQ,MAAM;AAChB,YAAM,SAAS,MAAM,KAAK,UAAU,GAAG,EAAE,SAAS,SAAS,QAAQ,IAAI;AACvE,aAAO,OAAO,SAAS,QAAQ;AAC/B,iBAAW;AACX,eAAS,OAAO;AAAA,IAClB,eAAW,sBAAS,IAAI,GAAG;AACzB,iBAAW;AACX,eAAS,OAAO,WAAW,IAAI;AAAA,IACjC,WAAW,MAAM;AACf,eAAS,KAAK;AACd,aAAO,KAAK,SAAS,QAAQ;AAC7B,iBAAW;AAAA,IACb;AAEA,UAAM,UAAmB,CAAC;AAC1B,eAAW,UAAU,OAAO,KAAK,iBAAiB,CAAC,CAAC;AAClD,cAAQ,OAAO,YAAY,CAAC,IAAI,OAAO,cAAe,MAAM,CAAC;AAC/D,QAAI,QAAQ;AACV,cAAQ,cAAc,IAAI,OAAO,QAAQ,WAAW;AAAA,aAC7C,QAAQ;AACf,cAAQ,cAAc,IAAI;AAAA,aACnB,QAAQ;AACf,cAAQ,cAAc,QAAI,oCAAmB,QAAQ,IAAI,KAAK;AAChE,QAAI,UAAU,EAAE,oBAAoB;AAClC,cAAQ,gBAAgB,IAAI,OAAO,MAAM;AAE3C,UAAM,KAAK,qBAAqB,KAAK,SAAS,QAAQ;AAAA,MACpD,QAAQ,gBAAgB;AAAA,MACxB,aAAS,qCAAqB,OAAO;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EAEA,MAAM,SAAS,UAA6B,CAAC,GAAG;AAC9C,UAAM,KAAK,aAAa,YAAY;AAClC,WAAK,QAAQ,EAAE,wBAAwB,OAAO;AAC9C,YAAM,KAAK;AAAA,QAAe;AAAA;AAAA,MAAsB;AAAA,IAClD,CAAC;AAAA,EACH;AAAA,EAEA,mBAAmB;AACjB,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,2BAA2B;AAAA,EAC/C;AAAA,EAEA,eAAe,MAAe;AAC5B,UAAM,QAAQ,KAAK;AACnB,SAAK,mBAAmB;AACxB,UAAM,QAAQ,IAAI;AAAA,EACpB;AAAA,EAEA,MAAM,eAAe,YAAqB;AACxC,UAAM,UAAU,KAAK,QAAQ,EAAE,8BAA8B;AAC7D,WAAO,MAAM,KAAK,qBAAqB,KAAK,SAAS,SAAS;AAAA,MAC5D,KAAK,QAAQ;AAAA,MACb,QAAQ,QAAQ;AAAA,MAChB,SAAS,QAAQ,cAAU,qCAAqB,QAAQ,OAAO,IAAI;AAAA,MACnE,UAAU,QAAQ;AAAA,MAClB;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AACF;AAEO,MAAM,uBAAuB,iCAA2E;AAAA,EAY7G,YAAY,QAAsB,MAAc,MAAc,aAAiD;AAC7G,UAAM,QAAQ,MAAM,MAAM,WAAW;AAHvC,SAAQ,aAAa;AAKnB,SAAK,UAAU;AAAA,MACb,WAAW,CAAC,YAA+C;AACzD,aAAK,mBAAmB;AAAA,MAC1B;AAAA,MAEA,SAAS,CAAC,YAA2E;AACnF,aAAK,iBAAiB;AAAA,MACxB;AAAA,MAEA,iBAAiB,MAAM;AACrB,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF;AAAA,MAEA,KAAK,MAAM;AACT,eAAO,KAAK,aAAa;AAAA,MAC3B;AAAA,MAEA,OAAO,OAAO,UAA8C,CAAC,MAAM;AACjE,cAAM,KAAK,SAAS,YAAY,EAAE,GAAG,SAAS,UAAU,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,MAChF;AAAA,MAEA,MAAM,CAAC,YAA6B;AAClC,gBAAI,sBAAS,OAAO;AAClB,eAAK,SAAS,aAAa,EAAE,SAAS,UAAU,MAAM,CAAC,EAAE,MAAM,MAAM;AAAA,UAAC,CAAC;AAAA;AAEvE,eAAK,SAAS,aAAa,EAAE,SAAS,QAAQ,SAAS,QAAQ,GAAG,UAAU,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,UAAC,CAAC;AAAA,MACtG;AAAA,MAEA,OAAO,OAAO,YAAY,IAAI;AAC5B,cAAM,KAAK,MAAM;AAAA,MACnB;AAAA,IACF;AAEA,SAAK,SAAS,GAAG,mBAAmB,CAAC,EAAE,SAAS,SAAS,MAAM;AAC7D,UAAI,KAAK;AACP,aAAK,eAAe,WAAW,OAAO,KAAK,SAAS,QAAQ,IAAI,OAAO;AAAA,eAChE,KAAK;AACZ,aAAK,SAAS,aAAa,EAAE,SAAS,SAAS,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,IACpE,CAAC;AAED,SAAK,SAAS,GAAG,qBAAqB,CAAC,EAAE,SAAS,SAAS,MAAM;AAC/D,UAAI,KAAK;AACP,aAAK,iBAAiB,WAAW,OAAO,KAAK,SAAS,QAAQ,IAAI,OAAO;AAAA;AAEzE,aAAK,SAAS,WAAW,EAAE,SAAS,SAAS,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,IAClE,CAAC;AAED,SAAK,SAAS,GAAG,aAAa,CAAC,EAAE,MAAM,QAAQ,SAAS,MAAM;AAC5D,UAAI,KAAK;AACP,aAAK,aAAa,MAAM,MAAM;AAAA;AAE9B,aAAK,SAAS,YAAY,EAAE,MAAM,QAAQ,SAAS,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,IACxE,CAAC;AAED,SAAK,SAAS,GAAG,eAAe,CAAC,EAAE,MAAM,QAAQ,SAAS,MAAM;AAC9D,UAAI,KAAK;AACP,aAAK,eAAe,MAAM,MAAM;AAAA;AAEhC,aAAK,SAAS,UAAU,EAAE,MAAM,QAAQ,SAAS,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,IACtE,CAAC;AAAA,EACH;AAAA,EA1EA,OAAO,KAAK,OAAuD;AACjE,WAAQ,MAAc;AAAA,EACxB;AAAA,EA0EA,MAAM;AACJ,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,MAAM,MAAM,UAA8C,CAAC,GAAG;AAC5D,UAAM,KAAK,SAAS,UAAU,EAAE,GAAG,SAAS,UAAU,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EAC9E;AAAA,EAEA,kBAAkB;AAChB,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,iCAAiC;AACnD,SAAK,aAAa;AAClB,SAAK,SAAS,QAAQ,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,KAAK,SAA0B;AAC7B,YAAI,sBAAS,OAAO;AAClB,WAAK,SAAS,WAAW,EAAE,SAAS,UAAU,MAAM,CAAC,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA;AAErE,WAAK,SAAS,WAAW,EAAE,SAAS,QAAQ,SAAS,QAAQ,GAAG,UAAU,KAAK,CAAC,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAAA,EACpG;AAAA,EAEA,UAAU,SAA4C;AACpD,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,QAAQ,SAAwE;AAC9E,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,OAAO,OAAO,YAAY,IAAI;AAC5B,UAAM,KAAK,MAAM;AAAA,EACnB;AAAA,EAEA,MAAM,eAAe;AACnB,QAAI,KAAK;AACP;AAGF,UAAM,KAAK,SAAS,aAAa,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EACnD;AACF;AAEO,MAAM,sBAAsB;AAAA,EAKjC,YAAY,SAA6B,KAAe,SAAwC;AAC9F,SAAK,WAAW;AAChB,SAAK,MAAM;AACX,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,OAAO,4BAA4B,UAAmC;AACpE,UAAM,WAAsF,CAAC;AAC7F,QAAI,MAAM;AACV,eAAW,WAAW,UAAU;AAC9B,cAAI,sBAAS,QAAQ,GAAG;AACtB,iBAAS,KAAK,EAAE,MAAM,QAAQ,IAAI,CAAC;AAAA,mBAC5B,sBAAS,QAAQ,GAAG;AAC3B,iBAAS,KAAK,EAAE,aAAa,QAAQ,IAAI,QAAQ,YAAY,QAAQ,IAAI,MAAM,CAAC;AAAA;AAEhF,cAAM;AAAA,IACV;AACA,QAAI;AACF,aAAO,CAAC,EAAE,MAAM,OAAO,CAAC;AAC1B,WAAO;AAAA,EACT;AAAA,EAEO,QAAQ,OAAwB;AACrC,eAAO,4BAAW,KAAK,UAAU,OAAO,KAAK,KAAK,IAAI;AAAA,EACxD;AAAA,EAEA,MAAa,OAAO,gBAAgC;AAClD,UAAM,UAAU,KAAK;AACrB,UAAM,QAAQ,cAAc;AAC5B,UAAM,eAAe,aAAa;AAAA,EACpC;AACF;AAwBO,MAAM,iBAAiB,iCAA+D;AAAA,EAc3F,YAAY,QAAsB,MAAc,MAAc,aAA2C;AACvG,UAAM,QAAQ,MAAM,MAAM,WAAW;AAXvC,SAAS,mBAAmB,IAAI,mCAAoB;AAYlD,SAAK,sBAAsB,IAAI,WAAW,YAAY,OAAO;AAC7D,SAAK,WAAW,QAAQ,KAAK,KAAK,aAAa,OAAO;AACtD,WAAO,OAAO,KAAK,SAAS,SAAS,KAAK,aAAa,MAAM;AAAA,EAC/D;AAAA,EAbA,OAAO,KAAK,UAA8C;AACxD,WAAQ,SAAiB;AAAA,EAC3B;AAAA,EAEA,OAAO,aAAa,UAAiE;AACnF,WAAO,WAAW,SAAS,KAAK,QAAQ,IAAI;AAAA,EAC9C;AAAA,EASA,MAAc;AACZ,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,KAAc;AAEZ,WAAO,KAAK,aAAa,WAAW,KAAM,KAAK,aAAa,UAAU,OAAO,KAAK,aAAa,UAAU;AAAA,EAC3G;AAAA,EAEA,SAAiB;AACf,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,aAAqB;AACnB,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,oBAA6B;AAC3B,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,UAAmB;AACjB,WAAO,KAAK,oBAAoB,QAAQ;AAAA,EAC1C;AAAA,EAEA,MAAM,iBAAsC;AAC1C,QAAI,CAAC,KAAK,uBAAuB;AAC/B,WAAK,yBAAyB,YAAY;AACxC,eAAO,IAAI,YAAY,MAAM,KAAK,SAAS,mBAAmB,GAAG,OAAO;AAAA,MAC1E,GAAG;AAAA,IACL;AACA,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA,EAEA,MAAM,aAA+B;AACnC,YAAQ,MAAM,KAAK,eAAe,GAAG,QAAQ;AAAA,EAC/C;AAAA,EAEA,MAAM,eAAsC;AAC1C,YAAQ,MAAM,KAAK,eAAe,GAAG,aAAa,EAAE,MAAM;AAAA,EAC5D;AAAA,EAEA,MAAM,YAAY,MAAsC;AACtD,YAAQ,MAAM,KAAK,eAAe,GAAG,IAAI,IAAI;AAAA,EAC/C;AAAA,EAEA,MAAM,aAAa,MAAiC;AAClD,YAAQ,MAAM,KAAK,eAAe,GAAG,OAAO,IAAI;AAAA,EAClD;AAAA,EAEA,MAAM,WAA0B;AAC9B,WAAO,MAAM,KAAK,QAAQ,EAAE,mBAAmB,EAAE,KAAK,KAAK,gBAAgB;AAAA,EAC7E;AAAA,EAEA,MAAM,OAAwB;AAC5B,YAAQ,MAAM,KAAK,SAAS,KAAK,GAAG;AAAA,EACtC;AAAA,EAEA,MAAM,OAAwB;AAC5B,UAAM,UAAU,MAAM,KAAK,KAAK;AAChC,WAAO,QAAQ,SAAS,MAAM;AAAA,EAChC;AAAA,EAEA,MAAM,OAAwB;AAC5B,UAAM,UAAU,MAAM,KAAK,KAAK;AAChC,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B;AAAA,EAEA,UAAmB;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,QAAe;AACb,WAAO,KAAK,SAAS,MAAM;AAAA,EAC7B;AAAA,EAEA,MAAM,aAAuC;AAC3C,YAAQ,MAAM,KAAK,SAAS,WAAW,GAAG,SAAS;AAAA,EACrD;AAAA,EAEA,MAAM,kBAAiD;AACrD,YAAQ,MAAM,KAAK,SAAS,gBAAgB,GAAG,SAAS;AAAA,EAC1D;AACF;AAEO,MAAM,kBAAkB,iCAAiE;AAAA,EAI9F,OAAO,KAAK,WAAiD;AAC3D,WAAQ,UAAkB;AAAA,EAC5B;AAAA,EAEA,YAAY,QAAsB,MAAc,MAAc,aAA4C;AACxG,UAAM,QAAQ,MAAM,MAAM,WAAW;AACrC,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,SAAS,GAAG,aAAa,WAAS;AACrC,UAAI,MAAM,WAAW;AACnB,aAAK,KAAK,qBAAO,UAAU,WAAW,EAAE,SAAS,MAAM,KAAK,CAAC;AAAA,eACtD,MAAM,WAAW;AACxB,aAAK,KAAK,qBAAO,UAAU,WAAW,EAAE,SAAS,OAAO,KAAK,MAAM,MAAM,QAAQ,EAAE,CAAC;AAAA,IACxF,CAAC;AACD,SAAK,SAAS,GAAG,iBAAiB,WAAS;AACzC,UAAI,MAAM,WAAW;AACnB,aAAK,KAAK,qBAAO,UAAU,eAAe,EAAE,SAAS,MAAM,KAAK,CAAC;AAAA,eAC1D,MAAM,WAAW;AACxB,aAAK,KAAK,qBAAO,UAAU,eAAe,EAAE,SAAS,OAAO,KAAK,MAAM,MAAM,QAAQ,EAAE,CAAC;AAAA,IAC5F,CAAC;AACD,SAAK,SAAS,GAAG,eAAe,CAAC,EAAE,MAAM,MAAM,KAAK,KAAK,qBAAO,UAAU,OAAO,KAAK,CAAC;AACvF,SAAK,SAAS,GAAG,SAAS,MAAM;AAC9B,WAAK,YAAY;AACjB,WAAK,KAAK,qBAAO,UAAU,OAAO,IAAI;AAAA,IACxC,CAAC;AAAA,EACH;AAAA,EAEA,MAAc;AACZ,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,WAAoB;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,aAAa,OAAe,qBAA0C,CAAC,GAAiB;AAC5F,WAAO,MAAM,KAAK,aAAa,YAAY;AACzC,YAAM,UAAU,KAAK,MAAM,iBAAiB,QAAQ,OAAO,uBAAuB,aAAa,CAAC,IAAI,kBAAkB;AACtH,YAAM,YAAY,OAAO,uBAAuB,aAAa,qBAAqB,mBAAmB;AACrG,YAAM,SAAS,qBAAO,eAAe,MAAM,KAAK;AAChD,aAAO,gBAAgB,SAAS,WAAW,OAAO,wCAAwC,KAAK,GAAG;AAClG,UAAI,UAAU,qBAAO,UAAU;AAC7B,eAAO,cAAc,MAAM,qBAAO,UAAU,OAAO,IAAI,MAAM,cAAc,CAAC;AAC9E,UAAI,UAAU,qBAAO,UAAU;AAC7B,eAAO,cAAc,MAAM,qBAAO,UAAU,OAAO,IAAI,MAAM,eAAe,CAAC;AAC/E,aAAO,cAAc,KAAK,OAAO,qBAAO,KAAK,OAAO,MAAM,KAAK,MAAM,sBAAsB,CAAC;AAC5F,YAAM,SAAS,MAAM,OAAO,aAAa,MAAM,OAAO,SAAgB;AACtE,aAAO,QAAQ;AACf,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACF;AAEO,SAAS,gBAAgB,SAAkB;AAChD,aAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,UAAM,QAAQ,QAAQ,GAAG;AACzB,QAAI,CAAC,OAAO,GAAG,OAAO,MAAS,KAAK,KAAC,sBAAS,KAAK;AACjD,YAAM,IAAI,MAAM,6BAA6B,GAAG,wBAAwB,OAAO,KAAK,aAAa;AAAA,EACrG;AACF;AAEO,MAAM,aAAa;AAAA,EAUxB,YAAY,UAAoB,SAA6B,KAAe,SAA+B,QAAgB,OAAO,kBAAkB;AATpJ,SAAQ,eAAe;AAKvB,SAAQ,mBAA4B;AACpC,SAAQ,qBAAqE,oBAAI,IAAI;AAInF,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,UAAU;AACf,SAAK,aAAa,SAAS,MAAM,QAAQ,EAAE,IAAI;AAAA,EACjD;AAAA,EAEA,OAAO,4BAA4B,UAA0B;AAC3D,UAAM,WAAoF,CAAC;AAC3F,QAAI,MAAM;AACV,eAAW,WAAW,UAAU;AAC9B,cAAI,sBAAS,QAAQ,GAAG;AACtB,iBAAS,KAAK,EAAE,MAAM,QAAQ,IAAI,CAAC;AAAA,mBAC5B,sBAAS,QAAQ,GAAG;AAC3B,iBAAS,KAAK,EAAE,aAAa,QAAQ,IAAI,QAAQ,YAAY,QAAQ,IAAI,MAAM,CAAC;AAAA;AAEhF,cAAM;AAAA,IACV;AACA,QAAI;AACF,aAAO,CAAC,EAAE,MAAM,OAAO,CAAC;AAC1B,WAAO;AAAA,EACT;AAAA,EAEO,QAAQ,YAA6B;AAC1C,eAAO,4BAAW,KAAK,UAAU,YAAY,KAAK,GAAG;AAAA,EACvD;AAAA,EAEA,MAAa,OAAO,OAAgC;AAClD,WAAO,MAAM,KAAK,WAAW,IAAI,YAAY,KAAK,YAAY,KAAK,CAAC;AAAA,EACtE;AAAA,EAEA,MAAc,YAAY,OAAgC;AACxD,UAAM,oBAAoB,EAAE,UAAU,IAAI,mCAAc,GAAG,MAAM;AACjE,SAAK,mBAAmB,IAAI,iBAAiB;AAC7C,QAAI;AACF,aAAO,MAAM,KAAK,gBAAgB,KAAK;AAAA,IACzC,SAAS,GAAG;AAEV,UAAI,KAAK;AACP,eAAO;AACT,cAAI,mCAAoB,CAAC,GAAG;AAG1B,mDAAoB,GAAG,IAAI,EAAE,OAAO;AAAA;AAAA,iEAA8K;AAAA,MACpN;AACA,YAAM;AAAA,IACR,UAAE;AACA,wBAAkB,SAAS,QAAQ;AACnC,WAAK,mBAAmB,OAAO,iBAAiB;AAAA,IAClD;AAAA,EACF;AAAA,EAEA,MAAM,KAAK,UAAmC;AAK5C,QAAI,aAAa,gBAAgB;AAC/B,WAAK,mBAAmB;AAAA,IAC1B,OAAO;AACL,YAAM,WAAW,CAAC;AAClB,iBAAW,cAAc,KAAK,oBAAoB;AAChD,YAAI,CAAC,WAAW,MAAM;AACpB,mBAAS,KAAK,WAAW,QAAQ;AAAA,MACrC;AACA,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC5B;AAAA,EACF;AAAA,EAEA,MAAc,gBAAgB,OAAgC;AAC5D,MAAE,KAAK;AACP,UAAM,iBAAiB,MAAM,eAAe;AAE5C,UAAM,UAAU,KAAK;AACrB,UAAM,CAAC,OAAO,IAAI,MAAM,QAAQ,IAAI;AAAA,MAClC;AAAA,MACA,QAAQ,OAAO,MAAM,QAAQ,CAAC;AAAA,IAChC,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEO,aAAsB;AAC3B,WAAO,KAAK,eAAe,KAAK,KAAK;AAAA,EACvC;AACF;AAEO,MAAM,WAAW;AAAA,EAWtB,YAAY,SAAuB;AATnC,SAAQ,cAAc,IAAI,yBAAyB;AAUjD,SAAK,gBAAgB;AACrB,eAAW,UAAU;AACnB,WAAK,YAAY,IAAI,OAAO,KAAK,YAAY,GAAG,OAAO,KAAK;AAAA,EAChE;AAAA,EAXA,OAAO,wBAAwB,SAA8B;AAC3D,UAAM,eAA6B,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,MAAM,KAAK,OAAO;AAAA,MACjF;AAAA,MAAM;AAAA,IACR,EAAE,EAAE,OAAO,YAAU,OAAO,UAAU,MAAS;AAC/C,WAAO,IAAI,WAAW,YAAY;AAAA,EACpC;AAAA,EAQA,IAAI,MAA6B;AAC/B,UAAM,SAAS,KAAK,OAAO,IAAI;AAC/B,QAAI,CAAC,UAAU,CAAC,OAAO;AACrB,aAAO;AACT,WAAO,OAAO,KAAK,KAAK,YAAY,MAAM,eAAe,OAAO,IAAI;AAAA,EACtE;AAAA,EAEA,OAAO,MAAwB;AAC7B,WAAO,CAAC,GAAG,KAAK,YAAY,IAAI,KAAK,YAAY,CAAC,CAAC;AAAA,EACrD;AAAA,EAEA,UAAmB;AACjB,UAAM,SAAkB,CAAC;AACzB,eAAW,QAAQ,KAAK,YAAY,KAAK;AACvC,aAAO,IAAI,IAAI,KAAK,IAAI,IAAI;AAC9B,WAAO;AAAA,EACT;AAAA,EAEA,eAA6B;AAC3B,WAAO,KAAK;AAAA,EACd;AACF;",
  "names": []
}

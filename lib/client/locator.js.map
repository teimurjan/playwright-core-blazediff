{
  "version": 3,
  "sources": ["../../src/client/locator.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ElementHandle } from './elementHandle';\nimport { asLocator } from '../utils/isomorphic/locatorGenerators';\nimport { getByAltTextSelector, getByLabelSelector, getByPlaceholderSelector, getByRoleSelector, getByTestIdSelector, getByTextSelector, getByTitleSelector } from '../utils/isomorphic/locatorUtils';\nimport { escapeForTextSelector } from '../utils/isomorphic/stringUtils';\nimport { isString } from '../utils/isomorphic/rtti';\nimport { monotonicTime } from '../utils/isomorphic/time';\n\nimport type { Frame } from './frame';\nimport type { FilePayload, FrameExpectParams, Rect, SelectOption, SelectOptionOptions, TimeoutOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type * as channels from '@protocol/channels';\n\n\nexport type LocatorOptions = {\n  hasText?: string | RegExp;\n  hasNotText?: string | RegExp;\n  has?: Locator;\n  hasNot?: Locator;\n  visible?: boolean;\n};\n\nexport class Locator implements api.Locator {\n  _frame: Frame;\n  _selector: string;\n\n  constructor(frame: Frame, selector: string, options?: LocatorOptions) {\n    this._frame = frame;\n    this._selector = selector;\n\n    if (options?.hasText)\n      this._selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\n\n    if (options?.hasNotText)\n      this._selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\n\n    if (options?.has) {\n      const locator = options.has;\n      if (locator._frame !== frame)\n        throw new Error(`Inner \"has\" locator must belong to the same frame.`);\n      this._selector += ` >> internal:has=` + JSON.stringify(locator._selector);\n    }\n\n    if (options?.hasNot) {\n      const locator = options.hasNot;\n      if (locator._frame !== frame)\n        throw new Error(`Inner \"hasNot\" locator must belong to the same frame.`);\n      this._selector += ` >> internal:has-not=` + JSON.stringify(locator._selector);\n    }\n\n    if (options?.visible !== undefined)\n      this._selector += ` >> visible=${options.visible ? 'true' : 'false'}`;\n\n    if (this._frame._platform.inspectCustom)\n      (this as any)[this._frame._platform.inspectCustom] = () => this._inspect();\n  }\n\n  private async _withElement<R>(task: (handle: ElementHandle<SVGElement | HTMLElement>, timeout?: number) => Promise<R>, options: { title: string, internal?: boolean, timeout?: number }): Promise<R> {\n    const timeout = this._frame._timeout({ timeout: options.timeout });\n    const deadline = timeout ? monotonicTime() + timeout : 0;\n\n    return await this._frame._wrapApiCall<R>(async () => {\n      const result = await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, state: 'attached', timeout });\n      const handle = ElementHandle.fromNullable(result.element) as ElementHandle<SVGElement | HTMLElement> | null;\n      if (!handle)\n        throw new Error(`Could not resolve ${this._selector} to DOM Element`);\n      try {\n        return await task(handle, deadline ? deadline - monotonicTime() : 0);\n      } finally {\n        await handle.dispose();\n      }\n    }, { title: options.title, internal: options.internal });\n  }\n\n  _equals(locator: Locator) {\n    return this._frame === locator._frame && this._selector === locator._selector;\n  }\n\n  page() {\n    return this._frame.page();\n  }\n\n  async boundingBox(options?: TimeoutOptions): Promise<Rect | null> {\n    return await this._withElement(h => h.boundingBox(), { title: 'Bounding box', timeout: options?.timeout });\n  }\n\n  async check(options: channels.ElementHandleCheckOptions & TimeoutOptions = {}) {\n    return await this._frame.check(this._selector, { strict: true, ...options });\n  }\n\n  async click(options: channels.ElementHandleClickOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.click(this._selector, { strict: true, ...options });\n  }\n\n  async dblclick(options: channels.ElementHandleDblclickOptions & TimeoutOptions = {}): Promise<void> {\n    await this._frame.dblclick(this._selector, { strict: true, ...options });\n  }\n\n  async dispatchEvent(type: string, eventInit: Object = {}, options?: TimeoutOptions) {\n    return await this._frame.dispatchEvent(this._selector, type, eventInit, { strict: true, ...options });\n  }\n\n  async dragTo(target: Locator, options: channels.FrameDragAndDropOptions & TimeoutOptions = {}) {\n    return await this._frame.dragAndDrop(this._selector, target._selector, {\n      strict: true,\n      ...options,\n    });\n  }\n\n  async evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<SVGElement | HTMLElement, Arg, R>, arg?: Arg, options?: TimeoutOptions): Promise<R> {\n    return await this._withElement(h => h.evaluate(pageFunction, arg), { title: 'Evaluate', timeout: options?.timeout });\n  }\n\n  async _evaluateFunction(functionDeclaration: string, options?: TimeoutOptions) {\n    return await this._withElement(h => h._evaluateFunction(functionDeclaration), { title: 'Evaluate', timeout: options?.timeout });\n  }\n\n  async evaluateAll<R, Arg>(pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R> {\n    return await this._frame.$$eval(this._selector, pageFunction, arg);\n  }\n\n  async evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<any, Arg, R>, arg?: Arg, options?: TimeoutOptions): Promise<structs.SmartHandle<R>> {\n    return await this._withElement(h => h.evaluateHandle(pageFunction, arg), { title: 'Evaluate', timeout: options?.timeout });\n  }\n\n  async fill(value: string, options: channels.ElementHandleFillOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.fill(this._selector, value, { strict: true, ...options });\n  }\n\n  async clear(options: channels.ElementHandleFillOptions = {}): Promise<void> {\n    await this._frame._wrapApiCall(() => this.fill('', options), { title: 'Clear' });\n  }\n\n  async _highlight() {\n    // VS Code extension uses this one, keep it for now.\n    return await this._frame._highlight(this._selector);\n  }\n\n  async highlight() {\n    return await this._frame._highlight(this._selector);\n  }\n\n  locator(selectorOrLocator: string | Locator, options?: Omit<LocatorOptions, 'visible'>): Locator {\n    if (isString(selectorOrLocator))\n      return new Locator(this._frame, this._selector + ' >> ' + selectorOrLocator, options);\n    if (selectorOrLocator._frame !== this._frame)\n      throw new Error(`Locators must belong to the same frame.`);\n    return new Locator(this._frame, this._selector + ' >> internal:chain=' + JSON.stringify(selectorOrLocator._selector), options);\n  }\n\n  getByTestId(testId: string | RegExp): Locator {\n    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));\n  }\n\n  getByAltText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByAltTextSelector(text, options));\n  }\n\n  getByLabel(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByLabelSelector(text, options));\n  }\n\n  getByPlaceholder(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByPlaceholderSelector(text, options));\n  }\n\n  getByText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTextSelector(text, options));\n  }\n\n  getByTitle(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTitleSelector(text, options));\n  }\n\n  getByRole(role: string, options: ByRoleOptions = {}): Locator {\n    return this.locator(getByRoleSelector(role, options));\n  }\n\n  frameLocator(selector: string): FrameLocator {\n    return new FrameLocator(this._frame, this._selector + ' >> ' + selector);\n  }\n\n  filter(options?: LocatorOptions): Locator {\n    return new Locator(this._frame, this._selector, options);\n  }\n\n  async elementHandle(options?: TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement>> {\n    return await this._frame.waitForSelector(this._selector, { strict: true, state: 'attached', ...options })!;\n  }\n\n  async elementHandles(): Promise<api.ElementHandle<SVGElement | HTMLElement>[]> {\n    return await this._frame.$$(this._selector);\n  }\n\n  contentFrame() {\n    return new FrameLocator(this._frame, this._selector);\n  }\n\n  describe(description: string) {\n    return new Locator(this._frame, this._selector + ' >> internal:describe=' + JSON.stringify(description));\n  }\n\n  first(): Locator {\n    return new Locator(this._frame, this._selector + ' >> nth=0');\n  }\n\n  last(): Locator {\n    return new Locator(this._frame, this._selector + ` >> nth=-1`);\n  }\n\n  nth(index: number): Locator {\n    return new Locator(this._frame, this._selector + ` >> nth=${index}`);\n  }\n\n  and(locator: Locator): Locator {\n    if (locator._frame !== this._frame)\n      throw new Error(`Locators must belong to the same frame.`);\n    return new Locator(this._frame, this._selector + ` >> internal:and=` + JSON.stringify(locator._selector));\n  }\n\n  or(locator: Locator): Locator {\n    if (locator._frame !== this._frame)\n      throw new Error(`Locators must belong to the same frame.`);\n    return new Locator(this._frame, this._selector + ` >> internal:or=` + JSON.stringify(locator._selector));\n  }\n\n  async focus(options?: TimeoutOptions): Promise<void> {\n    return await this._frame.focus(this._selector, { strict: true, ...options });\n  }\n\n  async blur(options?: TimeoutOptions): Promise<void> {\n    await this._frame._channel.blur({ selector: this._selector, strict: true, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  // options are only here for testing\n  async count(_options?: {}): Promise<number> {\n    return await this._frame._queryCount(this._selector, _options);\n  }\n\n  async _resolveSelector(): Promise<{ resolvedSelector: string }> {\n    return await this._frame._channel.resolveSelector({ selector: this._selector });\n  }\n\n  async getAttribute(name: string, options?: TimeoutOptions): Promise<string | null> {\n    return await this._frame.getAttribute(this._selector, name, { strict: true, ...options });\n  }\n\n  async hover(options: channels.ElementHandleHoverOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.hover(this._selector, { strict: true, ...options });\n  }\n\n  async innerHTML(options?: TimeoutOptions): Promise<string> {\n    return await this._frame.innerHTML(this._selector, { strict: true, ...options });\n  }\n\n  async innerText(options?: TimeoutOptions): Promise<string> {\n    return await this._frame.innerText(this._selector, { strict: true, ...options });\n  }\n\n  async inputValue(options?: TimeoutOptions): Promise<string> {\n    return await this._frame.inputValue(this._selector, { strict: true, ...options });\n  }\n\n  async isChecked(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isChecked(this._selector, { strict: true, ...options });\n  }\n\n  async isDisabled(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isDisabled(this._selector, { strict: true, ...options });\n  }\n\n  async isEditable(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isEditable(this._selector, { strict: true, ...options });\n  }\n\n  async isEnabled(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isEnabled(this._selector, { strict: true, ...options });\n  }\n\n  async isHidden(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isHidden(this._selector, { strict: true, ...options });\n  }\n\n  async isVisible(options?: TimeoutOptions): Promise<boolean> {\n    return await this._frame.isVisible(this._selector, { strict: true, ...options });\n  }\n\n  async press(key: string, options: channels.ElementHandlePressOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.press(this._selector, key, { strict: true, ...options });\n  }\n\n  async screenshot(options: Omit<channels.ElementHandleScreenshotOptions, 'mask'> & TimeoutOptions & { path?: string, mask?: api.Locator[] } = {}): Promise<Buffer> {\n    const mask = options.mask as Locator[] | undefined;\n    return await this._withElement((h, timeout) => h.screenshot({ ...options, mask, timeout }), { title: 'Screenshot', timeout: options.timeout });\n  }\n\n  async ariaSnapshot(options?: TimeoutOptions): Promise<string> {\n    const result = await this._frame._channel.ariaSnapshot({ ...options, selector: this._selector, timeout: this._frame._timeout(options) });\n    return result.snapshot;\n  }\n\n  async scrollIntoViewIfNeeded(options: channels.ElementHandleScrollIntoViewIfNeededOptions & TimeoutOptions = {}) {\n    return await this._withElement((h, timeout) => h.scrollIntoViewIfNeeded({ ...options, timeout }), { title: 'Scroll into view', timeout: options.timeout });\n  }\n\n  async selectOption(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options: SelectOptionOptions = {}): Promise<string[]> {\n    return await this._frame.selectOption(this._selector, values, { strict: true, ...options });\n  }\n\n  async selectText(options: channels.ElementHandleSelectTextOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._withElement((h, timeout) => h.selectText({ ...options, timeout }), { title: 'Select text', timeout: options.timeout });\n  }\n\n  async setChecked(checked: boolean, options?: channels.ElementHandleCheckOptions & TimeoutOptions) {\n    if (checked)\n      await this.check(options);\n    else\n      await this.uncheck(options);\n  }\n\n  async setInputFiles(files: string | FilePayload | string[] | FilePayload[], options: channels.ElementHandleSetInputFilesOptions & TimeoutOptions = {}) {\n    return await this._frame.setInputFiles(this._selector, files, { strict: true, ...options });\n  }\n\n  async tap(options: channels.ElementHandleTapOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.tap(this._selector, { strict: true, ...options });\n  }\n\n  async textContent(options?: TimeoutOptions): Promise<string | null> {\n    return await this._frame.textContent(this._selector, { strict: true, ...options });\n  }\n\n  async type(text: string, options: channels.ElementHandleTypeOptions & TimeoutOptions = {}): Promise<void> {\n    return await this._frame.type(this._selector, text, { strict: true, ...options });\n  }\n\n  async pressSequentially(text: string, options: channels.ElementHandleTypeOptions & TimeoutOptions = {}): Promise<void> {\n    return await this.type(text, options);\n  }\n\n  async uncheck(options: channels.ElementHandleUncheckOptions & TimeoutOptions = {}) {\n    return await this._frame.uncheck(this._selector, { strict: true, ...options });\n  }\n\n  async all(): Promise<Locator[]> {\n    return new Array(await this.count()).fill(0).map((e, i) => this.nth(i));\n  }\n\n  async allInnerTexts(): Promise<string[]> {\n    return await this._frame.$$eval(this._selector, ee => ee.map(e => (e as HTMLElement).innerText));\n  }\n\n  async allTextContents(): Promise<string[]> {\n    return await this._frame.$$eval(this._selector, ee => ee.map(e => e.textContent || ''));\n  }\n\n  waitFor(options: channels.FrameWaitForSelectorOptions & TimeoutOptions & { state: 'attached' | 'visible' }): Promise<void>;\n  waitFor(options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<void>;\n  async waitFor(options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<void> {\n    await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, omitReturnValue: true, ...options, timeout: this._frame._timeout(options) });\n  }\n\n  async _expect(expression: string, options: FrameExpectParams): Promise<{ matches: boolean, received?: any, log?: string[], timedOut?: boolean }> {\n    return this._frame._expect(expression, {\n      ...options,\n      selector: this._selector,\n    });\n  }\n\n  private _inspect() {\n    return this.toString();\n  }\n\n  toString() {\n    return asLocator('javascript', this._selector);\n  }\n}\n\nexport class FrameLocator implements api.FrameLocator {\n  private _frame: Frame;\n  private _frameSelector: string;\n\n  constructor(frame: Frame, selector: string) {\n    this._frame = frame;\n    this._frameSelector = selector;\n  }\n\n  locator(selectorOrLocator: string | Locator, options?: LocatorOptions): Locator {\n    if (isString(selectorOrLocator))\n      return new Locator(this._frame, this._frameSelector + ' >> internal:control=enter-frame >> ' + selectorOrLocator, options);\n    if (selectorOrLocator._frame !== this._frame)\n      throw new Error(`Locators must belong to the same frame.`);\n    return new Locator(this._frame, this._frameSelector + ' >> internal:control=enter-frame >> ' + selectorOrLocator._selector, options);\n  }\n\n  getByTestId(testId: string | RegExp): Locator {\n    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));\n  }\n\n  getByAltText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByAltTextSelector(text, options));\n  }\n\n  getByLabel(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByLabelSelector(text, options));\n  }\n\n  getByPlaceholder(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByPlaceholderSelector(text, options));\n  }\n\n  getByText(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTextSelector(text, options));\n  }\n\n  getByTitle(text: string | RegExp, options?: { exact?: boolean }): Locator {\n    return this.locator(getByTitleSelector(text, options));\n  }\n\n  getByRole(role: string, options: ByRoleOptions = {}): Locator {\n    return this.locator(getByRoleSelector(role, options));\n  }\n\n  owner() {\n    return new Locator(this._frame, this._frameSelector);\n  }\n\n  frameLocator(selector: string): FrameLocator {\n    return new FrameLocator(this._frame, this._frameSelector + ' >> internal:control=enter-frame >> ' + selector);\n  }\n\n  first(): FrameLocator {\n    return new FrameLocator(this._frame, this._frameSelector + ' >> nth=0');\n  }\n\n  last(): FrameLocator {\n    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);\n  }\n\n  nth(index: number): FrameLocator {\n    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);\n  }\n}\n\nlet _testIdAttributeName: string = 'data-testid';\n\nexport function testIdAttributeName(): string {\n  return _testIdAttributeName;\n}\n\nexport function setTestIdAttribute(attributeName: string) {\n  _testIdAttributeName = attributeName;\n}\n"],
  "mappings": "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",
  "names": []
}

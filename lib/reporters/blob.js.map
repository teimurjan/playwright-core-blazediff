{
  "version": 3,
  "sources": ["../../src/reporters/blob.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { Readable } from 'stream';\n\nimport { removeFolders, sanitizeForFilePath } from 'playwright-core/lib/utils';\nimport { ManualPromise, calculateSha1, createGuid, getUserAgent } from 'playwright-core/lib/utils';\nimport { mime } from 'playwright-core/lib/utilsBundle';\nimport { yazl } from 'playwright-core/lib/zipBundle';\n\nimport { resolveOutputFile, CommonReporterOptions } from './base';\nimport { TeleReporterEmitter } from './teleEmitter';\n\nimport type { BlobReporterOptions } from '../../types/test';\nimport type { FullConfig, FullResult, TestResult } from '../../types/testReporter';\nimport type { BlobReportMetadata, JsonAttachment, JsonEvent } from '../isomorphic/teleReceiver';\nimport type { EventEmitter } from 'events';\n\nexport const currentBlobReportVersion = 2;\n\nexport class BlobReporter extends TeleReporterEmitter {\n  private readonly _messages: JsonEvent[] = [];\n  private readonly _attachments: { originalPath: string, zipEntryPath: string }[] = [];\n  private readonly _options: BlobReporterOptions & CommonReporterOptions;\n  private readonly _salt: string;\n  private _config!: FullConfig;\n\n  constructor(options: BlobReporterOptions & CommonReporterOptions) {\n    super(message => this._messages.push(message));\n    this._options = options;\n    if (this._options.fileName && !this._options.fileName.endsWith('.zip'))\n      throw new Error(`Blob report file name must end with .zip extension: ${this._options.fileName}`);\n    this._salt = createGuid();\n  }\n\n  override onConfigure(config: FullConfig) {\n    const metadata: BlobReportMetadata = {\n      version: currentBlobReportVersion,\n      userAgent: getUserAgent(),\n      name: process.env.PWTEST_BOT_NAME,\n      shard: config.shard ?? undefined,\n      pathSeparator: path.sep,\n    };\n    this._messages.push({\n      method: 'onBlobReportMetadata',\n      params: metadata\n    });\n\n    this._config = config;\n    super.onConfigure(config);\n  }\n\n  override async onEnd(result: FullResult): Promise<void> {\n    await super.onEnd(result);\n\n    const zipFileName = await this._prepareOutputFile();\n\n    const zipFile = new yazl.ZipFile();\n    const zipFinishPromise = new ManualPromise<undefined>();\n    const finishPromise = zipFinishPromise.catch(e => {\n      throw new Error(`Failed to write report ${zipFileName}: ` + e.message);\n    });\n\n    (zipFile as any as EventEmitter).on('error', error => zipFinishPromise.reject(error));\n    zipFile.outputStream.pipe(fs.createWriteStream(zipFileName)).on('close', () => {\n      zipFinishPromise.resolve(undefined);\n    }).on('error', error => zipFinishPromise.reject(error));\n\n    for (const { originalPath, zipEntryPath } of this._attachments) {\n      if (!fs.statSync(originalPath, { throwIfNoEntry: false })?.isFile())\n        continue;\n      zipFile.addFile(originalPath, zipEntryPath);\n    }\n\n    const lines = this._messages.map(m => JSON.stringify(m) + '\\n');\n    const content = Readable.from(lines);\n    zipFile.addReadStream(content, 'report.jsonl');\n    zipFile.end();\n\n    await finishPromise;\n  }\n\n  private async _prepareOutputFile() {\n    const { outputFile, outputDir } = resolveOutputFile('BLOB', {\n      ...this._options,\n      default: {\n        fileName: this._defaultReportName(this._config),\n        outputDir: 'blob-report',\n      }\n    })!;\n    if (!process.env.PWTEST_BLOB_DO_NOT_REMOVE)\n      await removeFolders([outputDir!]);\n    await fs.promises.mkdir(path.dirname(outputFile), { recursive: true });\n    return outputFile;\n  }\n\n  private _defaultReportName(config: FullConfig) {\n    let reportName = 'report';\n    if (this._options._commandHash)\n      reportName += '-' + sanitizeForFilePath(this._options._commandHash);\n    if (config.shard) {\n      const paddedNumber = `${config.shard.current}`.padStart(`${config.shard.total}`.length, '0');\n      reportName = `${reportName}-${paddedNumber}`;\n    }\n    return `${reportName}.zip`;\n  }\n\n  override _serializeAttachments(attachments: TestResult['attachments']): JsonAttachment[] {\n    return super._serializeAttachments(attachments).map(attachment => {\n      if (!attachment.path)\n        return attachment;\n      // Add run guid to avoid clashes between shards.\n      const sha1 = calculateSha1(attachment.path + this._salt);\n      const extension = mime.getExtension(attachment.contentType) || 'dat';\n      const newPath = `resources/${sha1}.${extension}`;\n      this._attachments.push({ originalPath: attachment.path, zipEntryPath: newPath });\n      return {\n        ...attachment,\n        path: newPath,\n      };\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "path", "fs"]
}

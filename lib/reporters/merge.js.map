{
  "version": 3,
  "sources": ["../../src/reporters/merge.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { ZipFile } from 'playwright-core/lib/utils';\n\nimport {  currentBlobReportVersion } from './blob';\nimport { Multiplexer } from './multiplexer';\nimport { JsonStringInternalizer, StringInternPool } from '../isomorphic/stringInternPool';\nimport { TeleReporterReceiver } from '../isomorphic/teleReceiver';\nimport { createReporters } from '../runner/reporters';\nimport { relativeFilePath } from '../util';\n\nimport type { ReporterDescription, TestAnnotation } from '../../types/test';\nimport type { TestError } from '../../types/testReporter';\nimport type { FullConfigInternal } from '../common/config';\nimport type { BlobReportMetadata, JsonAttachment, JsonConfig, JsonEvent, JsonFullResult, JsonLocation, JsonOnConfigureEvent, JsonOnEndEvent, JsonOnProjectEvent, JsonProject, JsonSuite, JsonTestCase } from '../isomorphic/teleReceiver';\nimport type * as blobV1 from './versions/blobV1';\n\ntype StatusCallback = (message: string) => void;\n\ntype ReportData = {\n  eventPatchers: JsonEventPatchers;\n  reportFile: string;\n  metadata: BlobReportMetadata;\n};\n\nexport async function createMergedReport(config: FullConfigInternal, dir: string, reporterDescriptions: ReporterDescription[], rootDirOverride: string | undefined) {\n  const reporters = await createReporters(config, 'merge', false, reporterDescriptions);\n  const multiplexer = new Multiplexer(reporters);\n  const stringPool = new StringInternPool();\n\n  let printStatus: StatusCallback = () => {};\n  if (!multiplexer.printsToStdio()) {\n    printStatus = printStatusToStdout;\n    printStatus(`merging reports from ${dir}`);\n  }\n\n  const shardFiles = await sortedShardFiles(dir);\n  if (shardFiles.length === 0)\n    throw new Error(`No report files found in ${dir}`);\n  const eventData = await mergeEvents(dir, shardFiles, stringPool, printStatus, rootDirOverride);\n  // If explicit config is provided, use platform path separator, otherwise use the one from the report (if any).\n  const pathSeparator = rootDirOverride ? path.sep : (eventData.pathSeparatorFromMetadata ?? path.sep);\n  const receiver = new TeleReporterReceiver(multiplexer, {\n    mergeProjects: false,\n    mergeTestCases: false,\n    resolvePath: (rootDir, relativePath) => stringPool.internString(rootDir + pathSeparator + relativePath),\n    configOverrides: config.config,\n  });\n  printStatus(`processing test events`);\n\n  const dispatchEvents = async (events: JsonEvent[]) => {\n    for (const event of events) {\n      if (event.method === 'onEnd')\n        printStatus(`building final report`);\n      await receiver.dispatch(event);\n      if (event.method === 'onEnd')\n        printStatus(`finished building report`);\n    }\n  };\n\n  await dispatchEvents(eventData.prologue);\n  for (const { reportFile, eventPatchers, metadata } of eventData.reports) {\n    const reportJsonl = await fs.promises.readFile(reportFile);\n    const events = parseTestEvents(reportJsonl);\n    new JsonStringInternalizer(stringPool).traverse(events);\n    eventPatchers.patchers.push(new AttachmentPathPatcher(dir));\n    if (metadata.name)\n      eventPatchers.patchers.push(new GlobalErrorPatcher(metadata.name));\n    eventPatchers.patchEvents(events);\n    await dispatchEvents(events);\n  }\n  await dispatchEvents(eventData.epilogue);\n}\n\nconst commonEventNames = ['onBlobReportMetadata', 'onConfigure', 'onProject', 'onBegin', 'onEnd'];\nconst commonEvents = new Set(commonEventNames);\nconst commonEventRegex = new RegExp(`${commonEventNames.join('|')}`);\n\nfunction parseCommonEvents(reportJsonl: Buffer): JsonEvent[] {\n  return splitBufferLines(reportJsonl)\n      .map(line => line.toString('utf8'))\n      .filter(line => commonEventRegex.test(line)) // quick filter\n      .map(line => JSON.parse(line) as JsonEvent)\n      .filter(event => commonEvents.has(event.method));\n}\n\nfunction parseTestEvents(reportJsonl: Buffer): JsonEvent[] {\n  return splitBufferLines(reportJsonl)\n      .map(line => line.toString('utf8'))\n      .filter(line => line.length)\n      .map(line => JSON.parse(line) as JsonEvent)\n      .filter(event => !commonEvents.has(event.method));\n}\n\nfunction splitBufferLines(buffer: Buffer) {\n  const lines = [];\n  let start = 0;\n  while (start < buffer.length) {\n    // 0x0A is the byte for '\\n'\n    const end = buffer.indexOf(0x0A, start);\n    if (end === -1) {\n      lines.push(buffer.slice(start));\n      break;\n    }\n    lines.push(buffer.slice(start, end));\n    start = end + 1;\n  }\n  return lines;\n}\n\nasync function extractAndParseReports(dir: string, shardFiles: string[], internalizer: JsonStringInternalizer, printStatus: StatusCallback) {\n  const shardEvents: { file: string, localPath: string, metadata: BlobReportMetadata, parsedEvents: JsonEvent[] }[] = [];\n  await fs.promises.mkdir(path.join(dir, 'resources'), { recursive: true });\n\n  const reportNames = new UniqueFileNameGenerator();\n  for (const file of shardFiles) {\n    const absolutePath = path.join(dir, file);\n    printStatus(`extracting: ${relativeFilePath(absolutePath)}`);\n    const zipFile = new ZipFile(absolutePath);\n    const entryNames = await zipFile.entries();\n    for (const entryName of entryNames.sort()) {\n      let fileName = path.join(dir, entryName);\n      const content = await zipFile.read(entryName);\n      if (entryName.endsWith('.jsonl')) {\n        fileName = reportNames.makeUnique(fileName);\n        let parsedEvents = parseCommonEvents(content);\n        // Passing reviver to JSON.parse doesn't work, as the original strings\n        // keep being used. To work around that we traverse the parsed events\n        // as a post-processing step.\n        internalizer.traverse(parsedEvents);\n        const metadata = findMetadata(parsedEvents, file);\n        parsedEvents = modernizer.modernize(metadata.version, parsedEvents);\n        shardEvents.push({\n          file,\n          localPath: fileName,\n          metadata,\n          parsedEvents\n        });\n      }\n      await fs.promises.writeFile(fileName, content);\n    }\n    zipFile.close();\n  }\n  return shardEvents;\n}\n\nfunction findMetadata(events: JsonEvent[], file: string): BlobReportMetadata {\n  if (events[0]?.method !== 'onBlobReportMetadata')\n    throw new Error(`No metadata event found in ${file}`);\n  const metadata = events[0].params;\n  if (metadata.version > currentBlobReportVersion)\n    throw new Error(`Blob report ${file} was created with a newer version of Playwright.`);\n  return metadata;\n}\n\nasync function mergeEvents(dir: string, shardReportFiles: string[], stringPool: StringInternPool, printStatus: StatusCallback, rootDirOverride: string | undefined): Promise<{\n  prologue: JsonEvent[];\n  reports: ReportData[];\n  epilogue: JsonEvent[];\n  pathSeparatorFromMetadata?: string;\n}> {\n  const internalizer = new JsonStringInternalizer(stringPool);\n\n  const configureEvents: JsonOnConfigureEvent[] = [];\n  const projectEvents: JsonOnProjectEvent[] = [];\n  const endEvents: JsonOnEndEvent[] = [];\n\n  const blobs = await extractAndParseReports(dir, shardReportFiles, internalizer, printStatus);\n  // Sort by (report name; shard; file name), so that salt generation below is deterministic when:\n  // - report names are unique;\n  // - report names are missing;\n  // - report names are clashing between shards.\n  blobs.sort((a, b) => {\n    const nameA = a.metadata.name ?? '';\n    const nameB = b.metadata.name ?? '';\n    if (nameA !== nameB)\n      return nameA.localeCompare(nameB);\n    const shardA = a.metadata.shard?.current ?? 0;\n    const shardB = b.metadata.shard?.current ?? 0;\n    if (shardA !== shardB)\n      return shardA - shardB;\n    return a.file.localeCompare(b.file);\n  });\n\n  printStatus(`merging events`);\n\n  const reports: ReportData[] = [];\n  const globalTestIdSet = new Set<string>();\n\n  for (let i = 0; i < blobs.length; ++i) {\n    // Generate unique salt for each blob.\n    const { parsedEvents, metadata, localPath } = blobs[i];\n    const eventPatchers = new JsonEventPatchers();\n    eventPatchers.patchers.push(new IdsPatcher(\n        stringPool,\n        metadata.name,\n        String(i),\n        globalTestIdSet,\n    ));\n    // Only patch path separators if we are merging reports with explicit config.\n    if (rootDirOverride)\n      eventPatchers.patchers.push(new PathSeparatorPatcher(metadata.pathSeparator));\n    eventPatchers.patchEvents(parsedEvents);\n\n    for (const event of parsedEvents) {\n      if (event.method === 'onConfigure')\n        configureEvents.push(event);\n      else if (event.method === 'onProject')\n        projectEvents.push(event);\n      else if (event.method === 'onEnd')\n        endEvents.push(event);\n    }\n\n    // Save information about the reports to stream their test events later.\n    reports.push({\n      eventPatchers,\n      reportFile: localPath,\n      metadata,\n    });\n  }\n\n  return {\n    prologue: [\n      mergeConfigureEvents(configureEvents, rootDirOverride),\n      ...projectEvents,\n      { method: 'onBegin', params: undefined },\n    ],\n    reports,\n    epilogue: [\n      mergeEndEvents(endEvents),\n      { method: 'onExit', params: undefined },\n    ],\n    pathSeparatorFromMetadata: blobs[0]?.metadata.pathSeparator,\n  };\n}\n\nfunction mergeConfigureEvents(configureEvents: JsonOnConfigureEvent[], rootDirOverride: string | undefined): JsonEvent {\n  if (!configureEvents.length)\n    throw new Error('No configure events found');\n  let config: JsonConfig = {\n    configFile: undefined,\n    globalTimeout: 0,\n    maxFailures: 0,\n    metadata: {\n    },\n    rootDir: '',\n    version: '',\n    workers: 0,\n    globalSetup: null,\n    globalTeardown: null,\n  };\n  for (const event of configureEvents)\n    config = mergeConfigs(config, event.params.config);\n\n  if (rootDirOverride) {\n    config.rootDir = rootDirOverride;\n  } else {\n    const rootDirs = new Set(configureEvents.map(e => e.params.config.rootDir));\n    if (rootDirs.size > 1) {\n      throw new Error([\n        `Blob reports being merged were recorded with different test directories, and`,\n        `merging cannot proceed. This may happen if you are merging reports from`,\n        `machines with different environments, like different operating systems or`,\n        `if the tests ran with different playwright configs.`,\n        ``,\n        `You can force merge by specifying a merge config file with \"-c\" option. If`,\n        `you'd like all test paths to be correct, make sure 'testDir' in the merge config`,\n        `file points to the actual tests location.`,\n        ``,\n        `Found directories:`,\n        ...rootDirs\n      ].join('\\n'));\n    }\n  }\n\n  return {\n    method: 'onConfigure',\n    params: {\n      config,\n    }\n  };\n}\n\nfunction mergeConfigs(to: JsonConfig, from: JsonConfig): JsonConfig {\n  return {\n    ...to,\n    ...from,\n    metadata: {\n      ...to.metadata,\n      ...from.metadata,\n      actualWorkers: (to.metadata.actualWorkers || 0) + (from.metadata.actualWorkers || 0),\n    },\n    workers: to.workers + from.workers,\n  };\n}\n\nfunction mergeEndEvents(endEvents: JsonOnEndEvent[]): JsonEvent {\n  let startTime = endEvents.length ? 10000000000000 : Date.now();\n  let status: JsonFullResult['status'] = 'passed';\n  let duration: number = 0;\n\n  for (const event of endEvents) {\n    const shardResult = event.params.result;\n    if (shardResult.status === 'failed')\n      status = 'failed';\n    else if (shardResult.status === 'timedout' && status !== 'failed')\n      status = 'timedout';\n    else if (shardResult.status === 'interrupted' && status !== 'failed' && status !== 'timedout')\n      status = 'interrupted';\n    startTime = Math.min(startTime, shardResult.startTime);\n    duration = Math.max(duration, shardResult.duration);\n  }\n  const result: JsonFullResult = {\n    status,\n    startTime,\n    duration,\n  };\n  return {\n    method: 'onEnd',\n    params: {\n      result\n    }\n  };\n}\n\nasync function sortedShardFiles(dir: string) {\n  const files = await fs.promises.readdir(dir);\n  return files.filter(file => file.endsWith('.zip')).sort();\n}\n\nfunction printStatusToStdout(message: string) {\n  // eslint-disable-next-line no-restricted-properties\n  process.stdout.write(`${message}\\n`);\n}\n\nclass UniqueFileNameGenerator {\n  private _usedNames = new Set<string>();\n\n  makeUnique(name: string): string {\n    if (!this._usedNames.has(name)) {\n      this._usedNames.add(name);\n      return name;\n    }\n    const extension = path.extname(name);\n    name = name.substring(0, name.length - extension.length);\n    let index = 0;\n    while (true) {\n      const candidate = `${name}-${++index}${extension}`;\n      if (!this._usedNames.has(candidate)) {\n        this._usedNames.add(candidate);\n        return candidate;\n      }\n    }\n  }\n}\n\nclass IdsPatcher {\n  private _stringPool: StringInternPool;\n  private _botName: string | undefined;\n  private _salt: string;\n  private _testIdsMap: Map<string, string>;\n  private _globalTestIdSet: Set<string>;\n\n  constructor(\n    stringPool: StringInternPool,\n    botName: string | undefined,\n    salt: string,\n    globalTestIdSet: Set<string>,\n  ) {\n    this._stringPool = stringPool;\n    this._botName = botName;\n    this._salt = salt;\n    this._testIdsMap = new Map();\n    this._globalTestIdSet = globalTestIdSet;\n  }\n\n  patchEvent(event: JsonEvent) {\n    const { method, params } = event;\n    switch (method) {\n      case 'onProject':\n        this._onProject(params.project);\n        return;\n      case 'onAttach':\n      case 'onTestBegin':\n      case 'onStepBegin':\n      case 'onStepEnd':\n      case 'onStdIO':\n        params.testId = params.testId ? this._mapTestId(params.testId) : undefined;\n        return;\n      case 'onTestEnd':\n        params.test.testId = this._mapTestId(params.test.testId);\n        return;\n    }\n  }\n\n  private _onProject(project: JsonProject) {\n    project.metadata ??= {};\n    project.suites.forEach(suite => this._updateTestIds(suite));\n  }\n\n  private _updateTestIds(suite: JsonSuite) {\n    suite.entries.forEach(entry => {\n      if ('testId' in entry)\n        this._updateTestId(entry);\n      else\n        this._updateTestIds(entry);\n    });\n  }\n\n  private _updateTestId(test: JsonTestCase) {\n    test.testId = this._mapTestId(test.testId);\n    if (this._botName) {\n      test.tags = test.tags || [];\n      test.tags.unshift('@' + this._botName);\n    }\n  }\n\n  private _mapTestId(testId: string): string {\n    const t1 = this._stringPool.internString(testId);\n    if (this._testIdsMap.has(t1))\n      // already mapped\n      return this._testIdsMap.get(t1)!;\n    if (this._globalTestIdSet.has(t1)) {\n      // test id is used in another blob, so we need to salt it.\n      const t2 = this._stringPool.internString(testId + this._salt);\n      this._globalTestIdSet.add(t2);\n      this._testIdsMap.set(t1, t2);\n      return t2;\n    }\n    this._globalTestIdSet.add(t1);\n    this._testIdsMap.set(t1, t1);\n    return t1;\n  }\n}\n\nclass AttachmentPathPatcher {\n  constructor(private _resourceDir: string) {\n  }\n\n  patchEvent(event: JsonEvent) {\n    if (event.method === 'onAttach')\n      this._patchAttachments(event.params.attachments);\n    else if (event.method === 'onTestEnd')\n      this._patchAttachments(event.params.result.attachments ?? []);\n  }\n\n  private _patchAttachments(attachments: JsonAttachment[]) {\n    for (const attachment of attachments) {\n      if (!attachment.path)\n        continue;\n\n      attachment.path = path.join(this._resourceDir, attachment.path);\n    }\n  }\n}\n\nclass PathSeparatorPatcher {\n  private _from: string;\n  private _to: string;\n  constructor(from?: string) {\n    this._from = from ?? (path.sep === '/' ? '\\\\' : '/');\n    this._to = path.sep;\n  }\n\n  patchEvent(jsonEvent: JsonEvent) {\n    if (this._from === this._to)\n      return;\n    if (jsonEvent.method === 'onProject') {\n      this._updateProject(jsonEvent.params.project);\n      return;\n    }\n    if (jsonEvent.method === 'onTestEnd') {\n      const test = jsonEvent.params.test;\n      test.annotations?.forEach(annotation => this._updateAnnotationLocation(annotation));\n      const testResult = jsonEvent.params.result;\n      testResult.annotations?.forEach(annotation => this._updateAnnotationLocation(annotation));\n      testResult.errors.forEach(error => this._updateErrorLocations(error));\n      (testResult.attachments ?? []).forEach(attachment => {\n        if (attachment.path)\n          attachment.path = this._updatePath(attachment.path);\n      });\n      return;\n    }\n    if (jsonEvent.method === 'onStepBegin') {\n      const step = jsonEvent.params.step;\n      this._updateLocation(step.location);\n      return;\n    }\n    if (jsonEvent.method === 'onStepEnd') {\n      const step = jsonEvent.params.step;\n      this._updateErrorLocations(step.error);\n      step.annotations?.forEach(annotation => this._updateAnnotationLocation(annotation));\n      return;\n    }\n    if (jsonEvent.method === 'onAttach') {\n      const attach = jsonEvent.params;\n      attach.attachments.forEach(attachment => {\n        if (attachment.path)\n          attachment.path = this._updatePath(attachment.path);\n      });\n      return;\n    }\n  }\n\n  private _updateProject(project: JsonProject) {\n    project.outputDir = this._updatePath(project.outputDir);\n    project.testDir = this._updatePath(project.testDir);\n    project.snapshotDir = this._updatePath(project.snapshotDir);\n    project.suites.forEach(suite => this._updateSuite(suite, true));\n  }\n\n  private _updateSuite(suite: JsonSuite, isFileSuite: boolean = false) {\n    this._updateLocation(suite.location);\n    if (isFileSuite)\n      suite.title = this._updatePath(suite.title);\n    for (const entry of suite.entries) {\n      if ('testId' in entry) {\n        this._updateLocation(entry.location);\n        entry.annotations?.forEach(annotation => this._updateAnnotationLocation(annotation));\n      } else {\n        this._updateSuite(entry);\n      }\n    }\n  }\n\n  private _updateErrorLocations(error: TestError | undefined) {\n    while (error) {\n      this._updateLocation(error.location);\n      error = error.cause;\n    }\n  }\n\n  private _updateAnnotationLocation(annotation: TestAnnotation) {\n    this._updateLocation(annotation.location);\n  }\n\n  private _updateLocation(location?: JsonLocation) {\n    if (location)\n      location.file = this._updatePath(location.file);\n  }\n\n  private _updatePath(text: string): string {\n    return text.split(this._from).join(this._to);\n  }\n}\n\nclass GlobalErrorPatcher {\n  private _prefix: string;\n\n  constructor(botName: string) {\n    this._prefix = `(${botName}) `;\n  }\n\n  patchEvent(event: JsonEvent) {\n    if (event.method !== 'onError')\n      return;\n    const error = event.params.error;\n    if (error.message !== undefined)\n      error.message = this._prefix + error.message;\n    if (error.stack !== undefined)\n      error.stack = this._prefix + error.stack;\n  }\n}\n\ninterface JsonEventPatcher {\n  patchEvent(event: JsonEvent): void;\n}\n\nclass JsonEventPatchers {\n  readonly patchers: JsonEventPatcher[] = [];\n\n  patchEvents(events: JsonEvent[]) {\n    for (const event of events) {\n      for (const patcher of this.patchers)\n        patcher.patchEvent(event);\n    }\n  }\n}\n\nclass BlobModernizer {\n  modernize(fromVersion: number, events: JsonEvent[]): JsonEvent[] {\n    const result = [];\n    for (const event of events)\n      result.push(...this._modernize(fromVersion, event));\n    return result;\n  }\n\n  private _modernize(fromVersion: number, event: JsonEvent): JsonEvent[] {\n    let events = [event];\n    for (let version = fromVersion; version < currentBlobReportVersion; ++version)\n      events = (this as any)[`_modernize_${version}_to_${version + 1}`].call(this, events);\n    return events;\n  }\n\n  _modernize_1_to_2(events: JsonEvent[]): JsonEvent[] {\n    return events.map(event => {\n      if (event.method === 'onProject') {\n        const modernizeSuite = (suite: blobV1.JsonSuite): JsonSuite => {\n          const newSuites = suite.suites.map(modernizeSuite);\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { suites, tests, ...remainder } = suite;\n          return { entries: [...newSuites, ...tests], ...remainder };\n        };\n        const project = event.params.project;\n        project.suites = (project.suites as unknown as blobV1.JsonSuite[]).map(modernizeSuite);\n      }\n      return event;\n    });\n  }\n}\n\nconst modernizer = new BlobModernizer();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,gBAAe;AACf,kBAAiB;AAEjB,mBAAwB;AAExB,kBAA0C;AAC1C,yBAA4B;AAC5B,8BAAyD;AACzD,0BAAqC;AACrC,uBAAgC;AAChC,kBAAiC;AAgBjC,eAAsB,mBAAmB,QAA4B,KAAa,sBAA6C,iBAAqC;AAClK,QAAM,YAAY,UAAM,kCAAgB,QAAQ,SAAS,OAAO,oBAAoB;AACpF,QAAM,cAAc,IAAI,+BAAY,SAAS;AAC7C,QAAM,aAAa,IAAI,yCAAiB;AAExC,MAAI,cAA8B,MAAM;AAAA,EAAC;AACzC,MAAI,CAAC,YAAY,cAAc,GAAG;AAChC,kBAAc;AACd,gBAAY,wBAAwB,GAAG,EAAE;AAAA,EAC3C;AAEA,QAAM,aAAa,MAAM,iBAAiB,GAAG;AAC7C,MAAI,WAAW,WAAW;AACxB,UAAM,IAAI,MAAM,4BAA4B,GAAG,EAAE;AACnD,QAAM,YAAY,MAAM,YAAY,KAAK,YAAY,YAAY,aAAa,eAAe;AAE7F,QAAM,gBAAgB,kBAAkB,YAAAA,QAAK,MAAO,UAAU,6BAA6B,YAAAA,QAAK;AAChG,QAAM,WAAW,IAAI,yCAAqB,aAAa;AAAA,IACrD,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,aAAa,CAAC,SAAS,iBAAiB,WAAW,aAAa,UAAU,gBAAgB,YAAY;AAAA,IACtG,iBAAiB,OAAO;AAAA,EAC1B,CAAC;AACD,cAAY,wBAAwB;AAEpC,QAAM,iBAAiB,OAAO,WAAwB;AACpD,eAAW,SAAS,QAAQ;AAC1B,UAAI,MAAM,WAAW;AACnB,oBAAY,uBAAuB;AACrC,YAAM,SAAS,SAAS,KAAK;AAC7B,UAAI,MAAM,WAAW;AACnB,oBAAY,0BAA0B;AAAA,IAC1C;AAAA,EACF;AAEA,QAAM,eAAe,UAAU,QAAQ;AACvC,aAAW,EAAE,YAAY,eAAe,SAAS,KAAK,UAAU,SAAS;AACvE,UAAM,cAAc,MAAM,UAAAC,QAAG,SAAS,SAAS,UAAU;AACzD,UAAM,SAAS,gBAAgB,WAAW;AAC1C,QAAI,+CAAuB,UAAU,EAAE,SAAS,MAAM;AACtD,kBAAc,SAAS,KAAK,IAAI,sBAAsB,GAAG,CAAC;AAC1D,QAAI,SAAS;AACX,oBAAc,SAAS,KAAK,IAAI,mBAAmB,SAAS,IAAI,CAAC;AACnE,kBAAc,YAAY,MAAM;AAChC,UAAM,eAAe,MAAM;AAAA,EAC7B;AACA,QAAM,eAAe,UAAU,QAAQ;AACzC;AAEA,MAAM,mBAAmB,CAAC,wBAAwB,eAAe,aAAa,WAAW,OAAO;AAChG,MAAM,eAAe,IAAI,IAAI,gBAAgB;AAC7C,MAAM,mBAAmB,IAAI,OAAO,GAAG,iBAAiB,KAAK,GAAG,CAAC,EAAE;AAEnE,SAAS,kBAAkB,aAAkC;AAC3D,SAAO,iBAAiB,WAAW,EAC9B,IAAI,UAAQ,KAAK,SAAS,MAAM,CAAC,EACjC,OAAO,UAAQ,iBAAiB,KAAK,IAAI,CAAC,EAC1C,IAAI,UAAQ,KAAK,MAAM,IAAI,CAAc,EACzC,OAAO,WAAS,aAAa,IAAI,MAAM,MAAM,CAAC;AACrD;AAEA,SAAS,gBAAgB,aAAkC;AACzD,SAAO,iBAAiB,WAAW,EAC9B,IAAI,UAAQ,KAAK,SAAS,MAAM,CAAC,EACjC,OAAO,UAAQ,KAAK,MAAM,EAC1B,IAAI,UAAQ,KAAK,MAAM,IAAI,CAAc,EACzC,OAAO,WAAS,CAAC,aAAa,IAAI,MAAM,MAAM,CAAC;AACtD;AAEA,SAAS,iBAAiB,QAAgB;AACxC,QAAM,QAAQ,CAAC;AACf,MAAI,QAAQ;AACZ,SAAO,QAAQ,OAAO,QAAQ;AAE5B,UAAM,MAAM,OAAO,QAAQ,IAAM,KAAK;AACtC,QAAI,QAAQ,IAAI;AACd,YAAM,KAAK,OAAO,MAAM,KAAK,CAAC;AAC9B;AAAA,IACF;AACA,UAAM,KAAK,OAAO,MAAM,OAAO,GAAG,CAAC;AACnC,YAAQ,MAAM;AAAA,EAChB;AACA,SAAO;AACT;AAEA,eAAe,uBAAuB,KAAa,YAAsB,cAAsC,aAA6B;AAC1I,QAAM,cAA8G,CAAC;AACrH,QAAM,UAAAA,QAAG,SAAS,MAAM,YAAAD,QAAK,KAAK,KAAK,WAAW,GAAG,EAAE,WAAW,KAAK,CAAC;AAExE,QAAM,cAAc,IAAI,wBAAwB;AAChD,aAAW,QAAQ,YAAY;AAC7B,UAAM,eAAe,YAAAA,QAAK,KAAK,KAAK,IAAI;AACxC,gBAAY,mBAAe,8BAAiB,YAAY,CAAC,EAAE;AAC3D,UAAM,UAAU,IAAI,qBAAQ,YAAY;AACxC,UAAM,aAAa,MAAM,QAAQ,QAAQ;AACzC,eAAW,aAAa,WAAW,KAAK,GAAG;AACzC,UAAI,WAAW,YAAAA,QAAK,KAAK,KAAK,SAAS;AACvC,YAAM,UAAU,MAAM,QAAQ,KAAK,SAAS;AAC5C,UAAI,UAAU,SAAS,QAAQ,GAAG;AAChC,mBAAW,YAAY,WAAW,QAAQ;AAC1C,YAAI,eAAe,kBAAkB,OAAO;AAI5C,qBAAa,SAAS,YAAY;AAClC,cAAM,WAAW,aAAa,cAAc,IAAI;AAChD,uBAAe,WAAW,UAAU,SAAS,SAAS,YAAY;AAClE,oBAAY,KAAK;AAAA,UACf;AAAA,UACA,WAAW;AAAA,UACX;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AACA,YAAM,UAAAC,QAAG,SAAS,UAAU,UAAU,OAAO;AAAA,IAC/C;AACA,YAAQ,MAAM;AAAA,EAChB;AACA,SAAO;AACT;AAEA,SAAS,aAAa,QAAqB,MAAkC;AAC3E,MAAI,OAAO,CAAC,GAAG,WAAW;AACxB,UAAM,IAAI,MAAM,8BAA8B,IAAI,EAAE;AACtD,QAAM,WAAW,OAAO,CAAC,EAAE;AAC3B,MAAI,SAAS,UAAU;AACrB,UAAM,IAAI,MAAM,eAAe,IAAI,kDAAkD;AACvF,SAAO;AACT;AAEA,eAAe,YAAY,KAAa,kBAA4B,YAA8B,aAA6B,iBAK5H;AACD,QAAM,eAAe,IAAI,+CAAuB,UAAU;AAE1D,QAAM,kBAA0C,CAAC;AACjD,QAAM,gBAAsC,CAAC;AAC7C,QAAM,YAA8B,CAAC;AAErC,QAAM,QAAQ,MAAM,uBAAuB,KAAK,kBAAkB,cAAc,WAAW;AAK3F,QAAM,KAAK,CAAC,GAAG,MAAM;AACnB,UAAM,QAAQ,EAAE,SAAS,QAAQ;AACjC,UAAM,QAAQ,EAAE,SAAS,QAAQ;AACjC,QAAI,UAAU;AACZ,aAAO,MAAM,cAAc,KAAK;AAClC,UAAM,SAAS,EAAE,SAAS,OAAO,WAAW;AAC5C,UAAM,SAAS,EAAE,SAAS,OAAO,WAAW;AAC5C,QAAI,WAAW;AACb,aAAO,SAAS;AAClB,WAAO,EAAE,KAAK,cAAc,EAAE,IAAI;AAAA,EACpC,CAAC;AAED,cAAY,gBAAgB;AAE5B,QAAM,UAAwB,CAAC;AAC/B,QAAM,kBAAkB,oBAAI,IAAY;AAExC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AAErC,UAAM,EAAE,cAAc,UAAU,UAAU,IAAI,MAAM,CAAC;AACrD,UAAM,gBAAgB,IAAI,kBAAkB;AAC5C,kBAAc,SAAS,KAAK,IAAI;AAAA,MAC5B;AAAA,MACA,SAAS;AAAA,MACT,OAAO,CAAC;AAAA,MACR;AAAA,IACJ,CAAC;AAED,QAAI;AACF,oBAAc,SAAS,KAAK,IAAI,qBAAqB,SAAS,aAAa,CAAC;AAC9E,kBAAc,YAAY,YAAY;AAEtC,eAAW,SAAS,cAAc;AAChC,UAAI,MAAM,WAAW;AACnB,wBAAgB,KAAK,KAAK;AAAA,eACnB,MAAM,WAAW;AACxB,sBAAc,KAAK,KAAK;AAAA,eACjB,MAAM,WAAW;AACxB,kBAAU,KAAK,KAAK;AAAA,IACxB;AAGA,YAAQ,KAAK;AAAA,MACX;AAAA,MACA,YAAY;AAAA,MACZ;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,UAAU;AAAA,MACR,qBAAqB,iBAAiB,eAAe;AAAA,MACrD,GAAG;AAAA,MACH,EAAE,QAAQ,WAAW,QAAQ,OAAU;AAAA,IACzC;AAAA,IACA;AAAA,IACA,UAAU;AAAA,MACR,eAAe,SAAS;AAAA,MACxB,EAAE,QAAQ,UAAU,QAAQ,OAAU;AAAA,IACxC;AAAA,IACA,2BAA2B,MAAM,CAAC,GAAG,SAAS;AAAA,EAChD;AACF;AAEA,SAAS,qBAAqB,iBAAyC,iBAAgD;AACrH,MAAI,CAAC,gBAAgB;AACnB,UAAM,IAAI,MAAM,2BAA2B;AAC7C,MAAI,SAAqB;AAAA,IACvB,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,aAAa;AAAA,IACb,UAAU,CACV;AAAA,IACA,SAAS;AAAA,IACT,SAAS;AAAA,IACT,SAAS;AAAA,IACT,aAAa;AAAA,IACb,gBAAgB;AAAA,EAClB;AACA,aAAW,SAAS;AAClB,aAAS,aAAa,QAAQ,MAAM,OAAO,MAAM;AAEnD,MAAI,iBAAiB;AACnB,WAAO,UAAU;AAAA,EACnB,OAAO;AACL,UAAM,WAAW,IAAI,IAAI,gBAAgB,IAAI,OAAK,EAAE,OAAO,OAAO,OAAO,CAAC;AAC1E,QAAI,SAAS,OAAO,GAAG;AACrB,YAAM,IAAI,MAAM;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL,EAAE,KAAK,IAAI,CAAC;AAAA,IACd;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,MACN;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,aAAa,IAAgB,MAA8B;AAClE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,GAAG;AAAA,MACN,GAAG,KAAK;AAAA,MACR,gBAAgB,GAAG,SAAS,iBAAiB,MAAM,KAAK,SAAS,iBAAiB;AAAA,IACpF;AAAA,IACA,SAAS,GAAG,UAAU,KAAK;AAAA,EAC7B;AACF;AAEA,SAAS,eAAe,WAAwC;AAC9D,MAAI,YAAY,UAAU,SAAS,OAAiB,KAAK,IAAI;AAC7D,MAAI,SAAmC;AACvC,MAAI,WAAmB;AAEvB,aAAW,SAAS,WAAW;AAC7B,UAAM,cAAc,MAAM,OAAO;AACjC,QAAI,YAAY,WAAW;AACzB,eAAS;AAAA,aACF,YAAY,WAAW,cAAc,WAAW;AACvD,eAAS;AAAA,aACF,YAAY,WAAW,iBAAiB,WAAW,YAAY,WAAW;AACjF,eAAS;AACX,gBAAY,KAAK,IAAI,WAAW,YAAY,SAAS;AACrD,eAAW,KAAK,IAAI,UAAU,YAAY,QAAQ;AAAA,EACpD;AACA,QAAM,SAAyB;AAAA,IAC7B;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,MACN;AAAA,IACF;AAAA,EACF;AACF;AAEA,eAAe,iBAAiB,KAAa;AAC3C,QAAM,QAAQ,MAAM,UAAAA,QAAG,SAAS,QAAQ,GAAG;AAC3C,SAAO,MAAM,OAAO,UAAQ,KAAK,SAAS,MAAM,CAAC,EAAE,KAAK;AAC1D;AAEA,SAAS,oBAAoB,SAAiB;AAE5C,UAAQ,OAAO,MAAM,GAAG,OAAO;AAAA,CAAI;AACrC;AAEA,MAAM,wBAAwB;AAAA,EAA9B;AACE,SAAQ,aAAa,oBAAI,IAAY;AAAA;AAAA,EAErC,WAAW,MAAsB;AAC/B,QAAI,CAAC,KAAK,WAAW,IAAI,IAAI,GAAG;AAC9B,WAAK,WAAW,IAAI,IAAI;AACxB,aAAO;AAAA,IACT;AACA,UAAM,YAAY,YAAAD,QAAK,QAAQ,IAAI;AACnC,WAAO,KAAK,UAAU,GAAG,KAAK,SAAS,UAAU,MAAM;AACvD,QAAI,QAAQ;AACZ,WAAO,MAAM;AACX,YAAM,YAAY,GAAG,IAAI,IAAI,EAAE,KAAK,GAAG,SAAS;AAChD,UAAI,CAAC,KAAK,WAAW,IAAI,SAAS,GAAG;AACnC,aAAK,WAAW,IAAI,SAAS;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;AAEA,MAAM,WAAW;AAAA,EAOf,YACE,YACA,SACA,MACA,iBACA;AACA,SAAK,cAAc;AACnB,SAAK,WAAW;AAChB,SAAK,QAAQ;AACb,SAAK,cAAc,oBAAI,IAAI;AAC3B,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,WAAW,OAAkB;AAC3B,UAAM,EAAE,QAAQ,OAAO,IAAI;AAC3B,YAAQ,QAAQ;AAAA,MACd,KAAK;AACH,aAAK,WAAW,OAAO,OAAO;AAC9B;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO,SAAS,OAAO,SAAS,KAAK,WAAW,OAAO,MAAM,IAAI;AACjE;AAAA,MACF,KAAK;AACH,eAAO,KAAK,SAAS,KAAK,WAAW,OAAO,KAAK,MAAM;AACvD;AAAA,IACJ;AAAA,EACF;AAAA,EAEQ,WAAW,SAAsB;AACvC,YAAQ,aAAa,CAAC;AACtB,YAAQ,OAAO,QAAQ,WAAS,KAAK,eAAe,KAAK,CAAC;AAAA,EAC5D;AAAA,EAEQ,eAAe,OAAkB;AACvC,UAAM,QAAQ,QAAQ,WAAS;AAC7B,UAAI,YAAY;AACd,aAAK,cAAc,KAAK;AAAA;AAExB,aAAK,eAAe,KAAK;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEQ,cAAc,MAAoB;AACxC,SAAK,SAAS,KAAK,WAAW,KAAK,MAAM;AACzC,QAAI,KAAK,UAAU;AACjB,WAAK,OAAO,KAAK,QAAQ,CAAC;AAC1B,WAAK,KAAK,QAAQ,MAAM,KAAK,QAAQ;AAAA,IACvC;AAAA,EACF;AAAA,EAEQ,WAAW,QAAwB;AACzC,UAAM,KAAK,KAAK,YAAY,aAAa,MAAM;AAC/C,QAAI,KAAK,YAAY,IAAI,EAAE;AAEzB,aAAO,KAAK,YAAY,IAAI,EAAE;AAChC,QAAI,KAAK,iBAAiB,IAAI,EAAE,GAAG;AAEjC,YAAM,KAAK,KAAK,YAAY,aAAa,SAAS,KAAK,KAAK;AAC5D,WAAK,iBAAiB,IAAI,EAAE;AAC5B,WAAK,YAAY,IAAI,IAAI,EAAE;AAC3B,aAAO;AAAA,IACT;AACA,SAAK,iBAAiB,IAAI,EAAE;AAC5B,SAAK,YAAY,IAAI,IAAI,EAAE;AAC3B,WAAO;AAAA,EACT;AACF;AAEA,MAAM,sBAAsB;AAAA,EAC1B,YAAoB,cAAsB;AAAtB;AAAA,EACpB;AAAA,EAEA,WAAW,OAAkB;AAC3B,QAAI,MAAM,WAAW;AACnB,WAAK,kBAAkB,MAAM,OAAO,WAAW;AAAA,aACxC,MAAM,WAAW;AACxB,WAAK,kBAAkB,MAAM,OAAO,OAAO,eAAe,CAAC,CAAC;AAAA,EAChE;AAAA,EAEQ,kBAAkB,aAA+B;AACvD,eAAW,cAAc,aAAa;AACpC,UAAI,CAAC,WAAW;AACd;AAEF,iBAAW,OAAO,YAAAA,QAAK,KAAK,KAAK,cAAc,WAAW,IAAI;AAAA,IAChE;AAAA,EACF;AACF;AAEA,MAAM,qBAAqB;AAAA,EAGzB,YAAY,MAAe;AACzB,SAAK,QAAQ,SAAS,YAAAA,QAAK,QAAQ,MAAM,OAAO;AAChD,SAAK,MAAM,YAAAA,QAAK;AAAA,EAClB;AAAA,EAEA,WAAW,WAAsB;AAC/B,QAAI,KAAK,UAAU,KAAK;AACtB;AACF,QAAI,UAAU,WAAW,aAAa;AACpC,WAAK,eAAe,UAAU,OAAO,OAAO;AAC5C;AAAA,IACF;AACA,QAAI,UAAU,WAAW,aAAa;AACpC,YAAM,OAAO,UAAU,OAAO;AAC9B,WAAK,aAAa,QAAQ,gBAAc,KAAK,0BAA0B,UAAU,CAAC;AAClF,YAAM,aAAa,UAAU,OAAO;AACpC,iBAAW,aAAa,QAAQ,gBAAc,KAAK,0BAA0B,UAAU,CAAC;AACxF,iBAAW,OAAO,QAAQ,WAAS,KAAK,sBAAsB,KAAK,CAAC;AACpE,OAAC,WAAW,eAAe,CAAC,GAAG,QAAQ,gBAAc;AACnD,YAAI,WAAW;AACb,qBAAW,OAAO,KAAK,YAAY,WAAW,IAAI;AAAA,MACtD,CAAC;AACD;AAAA,IACF;AACA,QAAI,UAAU,WAAW,eAAe;AACtC,YAAM,OAAO,UAAU,OAAO;AAC9B,WAAK,gBAAgB,KAAK,QAAQ;AAClC;AAAA,IACF;AACA,QAAI,UAAU,WAAW,aAAa;AACpC,YAAM,OAAO,UAAU,OAAO;AAC9B,WAAK,sBAAsB,KAAK,KAAK;AACrC,WAAK,aAAa,QAAQ,gBAAc,KAAK,0BAA0B,UAAU,CAAC;AAClF;AAAA,IACF;AACA,QAAI,UAAU,WAAW,YAAY;AACnC,YAAM,SAAS,UAAU;AACzB,aAAO,YAAY,QAAQ,gBAAc;AACvC,YAAI,WAAW;AACb,qBAAW,OAAO,KAAK,YAAY,WAAW,IAAI;AAAA,MACtD,CAAC;AACD;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,eAAe,SAAsB;AAC3C,YAAQ,YAAY,KAAK,YAAY,QAAQ,SAAS;AACtD,YAAQ,UAAU,KAAK,YAAY,QAAQ,OAAO;AAClD,YAAQ,cAAc,KAAK,YAAY,QAAQ,WAAW;AAC1D,YAAQ,OAAO,QAAQ,WAAS,KAAK,aAAa,OAAO,IAAI,CAAC;AAAA,EAChE;AAAA,EAEQ,aAAa,OAAkB,cAAuB,OAAO;AACnE,SAAK,gBAAgB,MAAM,QAAQ;AACnC,QAAI;AACF,YAAM,QAAQ,KAAK,YAAY,MAAM,KAAK;AAC5C,eAAW,SAAS,MAAM,SAAS;AACjC,UAAI,YAAY,OAAO;AACrB,aAAK,gBAAgB,MAAM,QAAQ;AACnC,cAAM,aAAa,QAAQ,gBAAc,KAAK,0BAA0B,UAAU,CAAC;AAAA,MACrF,OAAO;AACL,aAAK,aAAa,KAAK;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,sBAAsB,OAA8B;AAC1D,WAAO,OAAO;AACZ,WAAK,gBAAgB,MAAM,QAAQ;AACnC,cAAQ,MAAM;AAAA,IAChB;AAAA,EACF;AAAA,EAEQ,0BAA0B,YAA4B;AAC5D,SAAK,gBAAgB,WAAW,QAAQ;AAAA,EAC1C;AAAA,EAEQ,gBAAgB,UAAyB;AAC/C,QAAI;AACF,eAAS,OAAO,KAAK,YAAY,SAAS,IAAI;AAAA,EAClD;AAAA,EAEQ,YAAY,MAAsB;AACxC,WAAO,KAAK,MAAM,KAAK,KAAK,EAAE,KAAK,KAAK,GAAG;AAAA,EAC7C;AACF;AAEA,MAAM,mBAAmB;AAAA,EAGvB,YAAY,SAAiB;AAC3B,SAAK,UAAU,IAAI,OAAO;AAAA,EAC5B;AAAA,EAEA,WAAW,OAAkB;AAC3B,QAAI,MAAM,WAAW;AACnB;AACF,UAAM,QAAQ,MAAM,OAAO;AAC3B,QAAI,MAAM,YAAY;AACpB,YAAM,UAAU,KAAK,UAAU,MAAM;AACvC,QAAI,MAAM,UAAU;AAClB,YAAM,QAAQ,KAAK,UAAU,MAAM;AAAA,EACvC;AACF;AAMA,MAAM,kBAAkB;AAAA,EAAxB;AACE,SAAS,WAA+B,CAAC;AAAA;AAAA,EAEzC,YAAY,QAAqB;AAC/B,eAAW,SAAS,QAAQ;AAC1B,iBAAW,WAAW,KAAK;AACzB,gBAAQ,WAAW,KAAK;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,MAAM,eAAe;AAAA,EACnB,UAAU,aAAqB,QAAkC;AAC/D,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS;AAClB,aAAO,KAAK,GAAG,KAAK,WAAW,aAAa,KAAK,CAAC;AACpD,WAAO;AAAA,EACT;AAAA,EAEQ,WAAW,aAAqB,OAA+B;AACrE,QAAI,SAAS,CAAC,KAAK;AACnB,aAAS,UAAU,aAAa,UAAU,sCAA0B,EAAE;AACpE,eAAU,KAAa,cAAc,OAAO,OAAO,UAAU,CAAC,EAAE,EAAE,KAAK,MAAM,MAAM;AACrF,WAAO;AAAA,EACT;AAAA,EAEA,kBAAkB,QAAkC;AAClD,WAAO,OAAO,IAAI,WAAS;AACzB,UAAI,MAAM,WAAW,aAAa;AAChC,cAAM,iBAAiB,CAAC,UAAuC;AAC7D,gBAAM,YAAY,MAAM,OAAO,IAAI,cAAc;AAEjD,gBAAM,EAAE,QAAQ,OAAO,GAAG,UAAU,IAAI;AACxC,iBAAO,EAAE,SAAS,CAAC,GAAG,WAAW,GAAG,KAAK,GAAG,GAAG,UAAU;AAAA,QAC3D;AACA,cAAM,UAAU,MAAM,OAAO;AAC7B,gBAAQ,SAAU,QAAQ,OAAyC,IAAI,cAAc;AAAA,MACvF;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACF;AAEA,MAAM,aAAa,IAAI,eAAe;",
  "names": ["path", "fs"]
}

{
  "version": 3,
  "sources": ["../../src/reporters/reporterV2.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { FullConfig, FullResult, Reporter, Suite, TestCase, TestError, TestResult, TestStep } from '../../types/testReporter';\n\nexport interface ReporterV2 {\n  onConfigure?(config: FullConfig): void;\n  onBegin?(suite: Suite): void;\n  onTestBegin?(test: TestCase, result: TestResult): void;\n  onStdOut?(chunk: string | Buffer, test?: TestCase, result?: TestResult): void;\n  onStdErr?(chunk: string | Buffer, test?: TestCase, result?: TestResult): void;\n  onTestEnd?(test: TestCase, result: TestResult): void;\n  onEnd?(result: FullResult): Promise<{ status?: FullResult['status'] } | undefined | void> | void;\n  onExit?(): void | Promise<void>;\n  onError?(error: TestError): void;\n  onStepBegin?(test: TestCase, result: TestResult, step: TestStep): void;\n  onStepEnd?(test: TestCase, result: TestResult, step: TestStep): void;\n  printsToStdio?(): boolean;\n  version(): 'v2';\n}\n\nexport type AnyReporter = ReporterV2 | Reporter;\n\ntype StdIOChunk = {\n  chunk: string | Buffer;\n  test?: TestCase;\n  result?: TestResult;\n};\n\nexport function wrapReporterAsV2(reporter: Reporter | ReporterV2): ReporterV2 {\n  try {\n    if ('version' in reporter && reporter.version() === 'v2')\n      return reporter as ReporterV2;\n  } catch (e) {\n  }\n  return new ReporterV2Wrapper(reporter as Reporter);\n}\n\nclass ReporterV2Wrapper implements ReporterV2 {\n  private _reporter: Reporter;\n  private _deferred: { error?: TestError, stdout?: StdIOChunk, stderr?: StdIOChunk }[] | null = [];\n  private _config!: FullConfig;\n\n  constructor(reporter: Reporter) {\n    this._reporter = reporter;\n  }\n\n  version(): 'v2' {\n    return 'v2';\n  }\n\n  onConfigure(config: FullConfig) {\n    this._config = config;\n  }\n\n  onBegin(suite: Suite) {\n    this._reporter.onBegin?.(this._config, suite);\n\n    const deferred = this._deferred!;\n    this._deferred = null;\n    for (const item of deferred) {\n      if (item.error)\n        this.onError(item.error);\n      if (item.stdout)\n        this.onStdOut(item.stdout.chunk, item.stdout.test, item.stdout.result);\n      if (item.stderr)\n        this.onStdErr(item.stderr.chunk, item.stderr.test, item.stderr.result);\n    }\n  }\n\n  onTestBegin(test: TestCase, result: TestResult) {\n    this._reporter.onTestBegin?.(test, result);\n  }\n\n  onStdOut(chunk: string | Buffer, test?: TestCase, result?: TestResult) {\n    if (this._deferred) {\n      this._deferred.push({ stdout: { chunk, test, result } });\n      return;\n    }\n    this._reporter.onStdOut?.(chunk, test, result);\n  }\n\n  onStdErr(chunk: string | Buffer, test?: TestCase, result?: TestResult) {\n    if (this._deferred) {\n      this._deferred.push({ stderr: { chunk, test, result } });\n      return;\n    }\n    this._reporter.onStdErr?.(chunk, test, result);\n  }\n\n  onTestEnd(test: TestCase, result: TestResult) {\n    this._reporter.onTestEnd?.(test, result);\n  }\n\n  async onEnd(result: FullResult) {\n    return await this._reporter.onEnd?.(result);\n  }\n\n  async onExit() {\n    await this._reporter.onExit?.();\n  }\n\n  onError(error: TestError) {\n    if (this._deferred) {\n      this._deferred.push({ error });\n      return;\n    }\n    this._reporter.onError?.(error);\n  }\n\n  onStepBegin(test: TestCase, result: TestResult, step: TestStep) {\n    this._reporter.onStepBegin?.(test, result, step);\n  }\n\n  onStepEnd(test: TestCase, result: TestResult, step: TestStep) {\n    this._reporter.onStepEnd?.(test, result, step);\n  }\n\n  printsToStdio() {\n    return this._reporter.printsToStdio ? this._reporter.printsToStdio() : true;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA0CO,SAAS,iBAAiB,UAA6C;AAC5E,MAAI;AACF,QAAI,aAAa,YAAY,SAAS,QAAQ,MAAM;AAClD,aAAO;AAAA,EACX,SAAS,GAAG;AAAA,EACZ;AACA,SAAO,IAAI,kBAAkB,QAAoB;AACnD;AAEA,MAAM,kBAAwC;AAAA,EAK5C,YAAY,UAAoB;AAHhC,SAAQ,YAAsF,CAAC;AAI7F,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,UAAgB;AACd,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,QAAQ,OAAc;AACpB,SAAK,UAAU,UAAU,KAAK,SAAS,KAAK;AAE5C,UAAM,WAAW,KAAK;AACtB,SAAK,YAAY;AACjB,eAAW,QAAQ,UAAU;AAC3B,UAAI,KAAK;AACP,aAAK,QAAQ,KAAK,KAAK;AACzB,UAAI,KAAK;AACP,aAAK,SAAS,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,MAAM;AACvE,UAAI,KAAK;AACP,aAAK,SAAS,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,MAAM;AAAA,IACzE;AAAA,EACF;AAAA,EAEA,YAAY,MAAgB,QAAoB;AAC9C,SAAK,UAAU,cAAc,MAAM,MAAM;AAAA,EAC3C;AAAA,EAEA,SAAS,OAAwB,MAAiB,QAAqB;AACrE,QAAI,KAAK,WAAW;AAClB,WAAK,UAAU,KAAK,EAAE,QAAQ,EAAE,OAAO,MAAM,OAAO,EAAE,CAAC;AACvD;AAAA,IACF;AACA,SAAK,UAAU,WAAW,OAAO,MAAM,MAAM;AAAA,EAC/C;AAAA,EAEA,SAAS,OAAwB,MAAiB,QAAqB;AACrE,QAAI,KAAK,WAAW;AAClB,WAAK,UAAU,KAAK,EAAE,QAAQ,EAAE,OAAO,MAAM,OAAO,EAAE,CAAC;AACvD;AAAA,IACF;AACA,SAAK,UAAU,WAAW,OAAO,MAAM,MAAM;AAAA,EAC/C;AAAA,EAEA,UAAU,MAAgB,QAAoB;AAC5C,SAAK,UAAU,YAAY,MAAM,MAAM;AAAA,EACzC;AAAA,EAEA,MAAM,MAAM,QAAoB;AAC9B,WAAO,MAAM,KAAK,UAAU,QAAQ,MAAM;AAAA,EAC5C;AAAA,EAEA,MAAM,SAAS;AACb,UAAM,KAAK,UAAU,SAAS;AAAA,EAChC;AAAA,EAEA,QAAQ,OAAkB;AACxB,QAAI,KAAK,WAAW;AAClB,WAAK,UAAU,KAAK,EAAE,MAAM,CAAC;AAC7B;AAAA,IACF;AACA,SAAK,UAAU,UAAU,KAAK;AAAA,EAChC;AAAA,EAEA,YAAY,MAAgB,QAAoB,MAAgB;AAC9D,SAAK,UAAU,cAAc,MAAM,QAAQ,IAAI;AAAA,EACjD;AAAA,EAEA,UAAU,MAAgB,QAAoB,MAAgB;AAC5D,SAAK,UAAU,YAAY,MAAM,QAAQ,IAAI;AAAA,EAC/C;AAAA,EAEA,gBAAgB;AACd,WAAO,KAAK,UAAU,gBAAgB,KAAK,UAAU,cAAc,IAAI;AAAA,EACzE;AACF;",
  "names": []
}

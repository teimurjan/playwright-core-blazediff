{
  "version": 3,
  "sources": ["../../../src/utils/isomorphic/stackTrace.ts"],
  "sourcesContent": ["/**\n * The MIT License (MIT)\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Copyright (c) 2016-2023 Isaac Z. Schlueter i@izs.me, James Talmage james@talmage.io (github.com/jamestalmage), and\n * Contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nexport type RawStack = string[];\n\nexport type StackFrame = {\n  file: string,\n  line: number,\n  column: number,\n  function?: string,\n};\n\nexport function captureRawStack(): RawStack {\n  const stackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 50;\n  const error = new Error();\n  const stack = error.stack || '';\n  Error.stackTraceLimit = stackTraceLimit;\n  return stack.split('\\n');\n}\n\nexport function parseStackFrame(text: string, pathSeparator: string, showInternalStackFrames: boolean): StackFrame | null {\n  const match = text && text.match(re);\n  if (!match)\n    return null;\n\n  let fname = match[2];\n  let file = match[7];\n  if (!file)\n    return null;\n  if (!showInternalStackFrames && (file.startsWith('internal') || file.startsWith('node:')))\n    return null;\n\n  const line = match[8];\n  const column = match[9];\n  const closeParen = match[11] === ')';\n\n  const frame: StackFrame = {\n    file: '',\n    line: 0,\n    column: 0,\n  };\n\n  if (line)\n    frame.line = Number(line);\n\n  if (column)\n    frame.column = Number(column);\n\n  if (closeParen && file) {\n    // make sure parens are balanced\n    // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n    // that the fname should be += \" (asdf) [as foo]\" and the file\n    // should be just \"xyz.js\"\n    // walk backwards from the end to find the last unbalanced (\n    let closes = 0;\n    for (let i = file.length - 1; i > 0; i--) {\n      if (file.charAt(i) === ')') {\n        closes++;\n      } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n        closes--;\n        if (closes === -1 && file.charAt(i - 1) === ' ') {\n          const before = file.slice(0, i - 1);\n          const after = file.slice(i + 1);\n          file = after;\n          fname += ` (${before}`;\n          break;\n        }\n      }\n    }\n  }\n\n  if (fname) {\n    const methodMatch = fname.match(methodRe);\n    if (methodMatch)\n      fname = methodMatch[1];\n  }\n\n  if (file) {\n    if (file.startsWith('file://'))\n      file = fileURLToPath(file, pathSeparator);\n    frame.file = file;\n  }\n\n  if (fname)\n    frame.function = fname;\n\n  return frame;\n}\n\nexport function rewriteErrorMessage<E extends Error>(e: E, newMessage: string): E {\n  const lines: string[] = (e.stack?.split('\\n') || []).filter(l => l.startsWith('    at '));\n  e.message = newMessage;\n  const errorTitle = `${e.name}: ${e.message}`;\n  if (lines.length)\n    e.stack = `${errorTitle}\\n${lines.join('\\n')}`;\n  return e;\n}\n\nexport function stringifyStackFrames(frames: StackFrame[]): string[] {\n  const stackLines: string[] = [];\n  for (const frame of frames) {\n    if (frame.function)\n      stackLines.push(`    at ${frame.function} (${frame.file}:${frame.line}:${frame.column})`);\n    else\n      stackLines.push(`    at ${frame.file}:${frame.line}:${frame.column}`);\n  }\n  return stackLines;\n}\n\nexport function splitErrorMessage(message: string): { name: string, message: string } {\n  const separationIdx = message.indexOf(':');\n  return {\n    name: separationIdx !== -1 ? message.slice(0, separationIdx) : '',\n    message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message,\n  };\n}\n\nexport function parseErrorStack(stack: string, pathSeparator: string, showInternalStackFrames: boolean = false): {\n  message: string;\n  stackLines: string[];\n  location?: StackFrame;\n} {\n  const lines = stack.split('\\n');\n  let firstStackLine = lines.findIndex(line => line.startsWith('    at '));\n  if (firstStackLine === -1)\n    firstStackLine = lines.length;\n  const message = lines.slice(0, firstStackLine).join('\\n');\n  const stackLines = lines.slice(firstStackLine);\n  let location: StackFrame | undefined;\n  for (const line of stackLines) {\n    const frame = parseStackFrame(line, pathSeparator, showInternalStackFrames);\n    if (!frame || !frame.file)\n      continue;\n    if (belongsToNodeModules(frame.file, pathSeparator))\n      continue;\n    location = { file: frame.file, column: frame.column || 0, line: frame.line || 0 };\n    break;\n  }\n  return { message, stackLines, location };\n}\n\nfunction belongsToNodeModules(file: string, pathSeparator: string) {\n  return file.includes(`${pathSeparator}node_modules${pathSeparator}`);\n}\n\nconst re = new RegExp('^' +\n  // Sometimes we strip out the '    at' because it's noisy\n  '(?:\\\\s*at )?' +\n  // $1 = ctor if 'new'\n  '(?:(new) )?' +\n  // $2 = function name (can be literally anything)\n  // May contain method at the end as [as xyz]\n  '(?:(.*?) \\\\()?' +\n  // (eval at <anonymous> (file.js:1:1),\n  // $3 = eval origin\n  // $4:$5:$6 are eval file/line/col, but not normally reported\n  '(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n  // file:line:col\n  // $7:$8:$9\n  // $10 = 'native' if native\n  '(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n  // maybe close the paren, then end\n  // if $11 is ), then we only allow balanced parens in the filename\n  // any imbalance is placed on the fname.  This is a heuristic, and\n  // bound to be incorrect in some edge cases.  The bet is that\n  // having weird characters in method names is more common than\n  // having weird characters in filenames, which seems reasonable.\n  '(\\\\)?)$'\n);\n\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nfunction fileURLToPath(fileUrl: string, pathSeparator: string): string {\n  if (!fileUrl.startsWith('file://'))\n    return fileUrl;\n\n  let path = decodeURIComponent(fileUrl.slice(7));\n  if (path.startsWith('/') && /^[a-zA-Z]:/.test(path.slice(1)))\n    path = path.slice(1);\n\n  return path.replace(/\\//g, pathSeparator);\n}\n"],
  "mappings": "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",
  "names": []
}

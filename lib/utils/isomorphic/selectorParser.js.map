{
  "version": 3,
  "sources": ["../../../src/utils/isomorphic/selectorParser.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InvalidSelectorError, parseCSS } from './cssParser';\n\nimport type { CSSComplexSelectorList } from './cssParser';\nexport { InvalidSelectorError, isInvalidSelectorError } from './cssParser';\n\nexport type NestedSelectorBody = { parsed: ParsedSelector, distance?: number };\nconst kNestedSelectorNames = new Set(['internal:has', 'internal:has-not', 'internal:and', 'internal:or', 'internal:chain', 'left-of', 'right-of', 'above', 'below', 'near']);\nconst kNestedSelectorNamesWithDistance = new Set(['left-of', 'right-of', 'above', 'below', 'near']);\n\nexport type ParsedSelectorPart = {\n  name: string,\n  body: string | CSSComplexSelectorList | NestedSelectorBody,\n  source: string,\n};\n\nexport type ParsedSelector = {\n  parts: ParsedSelectorPart[],\n  capture?: number,\n};\n\ntype ParsedSelectorStrings = {\n  parts: { name: string, body: string }[],\n  capture?: number,\n};\n\nexport const customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);\n\nexport function parseSelector(selector: string): ParsedSelector {\n  const parsedStrings = parseSelectorString(selector);\n  const parts: ParsedSelectorPart[] = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === 'css' || part.name === 'css:light') {\n      if (part.name === 'css:light')\n        part.body = ':light(' + part.body + ')';\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: 'css',\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector: string;\n      let distance: number | undefined;\n      try {\n        const unescaped = JSON.parse('[' + part.body + ']');\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== 'string')\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== 'number' || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find(part => part.name === 'internal:control' && part.body === 'enter-frame');\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      // Allow nested selectors to start with the same frame selector.\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`\"${parts[0].name}\" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\n\nexport function splitSelectorByFrame(selectorText: string): ParsedSelector[] {\n  const selector = parseSelector(selectorText);\n  const result: ParsedSelector[] = [];\n  let chunk: ParsedSelector = {\n    parts: [],\n  };\n  let chunkStartIndex = 0;\n  for (let i = 0; i < selector.parts.length; ++i) {\n    const part = selector.parts[i];\n    if (part.name === 'internal:control' && part.body === 'enter-frame') {\n      if (!chunk.parts.length)\n        throw new InvalidSelectorError('Selector cannot start with entering frame, select the iframe first');\n      result.push(chunk);\n      chunk = { parts: [] };\n      chunkStartIndex = i + 1;\n      continue;\n    }\n    if (selector.capture === i)\n      chunk.capture = i - chunkStartIndex;\n    chunk.parts.push(part);\n  }\n  if (!chunk.parts.length)\n    throw new InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);\n  result.push(chunk);\n  if (typeof selector.capture === 'number' && typeof result[result.length - 1].capture !== 'number')\n    throw new InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);\n  return result;\n}\n\nfunction selectorPartsEqual(list1: ParsedSelectorPart[], list2: ParsedSelectorPart[]) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\n\nexport function stringifySelector(selector: string | ParsedSelector, forceEngineName?: boolean): string {\n  if (typeof selector === 'string')\n    return selector;\n  return selector.parts.map((p, i) => {\n    let includeEngine = true;\n    if (!forceEngineName && i !== selector.capture) {\n      if (p.name === 'css')\n        includeEngine = false;\n      else if (p.name === 'xpath' && p.source.startsWith('//') || p.source.startsWith('..'))\n        includeEngine = false;\n    }\n    const prefix = includeEngine ? p.name + '=' : '';\n    return `${i === selector.capture ? '*' : ''}${prefix}${p.source}`;\n  }).join(' >> ');\n}\n\nexport function visitAllSelectorParts(selector: ParsedSelector, visitor: (part: ParsedSelectorPart, nested: boolean) => void) {\n  const visit = (selector: ParsedSelector, nested: boolean) => {\n    for (const part of selector.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit((part.body as NestedSelectorBody).parsed, true);\n    }\n  };\n  visit(selector, false);\n}\n\nfunction parseSelectorString(selector: string): ParsedSelectorStrings {\n  let index = 0;\n  let quote: string | undefined;\n  let start = 0;\n  const result: ParsedSelectorStrings = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf('=');\n    let name: string;\n    let body: string;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = 'text';\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = 'text';\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith('..')) {\n      // If selector starts with '//' or '//' prefixed with multiple opening\n      // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817\n      // If selector starts with '..', consider xpath as well.\n      name = 'xpath';\n      body = part;\n    } else {\n      name = 'css';\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === '*') {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== undefined)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n\n  if (!selector.includes('>>')) {\n    index = selector.length;\n    append();\n    return result;\n  }\n\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    // Must be a text selector with some text before the quote.\n    return !!match && !!match[1];\n  };\n\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === '\\\\' && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = undefined;\n      index++;\n    } else if (!quote && (c === '\"' || c === '\\'' || c === '`') && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === '>' && selector[index + 1] === '>') {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\n\nexport type AttributeSelectorOperator = '<truthy>'|'='|'*='|'|='|'^='|'$='|'~=';\nexport type AttributeSelectorPart = {\n  name: string,\n  jsonPath: string[],\n  op: AttributeSelectorOperator,\n  value: any,\n  caseSensitive: boolean,\n};\n\nexport type AttributeSelector = {\n  name: string,\n  attributes: AttributeSelectorPart[],\n};\n\n\nexport function parseAttributeSelector(selector: string, allowUnquotedStrings: boolean): AttributeSelector {\n  let wp = 0;\n  let EOL = selector.length === 0;\n\n  const next = () => selector[wp] || '';\n  const eat1 = () => {\n    const result = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result;\n  };\n\n  const syntaxError = (stage: string|undefined) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol \"${next()}\" at position ${wp}` + (stage ? ' during ' + stage : ''));\n  };\n\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n\n  function isCSSNameChar(char: string) {\n    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n    return (char >= '\\u0080')  // non-ascii\n        || (char >= '\\u0030' && char <= '\\u0039')  // digit\n        || (char >= '\\u0041' && char <= '\\u005a')  // uppercase letter\n        || (char >= '\\u0061' && char <= '\\u007a')  // lowercase letter\n        || (char >= '\\u0030' && char <= '\\u0039')  // digit\n        || char === '\\u005f'  // \"_\"\n        || char === '\\u002d';  // \"-\"\n  }\n\n  function readIdentifier() {\n    let result = '';\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result += eat1();\n    return result;\n  }\n\n  function readQuotedString(quote: string) {\n    let result = eat1();\n    if (result !== quote)\n      syntaxError('parsing quoted string');\n    while (!EOL && next() !== quote) {\n      if (next() === '\\\\')\n        eat1();\n      result += eat1();\n    }\n    if (next() !== quote)\n      syntaxError('parsing quoted string');\n    result += eat1();\n    return result;\n  }\n\n  function readRegularExpression() {\n    if (eat1() !== '/')\n      syntaxError('parsing regular expression');\n    let source = '';\n    let inClass = false;\n    // https://262.ecma-international.org/11.0/#sec-literals-regular-expression-literals\n    while (!EOL) {\n      if (next() === '\\\\') {\n        source += eat1();\n        if (EOL)\n          syntaxError('parsing regular expression');\n      } else if (inClass && next() === ']') {\n        inClass = false;\n      } else if (!inClass && next() === '[') {\n        inClass = true;\n      } else if (!inClass && next() === '/') {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== '/')\n      syntaxError('parsing regular expression');\n    let flags = '';\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n\n  function readAttributeToken() {\n    let token = '';\n    skipSpaces();\n    if (next() === `'` || next() === `\"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError('parsing property path');\n    return token;\n  }\n\n  function readOperator(): AttributeSelectorOperator {\n    skipSpaces();\n    let op = '';\n    if (!EOL)\n      op += eat1();\n    if (!EOL && (op !== '='))\n      op += eat1();\n    if (!['=', '*=', '^=', '$=', '|=', '~='].includes(op))\n      syntaxError('parsing operator');\n    return (op as AttributeSelectorOperator);\n  }\n\n  function readAttribute(): AttributeSelectorPart {\n    // skip leading [\n    eat1();\n\n    // read attribute name:\n    // foo.bar\n    // 'foo'  . \"ba zz\"\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === '.') {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    // check property is truthy: [enabled]\n    if (next() === ']') {\n      eat1();\n      return { name: jsonPath.join('.'), jsonPath, op: '<truthy>', value: null, caseSensitive: false };\n    }\n\n    const operator = readOperator();\n\n    let value = undefined;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === '/') {\n      if (operator !== '=')\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `'` || next() === `\"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === 'i' || next() === 'I') {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === 's' || next() === 'S') {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = '';\n      while (!EOL && (isCSSNameChar(next()) || next() === '+' || next() === '.'))\n        value += eat1();\n      if (value === 'true') {\n        value = true;\n      } else if (value === 'false') {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError('parsing attribute value');\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== ']')\n      syntaxError('parsing attribute value');\n\n    eat1();\n    if (operator !== '=' && typeof value !== 'string')\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join('.'), jsonPath, op: operator, value, caseSensitive };\n  }\n\n  const result: AttributeSelector = {\n    name: '',\n    attributes: [],\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === '[') {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(undefined);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["import_cssParser", "part", "selector", "result"]
}

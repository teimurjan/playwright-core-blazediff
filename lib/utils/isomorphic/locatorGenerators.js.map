{
  "version": 3,
  "sources": ["../../../src/utils/isomorphic/locatorGenerators.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {  parseAttributeSelector, parseSelector, stringifySelector } from './selectorParser';\nimport { escapeWithQuotes, normalizeEscapedRegexQuotes, toSnakeCase, toTitleCase } from './stringUtils';\n\nimport type { NestedSelectorBody } from './selectorParser';\nimport type { ParsedSelector } from './selectorParser';\n\nexport type Language = 'javascript' | 'python' | 'java' | 'csharp' | 'jsonl';\nexport type LocatorType = 'default' | 'role' | 'text' | 'label' | 'placeholder' | 'alt' | 'title' | 'test-id' | 'nth' | 'first' | 'last' | 'visible' | 'has-text' | 'has-not-text' | 'has' | 'hasNot' | 'frame' | 'frame-locator' | 'and' | 'or' | 'chain';\nexport type LocatorBase = 'page' | 'locator' | 'frame-locator';\nexport type Quote = '\\'' | '\"' | '`';\n\ntype LocatorOptions = {\n  attrs?: { name: string, value: string | boolean | number }[],\n  exact?: boolean,\n  name?: string | RegExp,\n  hasText?: string | RegExp,\n  hasNotText?: string | RegExp,\n};\nexport interface LocatorFactory {\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n  chainLocators(locators: string[]): string;\n}\n\nexport function asLocatorDescription(lang: Language, selector: string): string | undefined {\n  try {\n    const parsed = parseSelector(selector);\n    const lastPart = parsed.parts[parsed.parts.length - 1];\n    if (lastPart?.name === 'internal:describe') {\n      const description = JSON.parse(lastPart.body as string);\n      if (typeof description === 'string')\n        return description;\n    }\n    return innerAsLocators(new generators[lang](), parsed, false, 1)[0];\n  } catch (e) {\n    // Tolerate invalid input.\n    return selector;\n  }\n}\n\nexport function asLocator(lang: Language, selector: string, isFrameLocator: boolean = false): string {\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\n}\n\nexport function asLocators(lang: Language, selector: string, isFrameLocator: boolean = false, maxOutputSize = 20, preferredQuote?: Quote): string[] {\n  try {\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\n  } catch (e) {\n    // Tolerate invalid input.\n    return [selector];\n  }\n}\n\nfunction innerAsLocators(factory: LocatorFactory, parsed: ParsedSelector, isFrameLocator: boolean = false, maxOutputSize = 20): string[] {\n  const parts = [...parsed.parts];\n  const tokens: string[][] = [];\n  let nextBase: LocatorBase = isFrameLocator ? 'frame-locator' : 'page';\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = 'locator';\n\n    if (part.name === 'internal:describe')\n      continue;\n    if (part.name === 'nth') {\n      if (part.body === '0')\n        tokens.push([factory.generateLocator(base, 'first', ''), factory.generateLocator(base, 'nth', '0')]);\n      else if (part.body === '-1')\n        tokens.push([factory.generateLocator(base, 'last', ''), factory.generateLocator(base, 'nth', '-1')]);\n      else\n        tokens.push([factory.generateLocator(base, 'nth', part.body as string)]);\n      continue;\n    }\n    if (part.name === 'visible') {\n      tokens.push([factory.generateLocator(base, 'visible', part.body as string), factory.generateLocator(base, 'default', `visible=${part.body}`)]);\n      continue;\n    }\n    if (part.name === 'internal:text') {\n      const { exact, text } = detectExact(part.body as string);\n      tokens.push([factory.generateLocator(base, 'text', text, { exact })]);\n      continue;\n    }\n    if (part.name === 'internal:has-text') {\n      const { exact, text } = detectExact(part.body as string);\n      // There is no locator equivalent for strict has-text, leave it as is.\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, 'has-text', text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === 'internal:has-not-text') {\n      const { exact, text } = detectExact(part.body as string);\n      // There is no locator equivalent for strict has-not-text, leave it as is.\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, 'has-not-text', text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === 'internal:has') {\n      const inners = innerAsLocators(factory, (part.body as NestedSelectorBody).parsed, false, maxOutputSize);\n      tokens.push(inners.map(inner => factory.generateLocator(base, 'has', inner)));\n      continue;\n    }\n    if (part.name === 'internal:has-not') {\n      const inners = innerAsLocators(factory, (part.body as NestedSelectorBody).parsed, false, maxOutputSize);\n      tokens.push(inners.map(inner => factory.generateLocator(base, 'hasNot', inner)));\n      continue;\n    }\n    if (part.name === 'internal:and') {\n      const inners = innerAsLocators(factory, (part.body as NestedSelectorBody).parsed, false, maxOutputSize);\n      tokens.push(inners.map(inner => factory.generateLocator(base, 'and', inner)));\n      continue;\n    }\n    if (part.name === 'internal:or') {\n      const inners = innerAsLocators(factory, (part.body as NestedSelectorBody).parsed, false, maxOutputSize);\n      tokens.push(inners.map(inner => factory.generateLocator(base, 'or', inner)));\n      continue;\n    }\n    if (part.name === 'internal:chain') {\n      const inners = innerAsLocators(factory, (part.body as NestedSelectorBody).parsed, false, maxOutputSize);\n      tokens.push(inners.map(inner => factory.generateLocator(base, 'chain', inner)));\n      continue;\n    }\n    if (part.name === 'internal:label') {\n      const { exact, text } = detectExact(part.body as string);\n      tokens.push([factory.generateLocator(base, 'label', text, { exact })]);\n      continue;\n    }\n    if (part.name === 'internal:role') {\n      const attrSelector = parseAttributeSelector(part.body as string, true);\n      const options: LocatorOptions = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === 'name') {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === 'level' && typeof attr.value === 'string')\n            attr.value = +attr.value;\n          options.attrs!.push({ name: attr.name === 'include-hidden' ? 'includeHidden' : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, 'role', attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === 'internal:testid') {\n      const attrSelector = parseAttributeSelector(part.body as string, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, 'test-id', value)]);\n      continue;\n    }\n    if (part.name === 'internal:attr') {\n      const attrSelector = parseAttributeSelector(part.body as string, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value as string | RegExp;\n      const exact = !!caseSensitive;\n      if (name === 'placeholder') {\n        tokens.push([factory.generateLocator(base, 'placeholder', text, { exact })]);\n        continue;\n      }\n      if (name === 'alt') {\n        tokens.push([factory.generateLocator(base, 'alt', text, { exact })]);\n        continue;\n      }\n      if (name === 'title') {\n        tokens.push([factory.generateLocator(base, 'title', text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === 'internal:control' && (part.body as string) === 'enter-frame') {\n      // transform last tokens from `${selector}` into `${selector}.contentFrame()` and `frameLocator(${selector})`\n      const lastTokens = tokens[tokens.length - 1];\n      const lastPart = parts[index - 1];\n\n      const transformed = lastTokens.map(token => factory.chainLocators([token, factory.generateLocator(base, 'frame', '')]));\n      if (['xpath', 'css'].includes(lastPart.name)) {\n        transformed.push(\n            factory.generateLocator(base, 'frame-locator', stringifySelector({ parts: [lastPart] })),\n            factory.generateLocator(base, 'frame-locator', stringifySelector({ parts: [lastPart] }, true))\n        );\n      }\n\n      lastTokens.splice(0, lastTokens.length, ...transformed);\n      nextBase = 'frame-locator';\n      continue;\n    }\n\n    const nextPart = parts[index + 1];\n\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, 'default', selectorPart);\n\n    if (nextPart && ['internal:has-text', 'internal:has-not-text'].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body as string);\n      // There is no locator equivalent for strict has-text and has-not-text, leave it as is.\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator('locator', nextPart.name === 'internal:has-text' ? 'has-text' : 'has-not-text', text, { exact });\n        const options: LocatorOptions = {};\n        if (nextPart.name === 'internal:has-text')\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, 'default', selectorPart, options);\n        // Two options:\n        // - locator('div').filter({ hasText: 'foo' })\n        // - locator('div', { hasText: 'foo' })\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n\n    // Selectors can be prefixed with engine name, e.g. xpath=//foo\n    let locatorPartWithEngine: string | undefined;\n    if (['xpath', 'css'].includes(part.name)) {\n      const selectorPart = stringifySelector({ parts: [part] }, /* forceEngineName */ true);\n      locatorPartWithEngine = factory.generateLocator(base, 'default', selectorPart);\n    }\n\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean) as string[]);\n  }\n\n  return combineTokens(factory, tokens, maxOutputSize);\n}\n\nfunction combineTokens(factory: LocatorFactory, tokens: string[][], maxOutputSize: number): string[] {\n  const currentTokens = tokens.map(() => '');\n  const result: string[] = [];\n\n  const visit = (index: number) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return result.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n\n  visit(0);\n  return result;\n}\n\nfunction detectExact(text: string): { exact?: boolean, text: string | RegExp } {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith('\"')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith('\"s')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith('\"i')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\n\nexport class JavaScriptLocatorFactory implements LocatorFactory {\n  constructor(private preferredQuote?: Quote) {}\n\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options: LocatorOptions = {}): string {\n    switch (kind) {\n      case 'default':\n        if (options.hasText !== undefined)\n          return `locator(${this.quote(body as string)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== undefined)\n          return `locator(${this.quote(body as string)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body as string)})`;\n      case 'frame-locator':\n        return `frameLocator(${this.quote(body as string)})`;\n      case 'frame':\n        return `contentFrame()`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first()`;\n      case 'last':\n        return `last()`;\n      case 'visible':\n        return `filter({ visible: ${body === 'true' ? 'true' : 'false'} })`;\n      case 'role':\n        const attrs: string[] = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs!)\n          attrs.push(`${name}: ${typeof value === 'string' ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(', ')} }` : '';\n        return `getByRole(${this.quote(body as string)}${attrString})`;\n      case 'has-text':\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case 'has-not-text':\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case 'has':\n        return `filter({ has: ${body} })`;\n      case 'hasNot':\n        return `filter({ hasNot: ${body} })`;\n      case 'and':\n        return `and(${body})`;\n      case 'or':\n        return `or(${body})`;\n      case 'chain':\n        return `locator(${body})`;\n      case 'test-id':\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case 'text':\n        return this.toCallWithExact('getByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('getByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('getByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('getByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('getByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n\n  chainLocators(locators: string[]): string {\n    return locators.join('.');\n  }\n\n  private regexToSourceString(re: RegExp) {\n    return normalizeEscapedRegexQuotes(String(re));\n  }\n\n  private toCallWithExact(method: string, body: string | RegExp, exact?: boolean) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToSourceString(body)})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n\n  private toHasText(body: string | RegExp) {\n    if (isRegExp(body))\n      return this.regexToSourceString(body);\n    return this.quote(body);\n  }\n\n  private toTestIdValue(value: string | RegExp): string {\n    if (isRegExp(value))\n      return this.regexToSourceString(value);\n    return this.quote(value);\n  }\n\n  private quote(text: string) {\n    return escapeWithQuotes(text, this.preferredQuote ?? '\\'');\n  }\n}\n\nexport class PythonLocatorFactory implements LocatorFactory {\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options: LocatorOptions = {}): string {\n    switch (kind) {\n      case 'default':\n        if (options.hasText !== undefined)\n          return `locator(${this.quote(body as string)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== undefined)\n          return `locator(${this.quote(body as string)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body as string)})`;\n      case 'frame-locator':\n        return `frame_locator(${this.quote(body as string)})`;\n      case 'frame':\n        return `content_frame`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first`;\n      case 'last':\n        return `last`;\n      case 'visible':\n        return `filter(visible=${body === 'true' ? 'True' : 'False'})`;\n      case 'role':\n        const attrs: string[] = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs!) {\n          let valueString = typeof value === 'string' ? this.quote(value) : value;\n          if (typeof value === 'boolean')\n            valueString = value ? 'True' : 'False';\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(', ')}` : '';\n        return `get_by_role(${this.quote(body as string)}${attrString})`;\n      case 'has-text':\n        return `filter(has_text=${this.toHasText(body)})`;\n      case 'has-not-text':\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case 'has':\n        return `filter(has=${body})`;\n      case 'hasNot':\n        return `filter(has_not=${body})`;\n      case 'and':\n        return `and_(${body})`;\n      case 'or':\n        return `or_(${body})`;\n      case 'chain':\n        return `locator(${body})`;\n      case 'test-id':\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case 'text':\n        return this.toCallWithExact('get_by_text', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('get_by_alt_text', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('get_by_placeholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('get_by_label', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('get_by_title', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n\n  chainLocators(locators: string[]): string {\n    return locators.join('.');\n  }\n\n  private regexToString(body: RegExp) {\n    const suffix = body.flags.includes('i') ? ', re.IGNORECASE' : '';\n    return `re.compile(r\"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\//, '/').replace(/\"/g, '\\\\\"')}\"${suffix})`;\n  }\n\n  private toCallWithExact(method: string, body: string | RegExp, exact: boolean) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n\n  private toHasText(body: string | RegExp) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n\n  private toTestIdValue(value: string | RegExp) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n\n  private quote(text: string) {\n    return escapeWithQuotes(text, '\\\"');\n  }\n}\n\nexport class JavaLocatorFactory implements LocatorFactory {\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options: LocatorOptions = {}): string {\n    let clazz: string;\n    switch (base) {\n      case 'page': clazz = 'Page'; break;\n      case 'frame-locator': clazz = 'FrameLocator'; break;\n      case 'locator': clazz = 'Locator'; break;\n    }\n    switch (kind) {\n      case 'default':\n        if (options.hasText !== undefined)\n          return `locator(${this.quote(body as string)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== undefined)\n          return `locator(${this.quote(body as string)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body as string)})`;\n      case 'frame-locator':\n        return `frameLocator(${this.quote(body as string)})`;\n      case 'frame':\n        return `contentFrame()`;\n      case 'nth':\n        return `nth(${body})`;\n      case 'first':\n        return `first()`;\n      case 'last':\n        return `last()`;\n      case 'visible':\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === 'true' ? 'true' : 'false'}))`;\n      case 'role':\n        const attrs: string[] = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs!)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === 'string' ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join('')}` : '';\n        return `getByRole(AriaRole.${toSnakeCase(body as string).toUpperCase()}${attrString})`;\n      case 'has-text':\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case 'has-not-text':\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case 'has':\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case 'hasNot':\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case 'and':\n        return `and(${body})`;\n      case 'or':\n        return `or(${body})`;\n      case 'chain':\n        return `locator(${body})`;\n      case 'test-id':\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case 'text':\n        return this.toCallWithExact(clazz, 'getByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact(clazz, 'getByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact(clazz, 'getByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact(clazz, 'getByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact(clazz, 'getByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n\n  chainLocators(locators: string[]): string {\n    return locators.join('.');\n  }\n\n  private regexToString(body: RegExp) {\n    const suffix = body.flags.includes('i') ? ', Pattern.CASE_INSENSITIVE' : '';\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n\n  private toCallWithExact(clazz: string, method: string, body: string | RegExp, exact: boolean) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n\n  private toHasText(body: string | RegExp) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n\n  private toTestIdValue(value: string | RegExp) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n\n  private quote(text: string) {\n    return escapeWithQuotes(text, '\\\"');\n  }\n}\n\nexport class CSharpLocatorFactory implements LocatorFactory {\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options: LocatorOptions = {}): string {\n    switch (kind) {\n      case 'default':\n        if (options.hasText !== undefined)\n          return `Locator(${this.quote(body as string)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== undefined)\n          return `Locator(${this.quote(body as string)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body as string)})`;\n      case 'frame-locator':\n        return `FrameLocator(${this.quote(body as string)})`;\n      case 'frame':\n        return `ContentFrame`;\n      case 'nth':\n        return `Nth(${body})`;\n      case 'first':\n        return `First`;\n      case 'last':\n        return `Last`;\n      case 'visible':\n        return `Filter(new() { Visible = ${body === 'true' ? 'true' : 'false'} })`;\n      case 'role':\n        const attrs: string[] = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === 'string') {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs!)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === 'string' ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(', ')} }` : '';\n        return `GetByRole(AriaRole.${toTitleCase(body as string)}${attrString})`;\n      case 'has-text':\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case 'has-not-text':\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case 'has':\n        return `Filter(new() { Has = ${body} })`;\n      case 'hasNot':\n        return `Filter(new() { HasNot = ${body} })`;\n      case 'and':\n        return `And(${body})`;\n      case 'or':\n        return `Or(${body})`;\n      case 'chain':\n        return `Locator(${body})`;\n      case 'test-id':\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case 'text':\n        return this.toCallWithExact('GetByText', body, !!options.exact);\n      case 'alt':\n        return this.toCallWithExact('GetByAltText', body, !!options.exact);\n      case 'placeholder':\n        return this.toCallWithExact('GetByPlaceholder', body, !!options.exact);\n      case 'label':\n        return this.toCallWithExact('GetByLabel', body, !!options.exact);\n      case 'title':\n        return this.toCallWithExact('GetByTitle', body, !!options.exact);\n      default:\n        throw new Error('Unknown selector kind ' + kind);\n    }\n  }\n\n  chainLocators(locators: string[]): string {\n    return locators.join('.');\n  }\n\n  private regexToString(body: RegExp): string {\n    const suffix = body.flags.includes('i') ? ', RegexOptions.IgnoreCase' : '';\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n\n  private toCallWithExact(method: string, body: string | RegExp, exact: boolean) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n\n  private toHasText(body: string | RegExp) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n\n  private toTestIdValue(value: string | RegExp) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n\n  private toHasNotText(body: string | RegExp) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n\n  private quote(text: string) {\n    return escapeWithQuotes(text, '\\\"');\n  }\n}\n\nexport class JsonlLocatorFactory implements LocatorFactory {\n  generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options: LocatorOptions = {}): string {\n    return JSON.stringify({\n      kind,\n      body,\n      options,\n    });\n  }\n\n  chainLocators(locators: string[]): string {\n    const objects = locators.map(l => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n}\n\nconst generators: Record<Language, new (preferredQuote?: Quote) => LocatorFactory> = {\n  javascript: JavaScriptLocatorFactory,\n  python: PythonLocatorFactory,\n  java: JavaLocatorFactory,\n  csharp: CSharpLocatorFactory,\n  jsonl: JsonlLocatorFactory,\n};\n\nfunction isRegExp(obj: any): obj is RegExp {\n  return obj instanceof RegExp;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,4BAA0E;AAC1E,yBAAwF;AAsBjF,SAAS,qBAAqB,MAAgB,UAAsC;AACzF,MAAI;AACF,UAAM,aAAS,qCAAc,QAAQ;AACrC,UAAM,WAAW,OAAO,MAAM,OAAO,MAAM,SAAS,CAAC;AACrD,QAAI,UAAU,SAAS,qBAAqB;AAC1C,YAAM,cAAc,KAAK,MAAM,SAAS,IAAc;AACtD,UAAI,OAAO,gBAAgB;AACzB,eAAO;AAAA,IACX;AACA,WAAO,gBAAgB,IAAI,WAAW,IAAI,EAAE,GAAG,QAAQ,OAAO,CAAC,EAAE,CAAC;AAAA,EACpE,SAAS,GAAG;AAEV,WAAO;AAAA,EACT;AACF;AAEO,SAAS,UAAU,MAAgB,UAAkB,iBAA0B,OAAe;AACnG,SAAO,WAAW,MAAM,UAAU,gBAAgB,CAAC,EAAE,CAAC;AACxD;AAEO,SAAS,WAAW,MAAgB,UAAkB,iBAA0B,OAAO,gBAAgB,IAAI,gBAAkC;AAClJ,MAAI;AACF,WAAO,gBAAgB,IAAI,WAAW,IAAI,EAAE,cAAc,OAAG,qCAAc,QAAQ,GAAG,gBAAgB,aAAa;AAAA,EACrH,SAAS,GAAG;AAEV,WAAO,CAAC,QAAQ;AAAA,EAClB;AACF;AAEA,SAAS,gBAAgB,SAAyB,QAAwB,iBAA0B,OAAO,gBAAgB,IAAc;AACvI,QAAM,QAAQ,CAAC,GAAG,OAAO,KAAK;AAC9B,QAAM,SAAqB,CAAC;AAC5B,MAAI,WAAwB,iBAAiB,kBAAkB;AAC/D,WAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,UAAM,OAAO,MAAM,KAAK;AACxB,UAAM,OAAO;AACb,eAAW;AAEX,QAAI,KAAK,SAAS;AAChB;AACF,QAAI,KAAK,SAAS,OAAO;AACvB,UAAI,KAAK,SAAS;AAChB,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,SAAS,EAAE,GAAG,QAAQ,gBAAgB,MAAM,OAAO,GAAG,CAAC,CAAC;AAAA,eAC5F,KAAK,SAAS;AACrB,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,QAAQ,EAAE,GAAG,QAAQ,gBAAgB,MAAM,OAAO,IAAI,CAAC,CAAC;AAAA;AAEnG,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,OAAO,KAAK,IAAc,CAAC,CAAC;AACzE;AAAA,IACF;AACA,QAAI,KAAK,SAAS,WAAW;AAC3B,aAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,WAAW,KAAK,IAAc,GAAG,QAAQ,gBAAgB,MAAM,WAAW,WAAW,KAAK,IAAI,EAAE,CAAC,CAAC;AAC7I;AAAA,IACF;AACA,QAAI,KAAK,SAAS,iBAAiB;AACjC,YAAM,EAAE,OAAO,KAAK,IAAI,YAAY,KAAK,IAAc;AACvD,aAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,QAAQ,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AACpE;AAAA,IACF;AACA,QAAI,KAAK,SAAS,qBAAqB;AACrC,YAAM,EAAE,OAAO,KAAK,IAAI,YAAY,KAAK,IAAc;AAEvD,UAAI,CAAC,OAAO;AACV,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,YAAY,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AACxE;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,SAAS,yBAAyB;AACzC,YAAM,EAAE,OAAO,KAAK,IAAI,YAAY,KAAK,IAAc;AAEvD,UAAI,CAAC,OAAO;AACV,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,gBAAgB,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AAC5E;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,SAAS,gBAAgB;AAChC,YAAM,SAAS,gBAAgB,SAAU,KAAK,KAA4B,QAAQ,OAAO,aAAa;AACtG,aAAO,KAAK,OAAO,IAAI,WAAS,QAAQ,gBAAgB,MAAM,OAAO,KAAK,CAAC,CAAC;AAC5E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,oBAAoB;AACpC,YAAM,SAAS,gBAAgB,SAAU,KAAK,KAA4B,QAAQ,OAAO,aAAa;AACtG,aAAO,KAAK,OAAO,IAAI,WAAS,QAAQ,gBAAgB,MAAM,UAAU,KAAK,CAAC,CAAC;AAC/E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,gBAAgB;AAChC,YAAM,SAAS,gBAAgB,SAAU,KAAK,KAA4B,QAAQ,OAAO,aAAa;AACtG,aAAO,KAAK,OAAO,IAAI,WAAS,QAAQ,gBAAgB,MAAM,OAAO,KAAK,CAAC,CAAC;AAC5E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,eAAe;AAC/B,YAAM,SAAS,gBAAgB,SAAU,KAAK,KAA4B,QAAQ,OAAO,aAAa;AACtG,aAAO,KAAK,OAAO,IAAI,WAAS,QAAQ,gBAAgB,MAAM,MAAM,KAAK,CAAC,CAAC;AAC3E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,kBAAkB;AAClC,YAAM,SAAS,gBAAgB,SAAU,KAAK,KAA4B,QAAQ,OAAO,aAAa;AACtG,aAAO,KAAK,OAAO,IAAI,WAAS,QAAQ,gBAAgB,MAAM,SAAS,KAAK,CAAC,CAAC;AAC9E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,kBAAkB;AAClC,YAAM,EAAE,OAAO,KAAK,IAAI,YAAY,KAAK,IAAc;AACvD,aAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,SAAS,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AACrE;AAAA,IACF;AACA,QAAI,KAAK,SAAS,iBAAiB;AACjC,YAAM,mBAAe,8CAAuB,KAAK,MAAgB,IAAI;AACrE,YAAM,UAA0B,EAAE,OAAO,CAAC,EAAE;AAC5C,iBAAW,QAAQ,aAAa,YAAY;AAC1C,YAAI,KAAK,SAAS,QAAQ;AACxB,kBAAQ,QAAQ,KAAK;AACrB,kBAAQ,OAAO,KAAK;AAAA,QACtB,OAAO;AACL,cAAI,KAAK,SAAS,WAAW,OAAO,KAAK,UAAU;AACjD,iBAAK,QAAQ,CAAC,KAAK;AACrB,kBAAQ,MAAO,KAAK,EAAE,MAAM,KAAK,SAAS,mBAAmB,kBAAkB,KAAK,MAAM,OAAO,KAAK,MAAM,CAAC;AAAA,QAC/G;AAAA,MACF;AACA,aAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,QAAQ,aAAa,MAAM,OAAO,CAAC,CAAC;AAC/E;AAAA,IACF;AACA,QAAI,KAAK,SAAS,mBAAmB;AACnC,YAAM,mBAAe,8CAAuB,KAAK,MAAgB,IAAI;AACrE,YAAM,EAAE,MAAM,IAAI,aAAa,WAAW,CAAC;AAC3C,aAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,WAAW,KAAK,CAAC,CAAC;AAC7D;AAAA,IACF;AACA,QAAI,KAAK,SAAS,iBAAiB;AACjC,YAAM,mBAAe,8CAAuB,KAAK,MAAgB,IAAI;AACrE,YAAM,EAAE,MAAM,OAAO,cAAc,IAAI,aAAa,WAAW,CAAC;AAChE,YAAM,OAAO;AACb,YAAM,QAAQ,CAAC,CAAC;AAChB,UAAI,SAAS,eAAe;AAC1B,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,eAAe,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AAC3E;AAAA,MACF;AACA,UAAI,SAAS,OAAO;AAClB,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,OAAO,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AACnE;AAAA,MACF;AACA,UAAI,SAAS,SAAS;AACpB,eAAO,KAAK,CAAC,QAAQ,gBAAgB,MAAM,SAAS,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;AACrE;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,SAAS,sBAAuB,KAAK,SAAoB,eAAe;AAE/E,YAAM,aAAa,OAAO,OAAO,SAAS,CAAC;AAC3C,YAAM,WAAW,MAAM,QAAQ,CAAC;AAEhC,YAAM,cAAc,WAAW,IAAI,WAAS,QAAQ,cAAc,CAAC,OAAO,QAAQ,gBAAgB,MAAM,SAAS,EAAE,CAAC,CAAC,CAAC;AACtH,UAAI,CAAC,SAAS,KAAK,EAAE,SAAS,SAAS,IAAI,GAAG;AAC5C,oBAAY;AAAA,UACR,QAAQ,gBAAgB,MAAM,qBAAiB,yCAAkB,EAAE,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;AAAA,UACvF,QAAQ,gBAAgB,MAAM,qBAAiB,yCAAkB,EAAE,OAAO,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC;AAAA,QACjG;AAAA,MACF;AAEA,iBAAW,OAAO,GAAG,WAAW,QAAQ,GAAG,WAAW;AACtD,iBAAW;AACX;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,QAAQ,CAAC;AAEhC,UAAM,mBAAe,yCAAkB,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC;AACxD,UAAM,cAAc,QAAQ,gBAAgB,MAAM,WAAW,YAAY;AAEzE,QAAI,YAAY,CAAC,qBAAqB,uBAAuB,EAAE,SAAS,SAAS,IAAI,GAAG;AACtF,YAAM,EAAE,OAAO,KAAK,IAAI,YAAY,SAAS,IAAc;AAE3D,UAAI,CAAC,OAAO;AACV,cAAM,kBAAkB,QAAQ,gBAAgB,WAAW,SAAS,SAAS,sBAAsB,aAAa,gBAAgB,MAAM,EAAE,MAAM,CAAC;AAC/I,cAAM,UAA0B,CAAC;AACjC,YAAI,SAAS,SAAS;AACpB,kBAAQ,UAAU;AAAA;AAElB,kBAAQ,aAAa;AACvB,cAAM,eAAe,QAAQ,gBAAgB,MAAM,WAAW,cAAc,OAAO;AAInF,eAAO,KAAK,CAAC,QAAQ,cAAc,CAAC,aAAa,eAAe,CAAC,GAAG,YAAY,CAAC;AACjF;AACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI;AACJ,QAAI,CAAC,SAAS,KAAK,EAAE,SAAS,KAAK,IAAI,GAAG;AACxC,YAAMA,oBAAe;AAAA,QAAkB,EAAE,OAAO,CAAC,IAAI,EAAE;AAAA;AAAA,QAAyB;AAAA,MAAI;AACpF,8BAAwB,QAAQ,gBAAgB,MAAM,WAAWA,aAAY;AAAA,IAC/E;AAEA,WAAO,KAAK,CAAC,aAAa,qBAAqB,EAAE,OAAO,OAAO,CAAa;AAAA,EAC9E;AAEA,SAAO,cAAc,SAAS,QAAQ,aAAa;AACrD;AAEA,SAAS,cAAc,SAAyB,QAAoB,eAAiC;AACnG,QAAM,gBAAgB,OAAO,IAAI,MAAM,EAAE;AACzC,QAAM,SAAmB,CAAC;AAE1B,QAAM,QAAQ,CAAC,UAAkB;AAC/B,QAAI,UAAU,OAAO,QAAQ;AAC3B,aAAO,KAAK,QAAQ,cAAc,aAAa,CAAC;AAChD,aAAO,OAAO,SAAS;AAAA,IACzB;AACA,eAAW,SAAS,OAAO,KAAK,GAAG;AACjC,oBAAc,KAAK,IAAI;AACvB,UAAI,CAAC,MAAM,QAAQ,CAAC;AAClB,eAAO;AAAA,IACX;AACA,WAAO;AAAA,EACT;AAEA,QAAM,CAAC;AACP,SAAO;AACT;AAEA,SAAS,YAAY,MAA0D;AAC7E,MAAI,QAAQ;AACZ,QAAM,QAAQ,KAAK,MAAM,oBAAoB;AAC7C,MAAI;AACF,WAAO,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,EAAE;AAChD,MAAI,KAAK,SAAS,GAAG,GAAG;AACtB,WAAO,KAAK,MAAM,IAAI;AACtB,YAAQ;AAAA,EACV,WAAW,KAAK,SAAS,IAAI,GAAG;AAC9B,WAAO,KAAK,MAAM,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC,CAAC;AACpD,YAAQ;AAAA,EACV,WAAW,KAAK,SAAS,IAAI,GAAG;AAC9B,WAAO,KAAK,MAAM,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC,CAAC;AACpD,YAAQ;AAAA,EACV;AACA,SAAO,EAAE,OAAO,KAAK;AACvB;AAEO,MAAM,yBAAmD;AAAA,EAC9D,YAAoB,gBAAwB;AAAxB;AAAA,EAAyB;AAAA,EAE7C,gBAAgB,MAAmB,MAAmB,MAAuB,UAA0B,CAAC,GAAW;AACjH,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,YAAI,QAAQ,YAAY;AACtB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,gBAAgB,KAAK,UAAU,QAAQ,OAAO,CAAC;AAC7F,YAAI,QAAQ,eAAe;AACzB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,mBAAmB,KAAK,UAAU,QAAQ,UAAU,CAAC;AACnG,eAAO,WAAW,KAAK,MAAM,IAAc,CAAC;AAAA,MAC9C,KAAK;AACH,eAAO,gBAAgB,KAAK,MAAM,IAAc,CAAC;AAAA,MACnD,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,qBAAqB,SAAS,SAAS,SAAS,OAAO;AAAA,MAChE,KAAK;AACH,cAAM,QAAkB,CAAC;AACzB,YAAI,SAAS,QAAQ,IAAI,GAAG;AAC1B,gBAAM,KAAK,SAAS,KAAK,oBAAoB,QAAQ,IAAI,CAAC,EAAE;AAAA,QAC9D,WAAW,OAAO,QAAQ,SAAS,UAAU;AAC3C,gBAAM,KAAK,SAAS,KAAK,MAAM,QAAQ,IAAI,CAAC,EAAE;AAC9C,cAAI,QAAQ;AACV,kBAAM,KAAK,aAAa;AAAA,QAC5B;AACA,mBAAW,EAAE,MAAM,MAAM,KAAK,QAAQ;AACpC,gBAAM,KAAK,GAAG,IAAI,KAAK,OAAO,UAAU,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAChF,cAAM,aAAa,MAAM,SAAS,OAAO,MAAM,KAAK,IAAI,CAAC,OAAO;AAChE,eAAO,aAAa,KAAK,MAAM,IAAc,CAAC,GAAG,UAAU;AAAA,MAC7D,KAAK;AACH,eAAO,qBAAqB,KAAK,UAAU,IAAI,CAAC;AAAA,MAClD,KAAK;AACH,eAAO,wBAAwB,KAAK,UAAU,IAAI,CAAC;AAAA,MACrD,KAAK;AACH,eAAO,iBAAiB,IAAI;AAAA,MAC9B,KAAK;AACH,eAAO,oBAAoB,IAAI;AAAA,MACjC,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO,MAAM,IAAI;AAAA,MACnB,KAAK;AACH,eAAO,WAAW,IAAI;AAAA,MACxB,KAAK;AACH,eAAO,eAAe,KAAK,cAAc,IAAI,CAAC;AAAA,MAChD,KAAK;AACH,eAAO,KAAK,gBAAgB,aAAa,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MAChE,KAAK;AACH,eAAO,KAAK,gBAAgB,gBAAgB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACnE,KAAK;AACH,eAAO,KAAK,gBAAgB,oBAAoB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACvE,KAAK;AACH,eAAO,KAAK,gBAAgB,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACjE,KAAK;AACH,eAAO,KAAK,gBAAgB,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACjE;AACE,cAAM,IAAI,MAAM,2BAA2B,IAAI;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,cAAc,UAA4B;AACxC,WAAO,SAAS,KAAK,GAAG;AAAA,EAC1B;AAAA,EAEQ,oBAAoB,IAAY;AACtC,eAAO,gDAA4B,OAAO,EAAE,CAAC;AAAA,EAC/C;AAAA,EAEQ,gBAAgB,QAAgB,MAAuB,OAAiB;AAC9E,QAAI,SAAS,IAAI;AACf,aAAO,GAAG,MAAM,IAAI,KAAK,oBAAoB,IAAI,CAAC;AACpD,WAAO,QAAQ,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC,uBAAuB,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EAClG;AAAA,EAEQ,UAAU,MAAuB;AACvC,QAAI,SAAS,IAAI;AACf,aAAO,KAAK,oBAAoB,IAAI;AACtC,WAAO,KAAK,MAAM,IAAI;AAAA,EACxB;AAAA,EAEQ,cAAc,OAAgC;AACpD,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,oBAAoB,KAAK;AACvC,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA,EAEQ,MAAM,MAAc;AAC1B,eAAO,qCAAiB,MAAM,KAAK,kBAAkB,GAAI;AAAA,EAC3D;AACF;AAEO,MAAM,qBAA+C;AAAA,EAC1D,gBAAgB,MAAmB,MAAmB,MAAuB,UAA0B,CAAC,GAAW;AACjH,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,YAAI,QAAQ,YAAY;AACtB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,cAAc,KAAK,UAAU,QAAQ,OAAO,CAAC;AAC3F,YAAI,QAAQ,eAAe;AACzB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,kBAAkB,KAAK,UAAU,QAAQ,UAAU,CAAC;AAClG,eAAO,WAAW,KAAK,MAAM,IAAc,CAAC;AAAA,MAC9C,KAAK;AACH,eAAO,iBAAiB,KAAK,MAAM,IAAc,CAAC;AAAA,MACpD,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,kBAAkB,SAAS,SAAS,SAAS,OAAO;AAAA,MAC7D,KAAK;AACH,cAAM,QAAkB,CAAC;AACzB,YAAI,SAAS,QAAQ,IAAI,GAAG;AAC1B,gBAAM,KAAK,QAAQ,KAAK,cAAc,QAAQ,IAAI,CAAC,EAAE;AAAA,QACvD,WAAW,OAAO,QAAQ,SAAS,UAAU;AAC3C,gBAAM,KAAK,QAAQ,KAAK,MAAM,QAAQ,IAAI,CAAC,EAAE;AAC7C,cAAI,QAAQ;AACV,kBAAM,KAAK,YAAY;AAAA,QAC3B;AACA,mBAAW,EAAE,MAAM,MAAM,KAAK,QAAQ,OAAQ;AAC5C,cAAI,cAAc,OAAO,UAAU,WAAW,KAAK,MAAM,KAAK,IAAI;AAClE,cAAI,OAAO,UAAU;AACnB,0BAAc,QAAQ,SAAS;AACjC,gBAAM,KAAK,OAAG,gCAAY,IAAI,CAAC,IAAI,WAAW,EAAE;AAAA,QAClD;AACA,cAAM,aAAa,MAAM,SAAS,KAAK,MAAM,KAAK,IAAI,CAAC,KAAK;AAC5D,eAAO,eAAe,KAAK,MAAM,IAAc,CAAC,GAAG,UAAU;AAAA,MAC/D,KAAK;AACH,eAAO,mBAAmB,KAAK,UAAU,IAAI,CAAC;AAAA,MAChD,KAAK;AACH,eAAO,uBAAuB,KAAK,UAAU,IAAI,CAAC;AAAA,MACpD,KAAK;AACH,eAAO,cAAc,IAAI;AAAA,MAC3B,KAAK;AACH,eAAO,kBAAkB,IAAI;AAAA,MAC/B,KAAK;AACH,eAAO,QAAQ,IAAI;AAAA,MACrB,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO,WAAW,IAAI;AAAA,MACxB,KAAK;AACH,eAAO,kBAAkB,KAAK,cAAc,IAAI,CAAC;AAAA,MACnD,KAAK;AACH,eAAO,KAAK,gBAAgB,eAAe,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MAClE,KAAK;AACH,eAAO,KAAK,gBAAgB,mBAAmB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACtE,KAAK;AACH,eAAO,KAAK,gBAAgB,sBAAsB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACzE,KAAK;AACH,eAAO,KAAK,gBAAgB,gBAAgB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACnE,KAAK;AACH,eAAO,KAAK,gBAAgB,gBAAgB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACnE;AACE,cAAM,IAAI,MAAM,2BAA2B,IAAI;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,cAAc,UAA4B;AACxC,WAAO,SAAS,KAAK,GAAG;AAAA,EAC1B;AAAA,EAEQ,cAAc,MAAc;AAClC,UAAM,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,oBAAoB;AAC9D,WAAO,oBAAgB,gDAA4B,KAAK,MAAM,EAAE,QAAQ,QAAQ,GAAG,EAAE,QAAQ,MAAM,KAAK,CAAC,IAAI,MAAM;AAAA,EACrH;AAAA,EAEQ,gBAAgB,QAAgB,MAAuB,OAAgB;AAC7E,QAAI,SAAS,IAAI;AACf,aAAO,GAAG,MAAM,IAAI,KAAK,cAAc,IAAI,CAAC;AAC9C,QAAI;AACF,aAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AACtC,WAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EACtC;AAAA,EAEQ,UAAU,MAAuB;AACvC,QAAI,SAAS,IAAI;AACf,aAAO,KAAK,cAAc,IAAI;AAChC,WAAO,GAAG,KAAK,MAAM,IAAI,CAAC;AAAA,EAC5B;AAAA,EAEQ,cAAc,OAAwB;AAC5C,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,cAAc,KAAK;AACjC,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA,EAEQ,MAAM,MAAc;AAC1B,eAAO,qCAAiB,MAAM,GAAI;AAAA,EACpC;AACF;AAEO,MAAM,mBAA6C;AAAA,EACxD,gBAAgB,MAAmB,MAAmB,MAAuB,UAA0B,CAAC,GAAW;AACjH,QAAI;AACJ,YAAQ,MAAM;AAAA,MACZ,KAAK;AAAQ,gBAAQ;AAAQ;AAAA,MAC7B,KAAK;AAAiB,gBAAQ;AAAgB;AAAA,MAC9C,KAAK;AAAW,gBAAQ;AAAW;AAAA,IACrC;AACA,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,YAAI,QAAQ,YAAY;AACtB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,SAAS,KAAK,gCAAgC,KAAK,UAAU,QAAQ,OAAO,CAAC;AAC3H,YAAI,QAAQ,eAAe;AACzB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,SAAS,KAAK,mCAAmC,KAAK,UAAU,QAAQ,UAAU,CAAC;AACjI,eAAO,WAAW,KAAK,MAAM,IAAc,CAAC;AAAA,MAC9C,KAAK;AACH,eAAO,gBAAgB,KAAK,MAAM,IAAc,CAAC;AAAA,MACnD,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,cAAc,KAAK,+BAA+B,SAAS,SAAS,SAAS,OAAO;AAAA,MAC7F,KAAK;AACH,cAAM,QAAkB,CAAC;AACzB,YAAI,SAAS,QAAQ,IAAI,GAAG;AAC1B,gBAAM,KAAK,YAAY,KAAK,cAAc,QAAQ,IAAI,CAAC,GAAG;AAAA,QAC5D,WAAW,OAAO,QAAQ,SAAS,UAAU;AAC3C,gBAAM,KAAK,YAAY,KAAK,MAAM,QAAQ,IAAI,CAAC,GAAG;AAClD,cAAI,QAAQ;AACV,kBAAM,KAAK,iBAAiB;AAAA,QAChC;AACA,mBAAW,EAAE,MAAM,MAAM,KAAK,QAAQ;AACpC,gBAAM,KAAK,WAAO,gCAAY,IAAI,CAAC,IAAI,OAAO,UAAU,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,GAAG;AACjG,cAAM,aAAa,MAAM,SAAS,SAAS,KAAK,sBAAsB,MAAM,KAAK,EAAE,CAAC,KAAK;AACzF,eAAO,0BAAsB,gCAAY,IAAc,EAAE,YAAY,CAAC,GAAG,UAAU;AAAA,MACrF,KAAK;AACH,eAAO,cAAc,KAAK,+BAA+B,KAAK,UAAU,IAAI,CAAC;AAAA,MAC/E,KAAK;AACH,eAAO,cAAc,KAAK,kCAAkC,KAAK,UAAU,IAAI,CAAC;AAAA,MAClF,KAAK;AACH,eAAO,cAAc,KAAK,2BAA2B,IAAI;AAAA,MAC3D,KAAK;AACH,eAAO,cAAc,KAAK,8BAA8B,IAAI;AAAA,MAC9D,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO,MAAM,IAAI;AAAA,MACnB,KAAK;AACH,eAAO,WAAW,IAAI;AAAA,MACxB,KAAK;AACH,eAAO,eAAe,KAAK,cAAc,IAAI,CAAC;AAAA,MAChD,KAAK;AACH,eAAO,KAAK,gBAAgB,OAAO,aAAa,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACvE,KAAK;AACH,eAAO,KAAK,gBAAgB,OAAO,gBAAgB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MAC1E,KAAK;AACH,eAAO,KAAK,gBAAgB,OAAO,oBAAoB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MAC9E,KAAK;AACH,eAAO,KAAK,gBAAgB,OAAO,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACxE,KAAK;AACH,eAAO,KAAK,gBAAgB,OAAO,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACxE;AACE,cAAM,IAAI,MAAM,2BAA2B,IAAI;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,cAAc,UAA4B;AACxC,WAAO,SAAS,KAAK,GAAG;AAAA,EAC1B;AAAA,EAEQ,cAAc,MAAc;AAClC,UAAM,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,+BAA+B;AACzE,WAAO,mBAAmB,KAAK,UAAM,gDAA4B,KAAK,MAAM,CAAC,CAAC,GAAG,MAAM;AAAA,EACzF;AAAA,EAEQ,gBAAgB,OAAe,QAAgB,MAAuB,OAAgB;AAC5F,QAAI,SAAS,IAAI;AACf,aAAO,GAAG,MAAM,IAAI,KAAK,cAAc,IAAI,CAAC;AAC9C,QAAI;AACF,aAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC,SAAS,KAAK,QAAI,gCAAY,MAAM,CAAC;AAC3E,WAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EACtC;AAAA,EAEQ,UAAU,MAAuB;AACvC,QAAI,SAAS,IAAI;AACf,aAAO,KAAK,cAAc,IAAI;AAChC,WAAO,KAAK,MAAM,IAAI;AAAA,EACxB;AAAA,EAEQ,cAAc,OAAwB;AAC5C,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,cAAc,KAAK;AACjC,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA,EAEQ,MAAM,MAAc;AAC1B,eAAO,qCAAiB,MAAM,GAAI;AAAA,EACpC;AACF;AAEO,MAAM,qBAA+C;AAAA,EAC1D,gBAAgB,MAAmB,MAAmB,MAAuB,UAA0B,CAAC,GAAW;AACjH,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,YAAI,QAAQ,YAAY;AACtB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,aAAa,KAAK,UAAU,QAAQ,OAAO,CAAC;AAC1F,YAAI,QAAQ,eAAe;AACzB,iBAAO,WAAW,KAAK,MAAM,IAAc,CAAC,aAAa,KAAK,aAAa,QAAQ,UAAU,CAAC;AAChG,eAAO,WAAW,KAAK,MAAM,IAAc,CAAC;AAAA,MAC9C,KAAK;AACH,eAAO,gBAAgB,KAAK,MAAM,IAAc,CAAC;AAAA,MACnD,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,4BAA4B,SAAS,SAAS,SAAS,OAAO;AAAA,MACvE,KAAK;AACH,cAAM,QAAkB,CAAC;AACzB,YAAI,SAAS,QAAQ,IAAI,GAAG;AAC1B,gBAAM,KAAK,eAAe,KAAK,cAAc,QAAQ,IAAI,CAAC,EAAE;AAAA,QAC9D,WAAW,OAAO,QAAQ,SAAS,UAAU;AAC3C,gBAAM,KAAK,UAAU,KAAK,MAAM,QAAQ,IAAI,CAAC,EAAE;AAC/C,cAAI,QAAQ;AACV,kBAAM,KAAK,cAAc;AAAA,QAC7B;AACA,mBAAW,EAAE,MAAM,MAAM,KAAK,QAAQ;AACpC,gBAAM,KAAK,OAAG,gCAAY,IAAI,CAAC,MAAM,OAAO,UAAU,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAC9F,cAAM,aAAa,MAAM,SAAS,aAAa,MAAM,KAAK,IAAI,CAAC,OAAO;AACtE,eAAO,0BAAsB,gCAAY,IAAc,CAAC,GAAG,UAAU;AAAA,MACvE,KAAK;AACH,eAAO,kBAAkB,KAAK,UAAU,IAAI,CAAC;AAAA,MAC/C,KAAK;AACH,eAAO,kBAAkB,KAAK,aAAa,IAAI,CAAC;AAAA,MAClD,KAAK;AACH,eAAO,wBAAwB,IAAI;AAAA,MACrC,KAAK;AACH,eAAO,2BAA2B,IAAI;AAAA,MACxC,KAAK;AACH,eAAO,OAAO,IAAI;AAAA,MACpB,KAAK;AACH,eAAO,MAAM,IAAI;AAAA,MACnB,KAAK;AACH,eAAO,WAAW,IAAI;AAAA,MACxB,KAAK;AACH,eAAO,eAAe,KAAK,cAAc,IAAI,CAAC;AAAA,MAChD,KAAK;AACH,eAAO,KAAK,gBAAgB,aAAa,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MAChE,KAAK;AACH,eAAO,KAAK,gBAAgB,gBAAgB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACnE,KAAK;AACH,eAAO,KAAK,gBAAgB,oBAAoB,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACvE,KAAK;AACH,eAAO,KAAK,gBAAgB,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACjE,KAAK;AACH,eAAO,KAAK,gBAAgB,cAAc,MAAM,CAAC,CAAC,QAAQ,KAAK;AAAA,MACjE;AACE,cAAM,IAAI,MAAM,2BAA2B,IAAI;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,cAAc,UAA4B;AACxC,WAAO,SAAS,KAAK,GAAG;AAAA,EAC1B;AAAA,EAEQ,cAAc,MAAsB;AAC1C,UAAM,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,8BAA8B;AACxE,WAAO,aAAa,KAAK,UAAM,gDAA4B,KAAK,MAAM,CAAC,CAAC,GAAG,MAAM;AAAA,EACnF;AAAA,EAEQ,gBAAgB,QAAgB,MAAuB,OAAgB;AAC7E,QAAI,SAAS,IAAI;AACf,aAAO,GAAG,MAAM,IAAI,KAAK,cAAc,IAAI,CAAC;AAC9C,QAAI;AACF,aAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AACtC,WAAO,GAAG,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EACtC;AAAA,EAEQ,UAAU,MAAuB;AACvC,QAAI,SAAS,IAAI;AACf,aAAO,kBAAkB,KAAK,cAAc,IAAI,CAAC;AACnD,WAAO,aAAa,KAAK,MAAM,IAAI,CAAC;AAAA,EACtC;AAAA,EAEQ,cAAc,OAAwB;AAC5C,QAAI,SAAS,KAAK;AAChB,aAAO,KAAK,cAAc,KAAK;AACjC,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA,EAEQ,aAAa,MAAuB;AAC1C,QAAI,SAAS,IAAI;AACf,aAAO,qBAAqB,KAAK,cAAc,IAAI,CAAC;AACtD,WAAO,gBAAgB,KAAK,MAAM,IAAI,CAAC;AAAA,EACzC;AAAA,EAEQ,MAAM,MAAc;AAC1B,eAAO,qCAAiB,MAAM,GAAI;AAAA,EACpC;AACF;AAEO,MAAM,oBAA8C;AAAA,EACzD,gBAAgB,MAAmB,MAAmB,MAAuB,UAA0B,CAAC,GAAW;AACjH,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,cAAc,UAA4B;AACxC,UAAM,UAAU,SAAS,IAAI,OAAK,KAAK,MAAM,CAAC,CAAC;AAC/C,aAAS,IAAI,GAAG,IAAI,QAAQ,SAAS,GAAG,EAAE;AACxC,cAAQ,CAAC,EAAE,OAAO,QAAQ,IAAI,CAAC;AACjC,WAAO,KAAK,UAAU,QAAQ,CAAC,CAAC;AAAA,EAClC;AACF;AAEA,MAAM,aAA+E;AAAA,EACnF,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AACT;AAEA,SAAS,SAAS,KAAyB;AACzC,SAAO,eAAe;AACxB;",
  "names": ["selectorPart"]
}

{
  "version": 3,
  "sources": ["../../../src/utils/isomorphic/urlMatch.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isString } from './stringUtils';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#escaping\nconst escapedChars = new Set(['$', '^', '+', '.', '*', '(', ')', '|', '\\\\', '?', '{', '}', '[', ']']);\n\nexport function globToRegexPattern(glob: string): string {\n  const tokens = ['^'];\n  let inGroup = false;\n  for (let i = 0; i < glob.length; ++i) {\n    const c = glob[i];\n    if (c === '\\\\' && i + 1 < glob.length) {\n      const char = glob[++i];\n      tokens.push(escapedChars.has(char) ? '\\\\' + char : char);\n      continue;\n    }\n    if (c === '*') {\n      let starCount = 1;\n      while (glob[i + 1] === '*') {\n        starCount++;\n        i++;\n      }\n      if (starCount > 1)\n        tokens.push('(.*)');\n      else\n        tokens.push('([^/]*)');\n      continue;\n    }\n\n    switch (c) {\n      case '{':\n        inGroup = true;\n        tokens.push('(');\n        break;\n      case '}':\n        inGroup = false;\n        tokens.push(')');\n        break;\n      case ',':\n        if (inGroup) {\n          tokens.push('|');\n          break;\n        }\n        tokens.push('\\\\' + c);\n        break;\n      default:\n        tokens.push(escapedChars.has(c) ? '\\\\' + c : c);\n    }\n  }\n  tokens.push('$');\n  return tokens.join('');\n}\n\nfunction isRegExp(obj: any): obj is RegExp {\n  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nexport type URLMatch = string | RegExp | ((url: URL) => boolean);\n\nexport function urlMatchesEqual(match1: URLMatch, match2: URLMatch) {\n  if (isRegExp(match1) && isRegExp(match2))\n    return match1.source === match2.source && match1.flags === match2.flags;\n  return match1 === match2;\n}\n\nexport function urlMatches(baseURL: string | undefined, urlString: string, match: URLMatch | undefined, webSocketUrl?: boolean): boolean {\n  if (match === undefined || match === '')\n    return true;\n  if (isString(match))\n    match = new RegExp(resolveGlobToRegexPattern(baseURL, match, webSocketUrl));\n  if (isRegExp(match)) {\n    const r = match.test(urlString);\n    return r;\n  }\n  const url = parseURL(urlString);\n  if (!url)\n    return false;\n  if (typeof match !== 'function')\n    throw new Error('url parameter should be string, RegExp or function');\n  return match(url);\n}\n\nexport function resolveGlobToRegexPattern(baseURL: string | undefined, glob: string, webSocketUrl?: boolean): string {\n  if (webSocketUrl)\n    baseURL = toWebSocketBaseUrl(baseURL);\n  glob = resolveGlobBase(baseURL, glob);\n  return globToRegexPattern(glob);\n}\n\nfunction toWebSocketBaseUrl(baseURL: string | undefined) {\n  // Allow http(s) baseURL to match ws(s) urls.\n  if (baseURL && /^https?:\\/\\//.test(baseURL))\n    baseURL = baseURL.replace(/^http/, 'ws');\n  return baseURL;\n}\n\nfunction resolveGlobBase(baseURL: string | undefined, match: string): string {\n  if (!match.startsWith('*')) {\n    const tokenMap = new Map<string, string>();\n    function mapToken(original: string, replacement: string) {\n      if (original.length === 0)\n        return '';\n      tokenMap.set(replacement, original);\n      return replacement;\n    }\n    // Escaped `\\\\?` behaves the same as `?` in our glob patterns.\n    match = match.replaceAll(/\\\\\\\\\\?/g, '?');\n    // Special case about: URLs as they are not relative to baseURL\n    if (match.startsWith('about:') || match.startsWith('data:')\n      || match.startsWith('chrome:') || match.startsWith('edge:')\n      || match.startsWith('file:'))\n      return match;\n    // Glob symbols may be escaped in the URL and some of them such as ? affect resolution,\n    // so we replace them with safe components first.\n    const relativePath = match.split('/').map((token, index) => {\n      if (token === '.' || token === '..' || token === '')\n        return token;\n      // Handle special case of http*://, note that the new schema has to be\n      // a web schema so that slashes are properly inserted after domain.\n      if (index === 0 && token.endsWith(':'))\n        return mapToken(token, 'http:');\n      const questionIndex = token.indexOf('?');\n      if (questionIndex === -1)\n        return mapToken(token, `$_${index}_$`);\n      const newPrefix = mapToken(token.substring(0, questionIndex), `$_${index}_$`);\n      const newSuffix = mapToken(token.substring(questionIndex), `?$_${index}_$`);\n      return newPrefix + newSuffix;\n    }).join('/');\n    const result = resolveBaseURL(baseURL, relativePath);\n    let resolved = result.resolved;\n    for (const [token, original] of tokenMap) {\n      const normalize = result.caseInsensitivePart?.includes(token);\n      resolved = resolved.replace(token, normalize ? original.toLowerCase() : original);\n    }\n    match = resolved;\n  }\n  return match;\n}\n\nfunction parseURL(url: string): URL | null {\n  try {\n    return new URL(url);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport function constructURLBasedOnBaseURL(baseURL: string | undefined, givenURL: string): string {\n  try {\n    return resolveBaseURL(baseURL, givenURL).resolved;\n  } catch (e) {\n    return givenURL;\n  }\n}\n\nfunction resolveBaseURL(baseURL: string | undefined, givenURL: string) {\n  try {\n    const url = new URL(givenURL, baseURL);\n    const resolved = url.toString();\n    // Schema and domain are case-insensitive.\n    const caseInsensitivePrefix = url.origin;\n    return { resolved, caseInsensitivePart: caseInsensitivePrefix };\n  } catch (e) {\n    return { resolved: givenURL };\n  }\n}\n"],
  "mappings": "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",
  "names": ["mapToken"]
}

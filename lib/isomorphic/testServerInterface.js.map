{
  "version": 3,
  "sources": ["../../src/isomorphic/testServerInterface.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Event } from './events';\nimport type { JsonEvent } from './teleReceiver';\nimport type * as reporterTypes from '../../types/testReporter';\n\n// -- Reuse boundary -- Everything below this line is reused in the vscode extension.\n\nexport type ReportEntry = JsonEvent;\n\nexport interface TestServerInterface {\n  initialize(params: {\n    serializer?: string,\n    closeOnDisconnect?: boolean,\n    interceptStdio?: boolean,\n    watchTestDirs?: boolean,\n    populateDependenciesOnList?: boolean,\n  }): Promise<void>;\n\n  ping(params: {}): Promise<void>;\n\n  watch(params: {\n    fileNames: string[];\n  }): Promise<void>;\n\n  open(params: { location: reporterTypes.Location }): Promise<void>;\n\n  resizeTerminal(params: { cols: number, rows: number }): Promise<void>;\n\n  checkBrowsers(params: {}): Promise<{ hasBrowsers: boolean }>;\n\n  installBrowsers(params: {}): Promise<void>;\n\n  runGlobalSetup(params: {}): Promise<{\n    report: ReportEntry[],\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  runGlobalTeardown(params: {}): Promise<{\n    report: ReportEntry[],\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  startDevServer(params: {}): Promise<{\n    report: ReportEntry[];\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  stopDevServer(params: {}): Promise<{\n    report: ReportEntry[];\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  clearCache(params: {}): Promise<void>;\n\n  listFiles(params: {\n    projects?: string[];\n  }): Promise<{\n    report: ReportEntry[];\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  /**\n   * Returns list of teleReporter events.\n   */\n  listTests(params: {\n    projects?: string[];\n    locations?: string[];\n    grep?: string;\n    grepInvert?: string;\n  }): Promise<{\n    report: ReportEntry[],\n    status: reporterTypes.FullResult['status']\n  }>;\n\n  runTests(params: {\n    locations?: string[];\n    grep?: string;\n    grepInvert?: string;\n    testIds?: string[];\n    headed?: boolean;\n    workers?: number | string;\n    updateSnapshots?: 'all' | 'changed' | 'missing' | 'none';\n    updateSourceMethod?: 'overwrite' | 'patch' | '3way';\n    reporters?: string[],\n    trace?: 'on' | 'off';\n    video?: 'on' | 'off';\n    projects?: string[];\n    reuseContext?: boolean;\n    connectWsEndpoint?: string;\n  }): Promise<{\n    status: reporterTypes.FullResult['status'];\n  }>;\n\n  findRelatedTestFiles(params: {\n    files: string[];\n  }): Promise<{ testFiles: string[]; errors?: reporterTypes.TestError[]; }>;\n\n  stopTests(params: {}): Promise<void>;\n\n  closeGracefully(params: {}): Promise<void>;\n}\n\nexport interface TestServerInterfaceEvents {\n  onReport: Event<any>;\n  onStdio: Event<{ type: 'stdout' | 'stderr', text?: string, buffer?: string }>;\n  onTestFilesChanged: Event<{ testFiles: string[] }>;\n  onLoadTraceRequested: Event<{ traceUrl: string }>;\n}\n\nexport interface TestServerInterfaceEventEmitters {\n  dispatchEvent(event: 'report', params: ReportEntry): void;\n  dispatchEvent(event: 'stdio', params: { type: 'stdout' | 'stderr', text?: string, buffer?: string }): void;\n  dispatchEvent(event: 'testFilesChanged', params: { testFiles: string[] }): void;\n  dispatchEvent(event: 'loadTraceRequested', params: { traceUrl: string }): void;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}

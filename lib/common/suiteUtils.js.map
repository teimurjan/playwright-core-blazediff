{
  "version": 3,
  "sources": ["../../src/common/suiteUtils.ts"],
  "sourcesContent": ["/**\n* Copyright Microsoft Corporation. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport path from 'path';\n\nimport { calculateSha1, toPosixPath } from 'playwright-core/lib/utils';\n\nimport { createFileMatcher } from '../util';\n\nimport type { FullProjectInternal } from './config';\nimport type { Suite, TestCase } from './test';\nimport type { TestCaseFilter, TestFileFilter } from '../util';\n\n\nexport function filterSuite(suite: Suite, suiteFilter: (suites: Suite) => boolean, testFilter: TestCaseFilter) {\n  for (const child of suite.suites) {\n    if (!suiteFilter(child))\n      filterSuite(child, suiteFilter, testFilter);\n  }\n  const filteredTests = suite.tests.filter(testFilter);\n  const entries = new Set([...suite.suites, ...filteredTests]);\n  suite._entries = suite._entries.filter(e => entries.has(e)); // Preserve the order.\n}\n\nexport function filterTestsRemoveEmptySuites(suite: Suite, filter: TestCaseFilter): boolean {\n  const filteredSuites = suite.suites.filter(child => filterTestsRemoveEmptySuites(child, filter));\n  const filteredTests = suite.tests.filter(filter);\n  const entries = new Set([...filteredSuites, ...filteredTests]);\n  suite._entries = suite._entries.filter(e => entries.has(e)); // Preserve the order.\n  return !!suite._entries.length;\n}\n\nexport function bindFileSuiteToProject(project: FullProjectInternal, suite: Suite): Suite {\n  const relativeFile = path.relative(project.project.testDir, suite.location!.file);\n  const fileId = calculateSha1(toPosixPath(relativeFile)).slice(0, 20);\n\n  // Clone suite.\n  const result = suite._deepClone();\n  result._fileId = fileId;\n\n  // Assign test properties with project-specific values.\n  result.forEachTest((test, suite) => {\n    suite._fileId = fileId;\n    // At the point of the query, suite is not yet attached to the project, so we only get file, describe and test titles.\n    const [file, ...titles] = test.titlePath();\n    const testIdExpression = `[project=${project.id}]${toPosixPath(file)}\\x1e${titles.join('\\x1e')}`;\n    const testId = fileId + '-' + calculateSha1(testIdExpression).slice(0, 20);\n    test.id = testId;\n    test._projectId = project.id;\n\n    // Inherit properties from parent suites.\n    let inheritedRetries: number | undefined;\n    let inheritedTimeout: number | undefined;\n    for (let parentSuite: Suite | undefined = suite; parentSuite; parentSuite = parentSuite.parent) {\n      if (parentSuite._staticAnnotations.length)\n        test.annotations.unshift(...parentSuite._staticAnnotations);\n      if (inheritedRetries === undefined && parentSuite._retries !== undefined)\n        inheritedRetries = parentSuite._retries;\n      if (inheritedTimeout === undefined && parentSuite._timeout !== undefined)\n        inheritedTimeout = parentSuite._timeout;\n    }\n    test.retries = inheritedRetries ?? project.project.retries;\n    test.timeout = inheritedTimeout ?? project.project.timeout;\n\n    // Skip annotations imply skipped expectedStatus.\n    if (test.annotations.some(a => a.type === 'skip' || a.type === 'fixme'))\n      test.expectedStatus = 'skipped';\n\n    // We only compute / set digest in the runner.\n    if (test._poolDigest)\n      test._workerHash = `${project.id}-${test._poolDigest}-0`;\n  });\n\n  return result;\n}\n\nexport function applyRepeatEachIndex(project: FullProjectInternal, fileSuite: Suite, repeatEachIndex: number) {\n  // Assign test properties with project-specific values.\n  fileSuite.forEachTest((test, suite) => {\n    if (repeatEachIndex) {\n      const [file, ...titles] = test.titlePath();\n      const testIdExpression = `[project=${project.id}]${toPosixPath(file)}\\x1e${titles.join('\\x1e')} (repeat:${repeatEachIndex})`;\n      const testId = suite._fileId + '-' + calculateSha1(testIdExpression).slice(0, 20);\n      test.id = testId;\n      test.repeatEachIndex = repeatEachIndex;\n\n      if (test._poolDigest)\n        test._workerHash = `${project.id}-${test._poolDigest}-${repeatEachIndex}`;\n    }\n  });\n}\n\nexport function filterOnly(suite: Suite) {\n  if (!suite._getOnlyItems().length)\n    return;\n  const suiteFilter = (suite: Suite) => suite._only;\n  const testFilter = (test: TestCase) => test._only;\n  return filterSuiteWithOnlySemantics(suite, suiteFilter, testFilter);\n}\n\nfunction filterSuiteWithOnlySemantics(suite: Suite, suiteFilter: (suites: Suite) => boolean, testFilter: TestCaseFilter) {\n  const onlySuites = suite.suites.filter(child => filterSuiteWithOnlySemantics(child, suiteFilter, testFilter) || suiteFilter(child));\n  const onlyTests = suite.tests.filter(testFilter);\n  const onlyEntries = new Set([...onlySuites, ...onlyTests]);\n  if (onlyEntries.size) {\n    suite._entries = suite._entries.filter(e => onlyEntries.has(e)); // Preserve the order.\n    return true;\n  }\n  return false;\n}\n\nexport function filterByFocusedLine(suite: Suite, focusedTestFileLines: TestFileFilter[]) {\n  if (!focusedTestFileLines.length)\n    return;\n  const matchers = focusedTestFileLines.map(createFileMatcherFromFilter);\n  const testFileLineMatches = (testFileName: string, testLine: number, testColumn: number) => matchers.some(m => m(testFileName, testLine, testColumn));\n  const suiteFilter = (suite: Suite) => !!suite.location && testFileLineMatches(suite.location.file, suite.location.line, suite.location.column);\n  const testFilter = (test: TestCase) => testFileLineMatches(test.location.file, test.location.line, test.location.column);\n  return filterSuite(suite, suiteFilter, testFilter);\n}\n\nfunction createFileMatcherFromFilter(filter: TestFileFilter) {\n  const fileMatcher = createFileMatcher(filter.re || filter.exact || '');\n  return (testFileName: string, testLine: number, testColumn: number) =>\n    fileMatcher(testFileName) && (filter.line === testLine || filter.line === null) && (filter.column === testColumn || filter.column === null);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,kBAAiB;AAEjB,mBAA2C;AAE3C,kBAAkC;AAO3B,SAAS,YAAY,OAAc,aAAyC,YAA4B;AAC7G,aAAW,SAAS,MAAM,QAAQ;AAChC,QAAI,CAAC,YAAY,KAAK;AACpB,kBAAY,OAAO,aAAa,UAAU;AAAA,EAC9C;AACA,QAAM,gBAAgB,MAAM,MAAM,OAAO,UAAU;AACnD,QAAM,UAAU,oBAAI,IAAI,CAAC,GAAG,MAAM,QAAQ,GAAG,aAAa,CAAC;AAC3D,QAAM,WAAW,MAAM,SAAS,OAAO,OAAK,QAAQ,IAAI,CAAC,CAAC;AAC5D;AAEO,SAAS,6BAA6B,OAAc,QAAiC;AAC1F,QAAM,iBAAiB,MAAM,OAAO,OAAO,WAAS,6BAA6B,OAAO,MAAM,CAAC;AAC/F,QAAM,gBAAgB,MAAM,MAAM,OAAO,MAAM;AAC/C,QAAM,UAAU,oBAAI,IAAI,CAAC,GAAG,gBAAgB,GAAG,aAAa,CAAC;AAC7D,QAAM,WAAW,MAAM,SAAS,OAAO,OAAK,QAAQ,IAAI,CAAC,CAAC;AAC1D,SAAO,CAAC,CAAC,MAAM,SAAS;AAC1B;AAEO,SAAS,uBAAuB,SAA8B,OAAqB;AACxF,QAAM,eAAe,YAAAA,QAAK,SAAS,QAAQ,QAAQ,SAAS,MAAM,SAAU,IAAI;AAChF,QAAM,aAAS,gCAAc,0BAAY,YAAY,CAAC,EAAE,MAAM,GAAG,EAAE;AAGnE,QAAM,SAAS,MAAM,WAAW;AAChC,SAAO,UAAU;AAGjB,SAAO,YAAY,CAAC,MAAMC,WAAU;AAClC,IAAAA,OAAM,UAAU;AAEhB,UAAM,CAAC,MAAM,GAAG,MAAM,IAAI,KAAK,UAAU;AACzC,UAAM,mBAAmB,YAAY,QAAQ,EAAE,QAAI,0BAAY,IAAI,CAAC,IAAO,OAAO,KAAK,GAAM,CAAC;AAC9F,UAAM,SAAS,SAAS,UAAM,4BAAc,gBAAgB,EAAE,MAAM,GAAG,EAAE;AACzE,SAAK,KAAK;AACV,SAAK,aAAa,QAAQ;AAG1B,QAAI;AACJ,QAAI;AACJ,aAAS,cAAiCA,QAAO,aAAa,cAAc,YAAY,QAAQ;AAC9F,UAAI,YAAY,mBAAmB;AACjC,aAAK,YAAY,QAAQ,GAAG,YAAY,kBAAkB;AAC5D,UAAI,qBAAqB,UAAa,YAAY,aAAa;AAC7D,2BAAmB,YAAY;AACjC,UAAI,qBAAqB,UAAa,YAAY,aAAa;AAC7D,2BAAmB,YAAY;AAAA,IACnC;AACA,SAAK,UAAU,oBAAoB,QAAQ,QAAQ;AACnD,SAAK,UAAU,oBAAoB,QAAQ,QAAQ;AAGnD,QAAI,KAAK,YAAY,KAAK,OAAK,EAAE,SAAS,UAAU,EAAE,SAAS,OAAO;AACpE,WAAK,iBAAiB;AAGxB,QAAI,KAAK;AACP,WAAK,cAAc,GAAG,QAAQ,EAAE,IAAI,KAAK,WAAW;AAAA,EACxD,CAAC;AAED,SAAO;AACT;AAEO,SAAS,qBAAqB,SAA8B,WAAkB,iBAAyB;AAE5G,YAAU,YAAY,CAAC,MAAM,UAAU;AACrC,QAAI,iBAAiB;AACnB,YAAM,CAAC,MAAM,GAAG,MAAM,IAAI,KAAK,UAAU;AACzC,YAAM,mBAAmB,YAAY,QAAQ,EAAE,QAAI,0BAAY,IAAI,CAAC,IAAO,OAAO,KAAK,GAAM,CAAC,YAAY,eAAe;AACzH,YAAM,SAAS,MAAM,UAAU,UAAM,4BAAc,gBAAgB,EAAE,MAAM,GAAG,EAAE;AAChF,WAAK,KAAK;AACV,WAAK,kBAAkB;AAEvB,UAAI,KAAK;AACP,aAAK,cAAc,GAAG,QAAQ,EAAE,IAAI,KAAK,WAAW,IAAI,eAAe;AAAA,IAC3E;AAAA,EACF,CAAC;AACH;AAEO,SAAS,WAAW,OAAc;AACvC,MAAI,CAAC,MAAM,cAAc,EAAE;AACzB;AACF,QAAM,cAAc,CAACA,WAAiBA,OAAM;AAC5C,QAAM,aAAa,CAAC,SAAmB,KAAK;AAC5C,SAAO,6BAA6B,OAAO,aAAa,UAAU;AACpE;AAEA,SAAS,6BAA6B,OAAc,aAAyC,YAA4B;AACvH,QAAM,aAAa,MAAM,OAAO,OAAO,WAAS,6BAA6B,OAAO,aAAa,UAAU,KAAK,YAAY,KAAK,CAAC;AAClI,QAAM,YAAY,MAAM,MAAM,OAAO,UAAU;AAC/C,QAAM,cAAc,oBAAI,IAAI,CAAC,GAAG,YAAY,GAAG,SAAS,CAAC;AACzD,MAAI,YAAY,MAAM;AACpB,UAAM,WAAW,MAAM,SAAS,OAAO,OAAK,YAAY,IAAI,CAAC,CAAC;AAC9D,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,oBAAoB,OAAc,sBAAwC;AACxF,MAAI,CAAC,qBAAqB;AACxB;AACF,QAAM,WAAW,qBAAqB,IAAI,2BAA2B;AACrE,QAAM,sBAAsB,CAAC,cAAsB,UAAkB,eAAuB,SAAS,KAAK,OAAK,EAAE,cAAc,UAAU,UAAU,CAAC;AACpJ,QAAM,cAAc,CAACA,WAAiB,CAAC,CAACA,OAAM,YAAY,oBAAoBA,OAAM,SAAS,MAAMA,OAAM,SAAS,MAAMA,OAAM,SAAS,MAAM;AAC7I,QAAM,aAAa,CAAC,SAAmB,oBAAoB,KAAK,SAAS,MAAM,KAAK,SAAS,MAAM,KAAK,SAAS,MAAM;AACvH,SAAO,YAAY,OAAO,aAAa,UAAU;AACnD;AAEA,SAAS,4BAA4B,QAAwB;AAC3D,QAAM,kBAAc,+BAAkB,OAAO,MAAM,OAAO,SAAS,EAAE;AACrE,SAAO,CAAC,cAAsB,UAAkB,eAC9C,YAAY,YAAY,MAAM,OAAO,SAAS,YAAY,OAAO,SAAS,UAAU,OAAO,WAAW,cAAc,OAAO,WAAW;AAC1I;",
  "names": ["path", "suite"]
}

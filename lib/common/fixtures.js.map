{
  "version": 3,
  "sources": ["../../src/common/fixtures.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport crypto from 'crypto';\n\nimport { filterStackFile, formatLocation } from '../util';\n\nimport type { FixturesWithLocation } from './config';\nimport type { Fixtures } from '../../types/test';\nimport type { Location } from '../../types/testReporter';\n\nexport type FixtureScope = 'test' | 'worker';\ntype FixtureAuto = boolean | 'all-hooks-included';\nconst kScopeOrder: FixtureScope[] = ['test', 'worker'];\ntype FixtureOptions = { auto?: FixtureAuto, scope?: FixtureScope, option?: boolean, timeout?: number | undefined, title?: string, box?: boolean };\ntype FixtureTuple = [ value: any, options: FixtureOptions ];\nexport type FixtureRegistration = {\n  // Fixture registration location.\n  location: Location;\n  // Fixture name comes from test.extend() call.\n  name: string;\n  scope: FixtureScope;\n  // Either a fixture function, or a fixture value.\n  fn: Function | any;\n  // Auto fixtures always run without user explicitly mentioning them.\n  auto: FixtureAuto;\n  // An \"option\" fixture can have a value set in the config.\n  option: boolean;\n  // Custom title to be used instead of the name, internal-only.\n  customTitle?: string;\n  // Fixture with a separate timeout does not count towards the test time.\n  timeout?: number;\n  // Names of the dependencies, comes from the declaration \"({ foo, bar }) => {...}\"\n  deps: string[];\n  // Unique id, to differentiate between fixtures with the same name.\n  id: string;\n  // A fixture override can use the previous version of the fixture.\n  super?: FixtureRegistration;\n  // Whether this fixture is an option override value set from the config.\n  optionOverride?: boolean;\n  // Do not generate the step for this fixture, consider it internal.\n  box?: boolean;\n};\nexport type LoadError = {\n  message: string;\n  location: Location;\n};\ntype LoadErrorSink = (error: LoadError) => void;\ntype OptionOverrides = {\n  overrides: Fixtures,\n  location: Location,\n};\n\nfunction isFixtureTuple(value: any): value is FixtureTuple {\n  return Array.isArray(value) && typeof value[1] === 'object';\n}\n\nfunction isFixtureOption(value: any): value is FixtureTuple {\n  return isFixtureTuple(value) && !!value[1].option;\n}\n\nexport class FixturePool {\n  readonly digest: string;\n  private readonly _registrations: Map<string, FixtureRegistration>;\n  private _onLoadError: LoadErrorSink;\n\n  constructor(fixturesList: FixturesWithLocation[], onLoadError: LoadErrorSink, parentPool?: FixturePool, disallowWorkerFixtures?: boolean, optionOverrides?: OptionOverrides) {\n    this._registrations = new Map(parentPool ? parentPool._registrations : []);\n    this._onLoadError = onLoadError;\n\n    const allOverrides = optionOverrides?.overrides ?? {};\n    const overrideKeys = new Set(Object.keys(allOverrides));\n    for (const list of fixturesList) {\n      this._appendFixtureList(list, !!disallowWorkerFixtures, false);\n\n      // Process option overrides immediately after original option definitions,\n      // so that any test.use() override it.\n      const selectedOverrides: Fixtures = {};\n      for (const [key, value] of Object.entries(list.fixtures)) {\n        if (isFixtureOption(value) && overrideKeys.has(key))\n          (selectedOverrides as any)[key] = [(allOverrides as any)[key], value[1]];\n      }\n      if (Object.entries(selectedOverrides).length)\n        this._appendFixtureList({ fixtures: selectedOverrides, location: optionOverrides!.location }, !!disallowWorkerFixtures, true);\n    }\n\n    this.digest = this.validate();\n  }\n\n  private _appendFixtureList(list: FixturesWithLocation, disallowWorkerFixtures: boolean, isOptionsOverride: boolean) {\n    const { fixtures, location } = list;\n    for (const entry of Object.entries(fixtures)) {\n      const name = entry[0];\n      let value = entry[1];\n      let options: { auto: FixtureAuto, scope: FixtureScope, option: boolean, timeout: number | undefined, customTitle?: string, box?: boolean } | undefined;\n      if (isFixtureTuple(value)) {\n        options = {\n          auto: value[1].auto ?? false,\n          scope: value[1].scope || 'test',\n          option: !!value[1].option,\n          timeout: value[1].timeout,\n          customTitle: value[1].title,\n          box: value[1].box,\n        };\n        value = value[0];\n      }\n      let fn = value as (Function | any);\n\n      const previous = this._registrations.get(name);\n      if (previous && options) {\n        if (previous.scope !== options.scope) {\n          this._addLoadError(`Fixture \"${name}\" has already been registered as a { scope: '${previous.scope}' } fixture defined in ${formatLocation(previous.location)}.`, location);\n          continue;\n        }\n        if (previous.auto !== options.auto) {\n          this._addLoadError(`Fixture \"${name}\" has already been registered as a { auto: '${previous.scope}' } fixture defined in ${formatLocation(previous.location)}.`, location);\n          continue;\n        }\n      } else if (previous) {\n        // Note: deliberately not inheriting \"options.box\" so that fixture override is visible by default.\n        options = { auto: previous.auto, scope: previous.scope, option: previous.option, timeout: previous.timeout, customTitle: previous.customTitle };\n      } else if (!options) {\n        options = { auto: false, scope: 'test', option: false, timeout: undefined };\n      }\n\n      if (!kScopeOrder.includes(options.scope)) {\n        this._addLoadError(`Fixture \"${name}\" has unknown { scope: '${options.scope}' }.`, location);\n        continue;\n      }\n      if (options.scope === 'worker' && disallowWorkerFixtures) {\n        this._addLoadError(`Cannot use({ ${name} }) in a describe group, because it forces a new worker.\\nMake it top-level in the test file or put in the configuration file.`, location);\n        continue;\n      }\n\n      // Overriding option with \"undefined\" value means setting it to the default value\n      // from the config or from the original declaration of the option.\n      if (fn === undefined && options.option && previous) {\n        let original = previous;\n        while (!original.optionOverride && original.super)\n          original = original.super;\n        fn = original.fn;\n      }\n\n      const deps = fixtureParameterNames(fn, location, e => this._onLoadError(e));\n      const registration: FixtureRegistration = { id: '', name, location, scope: options.scope, fn, auto: options.auto, option: options.option, timeout: options.timeout, customTitle: options.customTitle, box: options.box, deps, super: previous, optionOverride: isOptionsOverride };\n      registrationId(registration);\n      this._registrations.set(name, registration);\n    }\n  }\n\n  private validate() {\n    const markers = new Map<FixtureRegistration, 'visiting' | 'visited'>();\n    const stack: FixtureRegistration[] = [];\n    let hasDependencyErrors = false;\n    const addDependencyError = (message: string, location: Location) => {\n      hasDependencyErrors = true;\n      this._addLoadError(message, location);\n    };\n    const visit = (registration: FixtureRegistration, boxedOnly: boolean) => {\n      markers.set(registration, 'visiting');\n      stack.push(registration);\n      for (const name of registration.deps) {\n        const dep = this.resolve(name, registration);\n        if (!dep) {\n          if (name === registration.name)\n            addDependencyError(`Fixture \"${registration.name}\" references itself, but does not have a base implementation.`, registration.location);\n          else\n            addDependencyError(`Fixture \"${registration.name}\" has unknown parameter \"${name}\".`, registration.location);\n          continue;\n        }\n        if (kScopeOrder.indexOf(registration.scope) > kScopeOrder.indexOf(dep.scope)) {\n          addDependencyError(`${registration.scope} fixture \"${registration.name}\" cannot depend on a ${dep.scope} fixture \"${name}\" defined in ${formatPotentiallyInternalLocation(dep.location)}.`, registration.location);\n          continue;\n        }\n        if (!markers.has(dep)) {\n          visit(dep, boxedOnly);\n        } else if (markers.get(dep) === 'visiting') {\n          const index = stack.indexOf(dep);\n          const allRegs = stack.slice(index, stack.length);\n          const filteredRegs = allRegs.filter(r => !r.box);\n          const regs = boxedOnly ? filteredRegs : allRegs;\n          const names = regs.map(r => `\"${r.name}\"`);\n          addDependencyError(`Fixtures ${names.join(' -> ')} -> \"${dep.name}\" form a dependency cycle: ${regs.map(r => formatPotentiallyInternalLocation(r.location)).join(' -> ')} -> ${formatPotentiallyInternalLocation(dep.location)}`, dep.location);\n          continue;\n        }\n      }\n      markers.set(registration, 'visited');\n      stack.pop();\n    };\n\n    const names = Array.from(this._registrations.keys()).sort();\n\n    // First iterate over non-boxed fixtures to provide clear error messages.\n    for (const name of names) {\n      const registration = this._registrations.get(name)!;\n      if (!registration.box)\n        visit(registration, true);\n    }\n\n    // If no errors found, iterate over boxed fixtures\n    if (!hasDependencyErrors) {\n      for (const name of names) {\n        const registration = this._registrations.get(name)!;\n        if (registration.box)\n          visit(registration, false);\n      }\n    }\n\n    const hash = crypto.createHash('sha1');\n    for (const name of names) {\n      const registration = this._registrations.get(name)!;\n      if (registration.scope === 'worker')\n        hash.update(registration.id + ';');\n    }\n    return hash.digest('hex');\n  }\n\n  validateFunction(fn: Function, prefix: string, location: Location) {\n    for (const name of fixtureParameterNames(fn, location, e => this._onLoadError(e))) {\n      const registration = this._registrations.get(name);\n      if (!registration)\n        this._addLoadError(`${prefix} has unknown parameter \"${name}\".`, location);\n    }\n  }\n\n  resolve(name: string, forFixture?: FixtureRegistration): FixtureRegistration | undefined {\n    if (name === forFixture?.name)\n      return forFixture.super;\n    return this._registrations.get(name);\n  }\n\n  autoFixtures() {\n    return [...this._registrations.values()].filter(r => r.auto !== false);\n  }\n\n  private _addLoadError(message: string, location: Location) {\n    this._onLoadError({ message, location });\n  }\n}\n\nconst signatureSymbol = Symbol('signature');\n\nexport function formatPotentiallyInternalLocation(location: Location): string {\n  const isUserFixture = location && filterStackFile(location.file);\n  return isUserFixture ? formatLocation(location) : '<builtin>';\n}\n\nexport function fixtureParameterNames(fn: Function | any, location: Location, onError: LoadErrorSink): string[] {\n  if (typeof fn !== 'function')\n    return [];\n  if (!fn[signatureSymbol])\n    fn[signatureSymbol] = innerFixtureParameterNames(fn, location, onError);\n  return fn[signatureSymbol];\n}\n\nexport function inheritFixtureNames(from: Function, to: Function) {\n  (to as any)[signatureSymbol] = (from as any)[signatureSymbol];\n}\n\nfunction innerFixtureParameterNames(fn: Function, location: Location, onError: LoadErrorSink): string[] {\n  const text = filterOutComments(fn.toString());\n  const match = text.match(/(?:async)?(?:\\s+function)?[^(]*\\(([^)]*)/);\n  if (!match)\n    return [];\n  const trimmedParams = match[1].trim();\n  if (!trimmedParams)\n    return [];\n  const [firstParam] = splitByComma(trimmedParams);\n  if (firstParam[0] !== '{' || firstParam[firstParam.length - 1] !== '}') {\n    onError({ message: 'First argument must use the object destructuring pattern: '  + firstParam, location });\n    return [];\n  }\n  const props = splitByComma(firstParam.substring(1, firstParam.length - 1)).map(prop => {\n    const colon = prop.indexOf(':');\n    return colon === -1 ? prop.trim() : prop.substring(0, colon).trim();\n  });\n  const restProperty = props.find(prop => prop.startsWith('...'));\n  if (restProperty) {\n    onError({ message: `Rest property \"${restProperty}\" is not supported. List all used fixtures explicitly, separated by comma.`, location });\n    return [];\n  }\n  return props;\n}\n\nfunction filterOutComments(s: string): string {\n  const result: string[] = [];\n  let commentState: 'none'|'singleline'|'multiline' = 'none';\n  for (let i = 0; i < s.length; ++i) {\n    if (commentState === 'singleline') {\n      if (s[i] === '\\n')\n        commentState = 'none';\n    } else if (commentState === 'multiline') {\n      if (s[i - 1] === '*' && s[i] === '/')\n        commentState = 'none';\n    } else if (commentState === 'none') {\n      if (s[i] === '/' && s[i + 1] === '/') {\n        commentState = 'singleline';\n      } else if (s[i] === '/' && s[i + 1] === '*') {\n        commentState = 'multiline';\n        i += 2;\n      } else {\n        result.push(s[i]);\n      }\n    }\n  }\n  return result.join('');\n}\n\nfunction splitByComma(s: string) {\n  const result: string[] = [];\n  const stack: string[] = [];\n  let start = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '{' || s[i] === '[') {\n      stack.push(s[i] === '{' ? '}' : ']');\n    } else if (s[i] === stack[stack.length - 1]) {\n      stack.pop();\n    } else if (!stack.length && s[i] === ',') {\n      const token = s.substring(start, i).trim();\n      if (token)\n        result.push(token);\n      start = i + 1;\n    }\n  }\n  const lastToken = s.substring(start).trim();\n  if (lastToken)\n    result.push(lastToken);\n  return result;\n}\n\n// name + superId, fn -> id\nconst registrationIdMap = new Map<string, Map<Function | any, string>>();\nlet lastId = 0;\n\nfunction registrationId(registration: FixtureRegistration): string {\n  if (registration.id)\n    return registration.id;\n  const key = registration.name + '@@@' + (registration.super ?  registrationId(registration.super) : '');\n  let map = registrationIdMap.get(key);\n  if (!map) {\n    map = new Map();\n    registrationIdMap.set(key, map);\n  }\n  if (!map.has(registration.fn))\n    map.set(registration.fn, String(lastId++));\n  registration.id = map.get(registration.fn)!;\n  return registration.id;\n}\n"],
  "mappings": "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",
  "names": ["names", "crypto"]
}

{
  "version": 3,
  "sources": ["../../src/runner/testGroups.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Suite, TestCase } from '../common/test';\n\nexport type TestGroup = {\n  workerHash: string;\n  requireFile: string;\n  repeatEachIndex: number;\n  projectId: string;\n  tests: TestCase[];\n};\n\nexport function createTestGroups(projectSuite: Suite, expectedParallelism: number): TestGroup[] {\n  // This function groups tests that can be run together.\n  // Tests cannot be run together when:\n  // - They belong to different projects - requires different workers.\n  // - They have a different repeatEachIndex - requires different workers.\n  // - They have a different set of worker fixtures in the pool - requires different workers.\n  // - They have a different requireFile - reuses the worker, but runs each requireFile separately.\n  // - They belong to a parallel suite.\n\n  // Using the map \"workerHash -> requireFile -> group\" makes us preserve the natural order\n  // of worker hashes and require files for the simple cases.\n  const groups = new Map<string, Map<string, {\n    // Tests that must be run in order are in the same group.\n    general: TestGroup,\n\n    // There are 3 kinds of parallel tests:\n    // - Tests belonging to parallel suites, without beforeAll/afterAll hooks.\n    //   These can be run independently, they are put into their own group, key === test.\n    // - Tests belonging to parallel suites, with beforeAll/afterAll hooks.\n    //   These should share the worker as much as possible, put into single parallelWithHooks group.\n    //   We'll divide them into equally-sized groups later.\n    // - Tests belonging to serial suites inside parallel suites.\n    //   These should run as a serial group, each group is independent, key === serial suite.\n    parallel: Map<Suite | TestCase, TestGroup>,\n    parallelWithHooks: TestGroup,\n  }>>();\n\n  const createGroup = (test: TestCase): TestGroup => {\n    return {\n      workerHash: test._workerHash,\n      requireFile: test._requireFile,\n      repeatEachIndex: test.repeatEachIndex,\n      projectId: test._projectId,\n      tests: [],\n    };\n  };\n\n  for (const test of projectSuite.allTests()) {\n    let withWorkerHash = groups.get(test._workerHash);\n    if (!withWorkerHash) {\n      withWorkerHash = new Map();\n      groups.set(test._workerHash, withWorkerHash);\n    }\n    let withRequireFile = withWorkerHash.get(test._requireFile);\n    if (!withRequireFile) {\n      withRequireFile = {\n        general: createGroup(test),\n        parallel: new Map(),\n        parallelWithHooks: createGroup(test),\n      };\n      withWorkerHash.set(test._requireFile, withRequireFile);\n    }\n\n    // Note that a parallel suite cannot be inside a serial suite. This is enforced in TestType.\n    let insideParallel = false;\n    let outerMostSequentialSuite: Suite | undefined;\n    let hasAllHooks = false;\n    for (let parent: Suite | undefined = test.parent; parent; parent = parent.parent) {\n      if (parent._parallelMode === 'serial' || parent._parallelMode === 'default')\n        outerMostSequentialSuite = parent;\n      insideParallel = insideParallel || parent._parallelMode === 'parallel';\n      hasAllHooks = hasAllHooks || parent._hooks.some(hook => hook.type === 'beforeAll' || hook.type === 'afterAll');\n    }\n\n    if (insideParallel) {\n      if (hasAllHooks && !outerMostSequentialSuite) {\n        withRequireFile.parallelWithHooks.tests.push(test);\n      } else {\n        const key = outerMostSequentialSuite || test;\n        let group = withRequireFile.parallel.get(key);\n        if (!group) {\n          group = createGroup(test);\n          withRequireFile.parallel.set(key, group);\n        }\n        group.tests.push(test);\n      }\n    } else {\n      withRequireFile.general.tests.push(test);\n    }\n  }\n\n  const result: TestGroup[] = [];\n  for (const withWorkerHash of groups.values()) {\n    for (const withRequireFile of withWorkerHash.values()) {\n      // Tests without parallel mode should run serially as a single group.\n      if (withRequireFile.general.tests.length)\n        result.push(withRequireFile.general);\n\n      // Parallel test groups without beforeAll/afterAll can be run independently.\n      result.push(...withRequireFile.parallel.values());\n\n      // Tests with beforeAll/afterAll should try to share workers as much as possible.\n      const parallelWithHooksGroupSize = Math.ceil(withRequireFile.parallelWithHooks.tests.length / expectedParallelism);\n      let lastGroup: TestGroup | undefined;\n      for (const test of withRequireFile.parallelWithHooks.tests) {\n        if (!lastGroup || lastGroup.tests.length >= parallelWithHooksGroupSize) {\n          lastGroup = createGroup(test);\n          result.push(lastGroup);\n        }\n        lastGroup.tests.push(test);\n      }\n    }\n  }\n  return result;\n}\n\nexport function filterForShard(shard: { total: number, current: number }, testGroups: TestGroup[]): Set<TestGroup> {\n  // Note that sharding works based on test groups.\n  // This means parallel files will be sharded by single tests,\n  // while non-parallel files will be sharded by the whole file.\n  //\n  // Shards are still balanced by the number of tests, not files,\n  // even in the case of non-paralleled files.\n\n  let shardableTotal = 0;\n  for (const group of testGroups)\n    shardableTotal += group.tests.length;\n\n  // Each shard gets some tests.\n  const shardSize = Math.floor(shardableTotal / shard.total);\n  // First few shards get one more test each.\n  const extraOne = shardableTotal - shardSize * shard.total;\n\n  const currentShard = shard.current - 1; // Make it zero-based for calculations.\n  const from = shardSize * currentShard + Math.min(extraOne, currentShard);\n  const to = from + shardSize + (currentShard < extraOne ? 1 : 0);\n\n  let current = 0;\n  const result = new Set<TestGroup>();\n  for (const group of testGroups) {\n    // Any test group goes to the shard that contains the first test of this group.\n    // So, this shard gets any group that starts at [from; to)\n    if (current >= from && current < to)\n      result.add(group);\n    current += group.tests.length;\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": []
}

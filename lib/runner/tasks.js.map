{
  "version": 3,
  "sources": ["../../src/runner/tasks.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\n\nimport { monotonicTime, removeFolders } from 'playwright-core/lib/utils';\nimport { debug } from 'playwright-core/lib/utilsBundle';\n\nimport { Dispatcher  } from './dispatcher';\nimport { FailureTracker } from './failureTracker';\nimport { collectProjectsAndTestFiles, createRootSuite, loadFileSuites, loadGlobalHook } from './loadUtils';\nimport { buildDependentProjects, buildTeardownToSetupsMap, filterProjects } from './projectUtils';\nimport { applySuggestedRebaselines, clearSuggestedRebaselines } from './rebase';\nimport { TaskRunner } from './taskRunner';\nimport { detectChangedTestFiles } from './vcs';\nimport { Suite } from '../common/test';\nimport { createTestGroups } from '../runner/testGroups';\nimport { cacheDir } from '../transform/compilationCache';\nimport { removeDirAndLogToConsole } from '../util';\n\nimport type { TestGroup } from '../runner/testGroups';\nimport type { EnvByProjectId } from './dispatcher';\nimport type { TestRunnerPluginRegistration } from '../plugins';\nimport type { Task } from './taskRunner';\nimport type { FullResult } from '../../types/testReporter';\nimport type { FullConfigInternal, FullProjectInternal } from '../common/config';\nimport type { InternalReporter } from '../reporters/internalReporter';\nimport type { ManualPromise } from 'playwright-core/lib/utils';\n\nconst readDirAsync = promisify(fs.readdir);\n\ntype ProjectWithTestGroups = {\n  project: FullProjectInternal;\n  projectSuite: Suite;\n  testGroups: TestGroup[];\n};\n\ntype Phase = {\n  dispatcher: Dispatcher,\n  projects: ProjectWithTestGroups[]\n};\n\nexport class TestRun {\n  readonly config: FullConfigInternal;\n  readonly reporter: InternalReporter;\n  readonly failureTracker: FailureTracker;\n  rootSuite: Suite | undefined = undefined;\n  readonly phases: Phase[] = [];\n  projectFiles: Map<FullProjectInternal, string[]> = new Map();\n  projectSuites: Map<FullProjectInternal, Suite[]> = new Map();\n\n  constructor(config: FullConfigInternal, reporter: InternalReporter) {\n    this.config = config;\n    this.reporter = reporter;\n    this.failureTracker = new FailureTracker(config);\n  }\n}\n\nexport async function runTasks(testRun: TestRun, tasks: Task<TestRun>[], globalTimeout?: number, cancelPromise?: ManualPromise<void>) {\n  const deadline = globalTimeout ? monotonicTime() + globalTimeout : 0;\n  const taskRunner = new TaskRunner<TestRun>(testRun.reporter, globalTimeout || 0);\n  for (const task of tasks)\n    taskRunner.addTask(task);\n  testRun.reporter.onConfigure(testRun.config.config);\n  const status = await taskRunner.run(testRun, deadline, cancelPromise);\n  return await finishTaskRun(testRun, status);\n}\n\nexport async function runTasksDeferCleanup(testRun: TestRun, tasks: Task<TestRun>[]) {\n  const taskRunner = new TaskRunner<TestRun>(testRun.reporter, 0);\n  for (const task of tasks)\n    taskRunner.addTask(task);\n  testRun.reporter.onConfigure(testRun.config.config);\n  const { status, cleanup } = await taskRunner.runDeferCleanup(testRun, 0);\n  return { status: await finishTaskRun(testRun, status), cleanup };\n}\n\nasync function finishTaskRun(testRun: TestRun, status: FullResult['status']) {\n  if (status === 'passed')\n    status = testRun.failureTracker.result();\n  const modifiedResult = await testRun.reporter.onEnd({ status });\n  if (modifiedResult && modifiedResult.status)\n    status = modifiedResult.status;\n  await testRun.reporter.onExit();\n  return status;\n}\n\nexport function createGlobalSetupTasks(config: FullConfigInternal) {\n  const tasks: Task<TestRun>[] = [];\n  if (!config.configCLIOverrides.preserveOutputDir)\n    tasks.push(createRemoveOutputDirsTask());\n  tasks.push(\n      ...createPluginSetupTasks(config),\n      ...config.globalTeardowns.map(file => createGlobalTeardownTask(file, config)).reverse(),\n      ...config.globalSetups.map(file => createGlobalSetupTask(file, config)),\n  );\n  return tasks;\n}\n\nexport function createRunTestsTasks(config: FullConfigInternal) {\n  return [\n    createPhasesTask(),\n    createReportBeginTask(),\n    ...config.plugins.map(plugin => createPluginBeginTask(plugin)),\n    createRunTestsTask(),\n  ];\n}\n\nexport function createClearCacheTask(config: FullConfigInternal): Task<TestRun> {\n  return {\n    title: 'clear cache',\n    setup: async () => {\n      await removeDirAndLogToConsole(cacheDir);\n      for (const plugin of config.plugins)\n        await plugin.instance?.clearCache?.();\n    },\n  };\n}\n\nexport function createReportBeginTask(): Task<TestRun> {\n  return {\n    title: 'report begin',\n    setup: async testRun => {\n      testRun.reporter.onBegin?.(testRun.rootSuite!);\n    },\n    teardown: async ({}) => {},\n  };\n}\n\nexport function createPluginSetupTasks(config: FullConfigInternal): Task<TestRun>[] {\n  return config.plugins.map(plugin => ({\n    title: 'plugin setup',\n    setup: async ({ reporter }) => {\n      if (typeof plugin.factory === 'function')\n        plugin.instance = await plugin.factory();\n      else\n        plugin.instance = plugin.factory;\n      await plugin.instance?.setup?.(config.config, config.configDir, reporter);\n    },\n    teardown: async () => {\n      await plugin.instance?.teardown?.();\n    },\n  }));\n}\n\nfunction createPluginBeginTask(plugin: TestRunnerPluginRegistration): Task<TestRun> {\n  return {\n    title: 'plugin begin',\n    setup: async testRun => {\n      await plugin.instance?.begin?.(testRun.rootSuite!);\n    },\n    teardown: async () => {\n      await plugin.instance?.end?.();\n    },\n  };\n}\n\nfunction createGlobalSetupTask(file: string, config: FullConfigInternal): Task<TestRun> {\n  let title = 'global setup';\n  if (config.globalSetups.length > 1)\n    title += ` (${file})`;\n\n  let globalSetupResult: any;\n  return {\n    title,\n    setup: async ({ config }) => {\n      const setupHook = await loadGlobalHook(config, file);\n      globalSetupResult = await setupHook(config.config);\n    },\n    teardown: async () => {\n      if (typeof globalSetupResult === 'function')\n        await globalSetupResult();\n    },\n  };\n}\n\nfunction createGlobalTeardownTask(file: string, config: FullConfigInternal): Task<TestRun> {\n  let title = 'global teardown';\n  if (config.globalTeardowns.length > 1)\n    title += ` (${file})`;\n\n  return {\n    title,\n    teardown: async ({ config }) => {\n      const teardownHook = await loadGlobalHook(config, file);\n      await teardownHook(config.config);\n    },\n  };\n}\n\nfunction createRemoveOutputDirsTask(): Task<TestRun> {\n  return {\n    title: 'clear output',\n    setup: async ({ config }) => {\n      const outputDirs = new Set<string>();\n      const projects = filterProjects(config.projects, config.cliProjectFilter);\n      projects.forEach(p => outputDirs.add(p.project.outputDir));\n\n      await Promise.all(Array.from(outputDirs).map(outputDir => removeFolders([outputDir]).then(async ([error]) => {\n        if (!error)\n          return;\n        if ((error as any).code === 'EBUSY') {\n          // We failed to remove folder, might be due to the whole folder being mounted inside a container:\n          //   https://github.com/microsoft/playwright/issues/12106\n          // Do a best-effort to remove all files inside of it instead.\n          const entries = await readDirAsync(outputDir).catch(e => []);\n          await Promise.all(entries.map(entry => removeFolders([path.join(outputDir, entry)])));\n        } else {\n          throw error;\n        }\n      })));\n    },\n  };\n}\n\nexport function createListFilesTask(): Task<TestRun> {\n  return {\n    title: 'load tests',\n    setup: async (testRun, errors) => {\n      testRun.rootSuite = await createRootSuite(testRun, errors, false);\n      testRun.failureTracker.onRootSuite(testRun.rootSuite);\n      await collectProjectsAndTestFiles(testRun, false);\n      for (const [project, files] of testRun.projectFiles) {\n        const projectSuite = new Suite(project.project.name, 'project');\n        projectSuite._fullProject = project;\n        testRun.rootSuite._addSuite(projectSuite);\n        const suites = files.map(file => {\n          const title = path.relative(testRun.config.config.rootDir, file);\n          const suite =  new Suite(title, 'file');\n          suite.location = { file, line: 0, column: 0 };\n          projectSuite._addSuite(suite);\n          return suite;\n        });\n        testRun.projectSuites.set(project, suites);\n      }\n    },\n  };\n}\n\nexport function createLoadTask(mode: 'out-of-process' | 'in-process', options: { filterOnly: boolean, failOnLoadErrors: boolean, doNotRunDepsOutsideProjectFilter?: boolean, populateDependencies?: boolean }): Task<TestRun> {\n  return {\n    title: 'load tests',\n    setup: async (testRun, errors, softErrors) => {\n      await collectProjectsAndTestFiles(testRun, !!options.doNotRunDepsOutsideProjectFilter);\n      await loadFileSuites(testRun, mode, options.failOnLoadErrors ? errors : softErrors);\n\n      if (testRun.config.cliOnlyChanged || options.populateDependencies) {\n        for (const plugin of testRun.config.plugins)\n          await plugin.instance?.populateDependencies?.();\n      }\n\n      if (testRun.config.cliOnlyChanged) {\n        const changedFiles = await detectChangedTestFiles(testRun.config.cliOnlyChanged, testRun.config.configDir);\n        testRun.config.preOnlyTestFilters.push(test => changedFiles.has(test.location.file));\n      }\n\n      testRun.rootSuite = await createRootSuite(testRun, options.failOnLoadErrors ? errors : softErrors, !!options.filterOnly);\n      testRun.failureTracker.onRootSuite(testRun.rootSuite);\n      // Fail when no tests.\n      if (options.failOnLoadErrors && !testRun.rootSuite.allTests().length && !testRun.config.cliPassWithNoTests && !testRun.config.config.shard && !testRun.config.cliOnlyChanged) {\n        if (testRun.config.cliArgs.length) {\n          throw new Error([\n            `No tests found.`,\n            `Make sure that arguments are regular expressions matching test files.`,\n            `You may need to escape symbols like \"$\" or \"*\" and quote the arguments.`,\n          ].join('\\n'));\n        }\n        throw new Error(`No tests found`);\n      }\n    },\n  };\n}\n\nexport function createApplyRebaselinesTask(): Task<TestRun> {\n  return {\n    title: 'apply rebaselines',\n    setup: async () => {\n      clearSuggestedRebaselines();\n    },\n    teardown: async ({ config, reporter }) => {\n      await applySuggestedRebaselines(config, reporter);\n    },\n  };\n}\n\nfunction createPhasesTask(): Task<TestRun> {\n  return {\n    title: 'create phases',\n    setup: async testRun => {\n      let maxConcurrentTestGroups = 0;\n\n      const processed = new Set<FullProjectInternal>();\n      const projectToSuite = new Map(testRun.rootSuite!.suites.map(suite => [suite._fullProject!, suite]));\n      const allProjects = [...projectToSuite.keys()];\n      const teardownToSetups = buildTeardownToSetupsMap(allProjects);\n      const teardownToSetupsDependents = new Map<FullProjectInternal, FullProjectInternal[]>();\n      for (const [teardown, setups] of teardownToSetups) {\n        const closure = buildDependentProjects(setups, allProjects);\n        closure.delete(teardown);\n        teardownToSetupsDependents.set(teardown, [...closure]);\n      }\n\n      for (let i = 0; i < projectToSuite.size; i++) {\n        // Find all projects that have all their dependencies processed by previous phases.\n        const phaseProjects: FullProjectInternal[] = [];\n        for (const project of projectToSuite.keys()) {\n          if (processed.has(project))\n            continue;\n          const projectsThatShouldFinishFirst = [...project.deps, ...(teardownToSetupsDependents.get(project) || [])];\n          if (projectsThatShouldFinishFirst.find(p => !processed.has(p)))\n            continue;\n          phaseProjects.push(project);\n        }\n\n        // Create a new phase.\n        for (const project of phaseProjects)\n          processed.add(project);\n        if (phaseProjects.length) {\n          let testGroupsInPhase = 0;\n          const phase: Phase = { dispatcher: new Dispatcher(testRun.config, testRun.reporter, testRun.failureTracker), projects: [] };\n          testRun.phases.push(phase);\n          for (const project of phaseProjects) {\n            const projectSuite = projectToSuite.get(project)!;\n            const testGroups = createTestGroups(projectSuite, testRun.config.config.workers);\n            phase.projects.push({ project, projectSuite, testGroups });\n            testGroupsInPhase += Math.min(project.workers ?? Number.MAX_SAFE_INTEGER, testGroups.length);\n          }\n          debug('pw:test:task')(`created phase #${testRun.phases.length} with ${phase.projects.map(p => p.project.project.name).sort()} projects, ${testGroupsInPhase} testGroups`);\n          maxConcurrentTestGroups = Math.max(maxConcurrentTestGroups, testGroupsInPhase);\n        }\n      }\n\n      testRun.config.config.metadata.actualWorkers = Math.min(testRun.config.config.workers, maxConcurrentTestGroups);\n    },\n  };\n}\n\nfunction createRunTestsTask(): Task<TestRun> {\n  return {\n    title: 'test suite',\n    setup: async ({ phases, failureTracker }) => {\n      const successfulProjects = new Set<FullProjectInternal>();\n      const extraEnvByProjectId: EnvByProjectId = new Map();\n      const teardownToSetups = buildTeardownToSetupsMap(phases.map(phase => phase.projects.map(p => p.project)).flat());\n\n      for (const { dispatcher, projects } of phases) {\n        // Each phase contains dispatcher and a set of test groups.\n        // We don't want to run the test groups belonging to the projects\n        // that depend on the projects that failed previously.\n        const phaseTestGroups: TestGroup[] = [];\n        for (const { project, testGroups } of projects) {\n          // Inherit extra environment variables from dependencies.\n          let extraEnv: Record<string, string | undefined> = {};\n          for (const dep of project.deps)\n            extraEnv = { ...extraEnv, ...extraEnvByProjectId.get(dep.id) };\n          for (const setup of teardownToSetups.get(project) || [])\n            extraEnv = { ...extraEnv, ...extraEnvByProjectId.get(setup.id) };\n          extraEnvByProjectId.set(project.id, extraEnv);\n\n          const hasFailedDeps = project.deps.some(p => !successfulProjects.has(p));\n          if (!hasFailedDeps)\n            phaseTestGroups.push(...testGroups);\n        }\n\n        if (phaseTestGroups.length) {\n          await dispatcher!.run(phaseTestGroups, extraEnvByProjectId);\n          await dispatcher.stop();\n          for (const [projectId, envProduced] of dispatcher.producedEnvByProjectId()) {\n            const extraEnv = extraEnvByProjectId.get(projectId) || {};\n            extraEnvByProjectId.set(projectId, { ...extraEnv, ...envProduced });\n          }\n        }\n\n        // If the worker broke, fail everything, we have no way of knowing which\n        // projects failed.\n        if (!failureTracker.hasWorkerErrors()) {\n          for (const { project, projectSuite } of projects) {\n            const hasFailedDeps = project.deps.some(p => !successfulProjects.has(p));\n            if (!hasFailedDeps && !projectSuite.allTests().some(test => !test.ok()))\n              successfulProjects.add(project);\n          }\n        }\n      }\n    },\n    teardown: async ({ phases }) => {\n      for (const { dispatcher } of phases.reverse())\n        await dispatcher.stop();\n    },\n  };\n}\n\nexport function createStartDevServerTask(): Task<TestRun> {\n  return {\n    title: 'start dev server',\n    setup: async ({ config }, errors, softErrors) => {\n      if (config.plugins.some(plugin => !!plugin.devServerCleanup)) {\n        errors.push({ message: `DevServer is already running` });\n        return;\n      }\n      for (const plugin of config.plugins)\n        plugin.devServerCleanup = await plugin.instance?.startDevServer?.();\n      if (!config.plugins.some(plugin => !!plugin.devServerCleanup))\n        errors.push({ message: `DevServer is not available in the package you are using. Did you mean to use component testing?` });\n    },\n\n    teardown: async ({ config }) => {\n      for (const plugin of config.plugins) {\n        await plugin.devServerCleanup?.();\n        plugin.devServerCleanup = undefined;\n      }\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["import_util", "fs", "config", "path"]
}

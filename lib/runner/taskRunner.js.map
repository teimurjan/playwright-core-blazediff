{
  "version": 3,
  "sources": ["../../src/runner/taskRunner.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ManualPromise, monotonicTime } from 'playwright-core/lib/utils';\nimport { colors } from 'playwright-core/lib/utils';\nimport { debug } from 'playwright-core/lib/utilsBundle';\n\n\nimport { SigIntWatcher } from './sigIntWatcher';\nimport { serializeError } from '../util';\n\nimport type { FullResult, TestError } from '../../types/testReporter';\nimport type { InternalReporter } from '../reporters/internalReporter';\n\ntype TaskPhase<Context> = (context: Context, errors: TestError[], softErrors: TestError[]) => Promise<void> | void;\nexport type Task<Context> = { title: string, setup?: TaskPhase<Context>, teardown?: TaskPhase<Context> };\n\nexport class TaskRunner<Context> {\n  private _tasks: Task<Context>[] = [];\n  private _reporter: InternalReporter;\n  private _hasErrors = false;\n  private _interrupted = false;\n  private _isTearDown = false;\n  private _globalTimeoutForError: number;\n\n  constructor(reporter: InternalReporter, globalTimeoutForError: number) {\n    this._reporter = reporter;\n    this._globalTimeoutForError = globalTimeoutForError;\n  }\n\n  addTask(task: Task<Context>) {\n    this._tasks.push(task);\n  }\n\n  async run(context: Context, deadline: number, cancelPromise?: ManualPromise<void>): Promise<FullResult['status']> {\n    const { status, cleanup } = await this.runDeferCleanup(context, deadline, cancelPromise);\n    const teardownStatus = await cleanup();\n    return status === 'passed' ? teardownStatus : status;\n  }\n\n  async runDeferCleanup(context: Context, deadline: number, cancelPromise = new ManualPromise<void>()): Promise<{ status: FullResult['status'], cleanup: () => Promise<FullResult['status']> }> {\n    const sigintWatcher = new SigIntWatcher();\n    const timeoutWatcher = new TimeoutWatcher(deadline);\n    const teardownRunner = new TaskRunner<Context>(this._reporter, this._globalTimeoutForError);\n    teardownRunner._isTearDown = true;\n\n    let currentTaskName: string | undefined;\n\n    const taskLoop = async () => {\n      for (const task of this._tasks) {\n        currentTaskName = task.title;\n        if (this._interrupted)\n          break;\n        debug('pw:test:task')(`\"${task.title}\" started`);\n        const errors: TestError[] = [];\n        const softErrors: TestError[] = [];\n        try {\n          teardownRunner._tasks.unshift({ title: `teardown for ${task.title}`, setup: task.teardown });\n          await task.setup?.(context, errors, softErrors);\n        } catch (e) {\n          debug('pw:test:task')(`error in \"${task.title}\": `, e);\n          errors.push(serializeError(e));\n        } finally {\n          for (const error of [...softErrors, ...errors])\n            this._reporter.onError?.(error);\n          if (errors.length) {\n            if (!this._isTearDown)\n              this._interrupted = true;\n            this._hasErrors = true;\n          }\n        }\n        debug('pw:test:task')(`\"${task.title}\" finished`);\n      }\n    };\n\n    await Promise.race([\n      taskLoop(),\n      cancelPromise,\n      sigintWatcher.promise(),\n      timeoutWatcher.promise,\n    ]);\n\n    sigintWatcher.disarm();\n    timeoutWatcher.disarm();\n\n    // Prevent subsequent tasks from running.\n    this._interrupted = true;\n\n    let status: FullResult['status'] = 'passed';\n    if (sigintWatcher.hadSignal() || cancelPromise?.isDone()) {\n      status = 'interrupted';\n    } else if (timeoutWatcher.timedOut()) {\n      this._reporter.onError?.({ message: colors.red(`Timed out waiting ${this._globalTimeoutForError / 1000}s for the ${currentTaskName} to run`) });\n      status = 'timedout';\n    } else if (this._hasErrors) {\n      status = 'failed';\n    }\n    cancelPromise?.resolve();\n    // Note that upon hitting deadline, we \"run cleanup\", but it exits immediately\n    // because of the same deadline. Essentially, we're not performing any cleanup.\n    const cleanup = () => teardownRunner.runDeferCleanup(context, deadline).then(r => r.status);\n    return { status, cleanup };\n  }\n}\n\nclass TimeoutWatcher {\n  private _timedOut = false;\n  readonly promise = new ManualPromise();\n  private _timer: NodeJS.Timeout | undefined;\n\n  constructor(deadline: number) {\n    if (!deadline)\n      return;\n\n    if (deadline - monotonicTime() <= 0) {\n      this._timedOut = true;\n      this.promise.resolve();\n      return;\n    }\n    this._timer = setTimeout(() => {\n      this._timedOut = true;\n      this.promise.resolve();\n    }, deadline - monotonicTime());\n  }\n\n  timedOut(): boolean {\n    return this._timedOut;\n  }\n\n  disarm() {\n    clearTimeout(this._timer);\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_utils"]
}

{
  "version": 3,
  "sources": ["../../src/runner/dispatcher.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ManualPromise,  eventsHelper } from 'playwright-core/lib/utils';\nimport { colors } from 'playwright-core/lib/utils';\n\nimport { addSuggestedRebaseline } from './rebase';\nimport { WorkerHost } from './workerHost';\nimport { serializeConfig } from '../common/ipc';\n\nimport type { FailureTracker } from './failureTracker';\nimport type { ProcessExitData } from './processHost';\nimport type { TestGroup } from './testGroups';\nimport type { TestError, TestResult, TestStep } from '../../types/testReporter';\nimport type { FullConfigInternal } from '../common/config';\nimport type { AttachmentPayload, DonePayload, RunPayload, SerializedConfig, StepBeginPayload, StepEndPayload, TeardownErrorsPayload, TestBeginPayload, TestEndPayload, TestOutputPayload } from '../common/ipc';\nimport type { Suite } from '../common/test';\nimport type { TestCase } from '../common/test';\nimport type { ReporterV2 } from '../reporters/reporterV2';\nimport type { RegisteredListener } from 'playwright-core/lib/utils';\n\n\nexport type EnvByProjectId = Map<string, Record<string, string | undefined>>;\n\nexport class Dispatcher {\n  private _workerSlots: { busy: boolean, worker?: WorkerHost, jobDispatcher?: JobDispatcher }[] = [];\n  private _queue: TestGroup[] = [];\n  private _workerLimitPerProjectId = new Map<string, number>();\n  private _queuedOrRunningHashCount = new Map<string, number>();\n  private _finished = new ManualPromise<void>();\n  private _isStopped = true;\n\n  private _config: FullConfigInternal;\n  private _reporter: ReporterV2;\n  private _failureTracker: FailureTracker;\n\n  private _extraEnvByProjectId: EnvByProjectId = new Map();\n  private _producedEnvByProjectId: EnvByProjectId = new Map();\n\n  constructor(config: FullConfigInternal, reporter: ReporterV2, failureTracker: FailureTracker) {\n    this._config = config;\n    this._reporter = reporter;\n    this._failureTracker = failureTracker;\n    for (const project of config.projects) {\n      if (project.workers)\n        this._workerLimitPerProjectId.set(project.id, project.workers);\n    }\n  }\n\n  private _findFirstJobToRun() {\n    // Always pick the first job that can be run while respecting the project worker limit.\n    for (let index = 0; index < this._queue.length; index++) {\n      const job = this._queue[index];\n      const projectIdWorkerLimit = this._workerLimitPerProjectId.get(job.projectId);\n      if (!projectIdWorkerLimit)\n        return index;\n      const runningWorkersWithSameProjectId = this._workerSlots.filter(w => w.busy && w.worker && w.worker.projectId() === job.projectId).length;\n      if (runningWorkersWithSameProjectId < projectIdWorkerLimit)\n        return index;\n    }\n    return -1;\n  }\n\n  private _scheduleJob() {\n    // NOTE: keep this method synchronous for easier reasoning.\n\n    // 0. No more running jobs after stop.\n    if (this._isStopped)\n      return;\n\n    // 1. Find a job to run.\n    const jobIndex = this._findFirstJobToRun();\n    if (jobIndex === -1)\n      return;\n    const job = this._queue[jobIndex];\n\n    // 2. Find a worker with the same hash, or just some free worker.\n    let workerIndex = this._workerSlots.findIndex(w => !w.busy && w.worker && w.worker.hash() === job.workerHash && !w.worker.didSendStop());\n    if (workerIndex === -1)\n      workerIndex = this._workerSlots.findIndex(w => !w.busy);\n    if (workerIndex === -1) {\n      // No workers available, bail out.\n      return;\n    }\n\n    // 3. Claim both the job and the worker slot.\n    this._queue.splice(jobIndex, 1);\n    const jobDispatcher = new JobDispatcher(job, this._reporter, this._failureTracker, () => this.stop().catch(() => {}));\n    this._workerSlots[workerIndex].busy = true;\n    this._workerSlots[workerIndex].jobDispatcher = jobDispatcher;\n\n    // 4. Run the job. This is the only async operation.\n    void this._runJobInWorker(workerIndex, jobDispatcher).then(() => {\n\n      // 5. Release the worker slot.\n      this._workerSlots[workerIndex].jobDispatcher = undefined;\n      this._workerSlots[workerIndex].busy = false;\n\n      // 6. Check whether we are done or should schedule another job.\n      this._checkFinished();\n      this._scheduleJob();\n    });\n  }\n\n  private async _runJobInWorker(index: number, jobDispatcher: JobDispatcher) {\n    const job = jobDispatcher.job;\n\n    // 0. Perhaps skip the whole job?\n    if (jobDispatcher.skipWholeJob())\n      return;\n\n    let worker = this._workerSlots[index].worker;\n\n    // 1. Restart the worker if it has the wrong hash or is being stopped already.\n    if (worker && (worker.hash() !== job.workerHash || worker.didSendStop())) {\n      await worker.stop();\n      worker = undefined;\n      if (this._isStopped) // Check stopped signal after async hop.\n        return;\n    }\n\n    // 2. Start the worker if it is down.\n    let startError;\n    if (!worker) {\n      worker = this._createWorker(job, index, serializeConfig(this._config, true));\n      this._workerSlots[index].worker = worker;\n      worker.on('exit', () => this._workerSlots[index].worker = undefined);\n      startError = await worker.start();\n      if (this._isStopped) // Check stopped signal after async hop.\n        return;\n    }\n\n    // 3. Finally, run some tests in the worker! Or fail all of them because of startup error...\n    if (startError)\n      jobDispatcher.onExit(startError);\n    else\n      jobDispatcher.runInWorker(worker);\n    const result = await jobDispatcher.jobResult;\n    this._updateCounterForWorkerHash(job.workerHash, -1);\n\n    // 4. When worker encounters error, we stop it and create a new one.\n    //    We also do not keep the worker alive if it cannot serve any more jobs.\n    if (result.didFail)\n      void worker.stop(true /* didFail */);\n    else if (this._isWorkerRedundant(worker))\n      void worker.stop();\n\n    // 5. Possibly queue a new job with leftover tests and/or retries.\n    if (!this._isStopped && result.newJob) {\n      this._queue.unshift(result.newJob);\n      this._updateCounterForWorkerHash(result.newJob.workerHash, +1);\n    }\n  }\n\n  private _checkFinished() {\n    if (this._finished.isDone())\n      return;\n\n    // Check that we have no more work to do.\n    if (this._queue.length && !this._isStopped)\n      return;\n\n    // Make sure all workers have finished the current job.\n    if (this._workerSlots.some(w => w.busy))\n      return;\n\n    this._finished.resolve();\n  }\n\n  private _isWorkerRedundant(worker: WorkerHost) {\n    let workersWithSameHash = 0;\n    for (const slot of this._workerSlots) {\n      if (slot.worker && !slot.worker.didSendStop() && slot.worker.hash() === worker.hash())\n        workersWithSameHash++;\n    }\n    return workersWithSameHash > this._queuedOrRunningHashCount.get(worker.hash())!;\n  }\n\n  private _updateCounterForWorkerHash(hash: string, delta: number) {\n    this._queuedOrRunningHashCount.set(hash, delta + (this._queuedOrRunningHashCount.get(hash) || 0));\n  }\n\n  async run(testGroups: TestGroup[], extraEnvByProjectId: EnvByProjectId) {\n    this._extraEnvByProjectId = extraEnvByProjectId;\n    this._queue = testGroups;\n    for (const group of testGroups)\n      this._updateCounterForWorkerHash(group.workerHash, +1);\n    this._isStopped = false;\n    this._workerSlots = [];\n    // 0. Stop right away if we have reached max failures.\n    if (this._failureTracker.hasReachedMaxFailures())\n      void this.stop();\n    // 1. Allocate workers.\n    for (let i = 0; i < this._config.config.workers; i++)\n      this._workerSlots.push({ busy: false });\n    // 2. Schedule enough jobs.\n    for (let i = 0; i < this._workerSlots.length; i++)\n      this._scheduleJob();\n    this._checkFinished();\n    // 3. More jobs are scheduled when the worker becomes free.\n    // 4. Wait for all jobs to finish.\n    await this._finished;\n  }\n\n  _createWorker(testGroup: TestGroup, parallelIndex: number, loaderData: SerializedConfig) {\n    const projectConfig = this._config.projects.find(p => p.id === testGroup.projectId)!;\n    const outputDir = projectConfig.project.outputDir;\n    const worker = new WorkerHost(testGroup, parallelIndex, loaderData, this._extraEnvByProjectId.get(testGroup.projectId) || {}, outputDir);\n    const handleOutput = (params: TestOutputPayload) => {\n      const chunk = chunkFromParams(params);\n      if (worker.didFail()) {\n        // Note: we keep reading stdio from workers that are currently stopping after failure,\n        // to debug teardown issues. However, we avoid spoiling the test result from\n        // the next retry.\n        return { chunk };\n      }\n      const currentlyRunning = this._workerSlots[parallelIndex].jobDispatcher?.currentlyRunning();\n      if (!currentlyRunning)\n        return { chunk };\n      return { chunk, test: currentlyRunning.test, result: currentlyRunning.result };\n    };\n    worker.on('stdOut', (params: TestOutputPayload) => {\n      const { chunk, test, result } = handleOutput(params);\n      result?.stdout.push(chunk);\n      this._reporter.onStdOut?.(chunk, test, result);\n    });\n    worker.on('stdErr', (params: TestOutputPayload) => {\n      const { chunk, test, result } = handleOutput(params);\n      result?.stderr.push(chunk);\n      this._reporter.onStdErr?.(chunk, test, result);\n    });\n    worker.on('teardownErrors', (params: TeardownErrorsPayload) => {\n      this._failureTracker.onWorkerError();\n      for (const error of params.fatalErrors)\n        this._reporter.onError?.(error);\n    });\n    worker.on('exit', () => {\n      const producedEnv = this._producedEnvByProjectId.get(testGroup.projectId) || {};\n      this._producedEnvByProjectId.set(testGroup.projectId, { ...producedEnv, ...worker.producedEnv() });\n    });\n    return worker;\n  }\n\n  producedEnvByProjectId() {\n    return this._producedEnvByProjectId;\n  }\n\n  async stop() {\n    if (this._isStopped)\n      return;\n    this._isStopped = true;\n    await Promise.all(this._workerSlots.map(({ worker }) => worker?.stop()));\n    this._checkFinished();\n  }\n}\n\nclass JobDispatcher {\n  jobResult = new ManualPromise<{ newJob?: TestGroup, didFail: boolean }>();\n\n  readonly job: TestGroup;\n  private _reporter: ReporterV2;\n  private _failureTracker: FailureTracker;\n  private _stopCallback: () => void;\n  private _listeners: RegisteredListener[] = [];\n  private _failedTests = new Set<TestCase>();\n  private _failedWithNonRetriableError = new Set<TestCase|Suite>();\n  private _remainingByTestId = new Map<string, TestCase>();\n  private _dataByTestId = new Map<string, { test: TestCase, result: TestResult, steps: Map<string, TestStep> }>();\n  private _parallelIndex = 0;\n  private _workerIndex = 0;\n  private _currentlyRunning: { test: TestCase, result: TestResult } | undefined;\n\n  constructor(job: TestGroup, reporter: ReporterV2, failureTracker: FailureTracker, stopCallback: () => void) {\n    this.job = job;\n    this._reporter = reporter;\n    this._failureTracker = failureTracker;\n    this._stopCallback = stopCallback;\n    this._remainingByTestId = new Map(this.job.tests.map(e => [e.id, e]));\n  }\n\n  private _onTestBegin(params: TestBeginPayload) {\n    const test = this._remainingByTestId.get(params.testId);\n    if (!test) {\n      // TODO: this should never be the case, report an internal error?\n      return;\n    }\n    const result = test._appendTestResult();\n    this._dataByTestId.set(test.id, { test, result, steps: new Map() });\n    result.parallelIndex = this._parallelIndex;\n    result.workerIndex = this._workerIndex;\n    result.startTime = new Date(params.startWallTime);\n    this._reporter.onTestBegin?.(test, result);\n    this._currentlyRunning = { test, result };\n  }\n\n  private _onTestEnd(params: TestEndPayload) {\n    if (this._failureTracker.hasReachedMaxFailures()) {\n      // Do not show more than one error to avoid confusion, but report\n      // as interrupted to indicate that we did actually start the test.\n      params.status = 'interrupted';\n      params.errors = [];\n    }\n    const data = this._dataByTestId.get(params.testId);\n    if (!data) {\n      // TODO: this should never be the case, report an internal error?\n      return;\n    }\n    this._dataByTestId.delete(params.testId);\n    this._remainingByTestId.delete(params.testId);\n    const { result, test } = data;\n    result.duration = params.duration;\n    result.errors = params.errors;\n    result.error = result.errors[0];\n    result.status = params.status;\n    result.annotations = params.annotations;\n    test.annotations = [...params.annotations]; // last test result wins\n    test.expectedStatus = params.expectedStatus;\n    test.timeout = params.timeout;\n    const isFailure = result.status !== 'skipped' && result.status !== test.expectedStatus;\n    if (isFailure)\n      this._failedTests.add(test);\n    if (params.hasNonRetriableError)\n      this._addNonretriableTestAndSerialModeParents(test);\n    this._reportTestEnd(test, result);\n    this._currentlyRunning = undefined;\n  }\n\n  private _addNonretriableTestAndSerialModeParents(test: TestCase) {\n    this._failedWithNonRetriableError.add(test);\n    for (let parent: Suite | undefined = test.parent; parent; parent = parent.parent) {\n      if (parent._parallelMode === 'serial')\n        this._failedWithNonRetriableError.add(parent);\n    }\n  }\n\n  private _onStepBegin(params: StepBeginPayload) {\n    const data = this._dataByTestId.get(params.testId);\n    if (!data) {\n      // The test has finished, but steps are still coming. Just ignore them.\n      return;\n    }\n    const { result, steps, test } = data;\n    const parentStep = params.parentStepId ? steps.get(params.parentStepId) : undefined;\n    const step: TestStep = {\n      title: params.title,\n      titlePath: () => {\n        const parentPath = parentStep?.titlePath() || [];\n        return [...parentPath, params.title];\n      },\n      parent: parentStep,\n      category: params.category,\n      startTime: new Date(params.wallTime),\n      duration: -1,\n      steps: [],\n      attachments: [],\n      annotations: [],\n      location: params.location,\n    };\n    steps.set(params.stepId, step);\n    (parentStep || result).steps.push(step);\n    this._reporter.onStepBegin?.(test, result, step);\n  }\n\n  private _onStepEnd(params: StepEndPayload) {\n    const data = this._dataByTestId.get(params.testId);\n    if (!data) {\n      // The test has finished, but steps are still coming. Just ignore them.\n      return;\n    }\n    const { result, steps, test } = data;\n    const step = steps.get(params.stepId);\n    if (!step) {\n      this._reporter.onStdErr?.('Internal error: step end without step begin: ' + params.stepId, test, result);\n      return;\n    }\n    step.duration = params.wallTime - step.startTime.getTime();\n    if (params.error)\n      step.error = params.error;\n    if (params.suggestedRebaseline)\n      addSuggestedRebaseline(step.location!, params.suggestedRebaseline);\n    step.annotations = params.annotations;\n    steps.delete(params.stepId);\n    this._reporter.onStepEnd?.(test, result, step);\n  }\n\n  private _onAttach(params: AttachmentPayload) {\n    const data = this._dataByTestId.get(params.testId)!;\n    if (!data) {\n      // The test has finished, but attachments are still coming. Just ignore them.\n      return;\n    }\n    const attachment = {\n      name: params.name,\n      path: params.path,\n      contentType: params.contentType,\n      body: params.body !== undefined ? Buffer.from(params.body, 'base64') : undefined\n    };\n    data.result.attachments.push(attachment);\n    if (params.stepId) {\n      const step = data.steps.get(params.stepId);\n      if (step)\n        step.attachments.push(attachment);\n      else\n        this._reporter.onStdErr?.('Internal error: step id not found: ' + params.stepId);\n    }\n  }\n\n  private _failTestWithErrors(test: TestCase, errors: TestError[]) {\n    const runData = this._dataByTestId.get(test.id);\n    // There might be a single test that has started but has not finished yet.\n    let result: TestResult;\n    if (runData) {\n      result = runData.result;\n    } else {\n      result = test._appendTestResult();\n      this._reporter.onTestBegin?.(test, result);\n    }\n    result.errors = [...errors];\n    result.error = result.errors[0];\n    result.status = errors.length ? 'failed' : 'skipped';\n    this._reportTestEnd(test, result);\n    this._failedTests.add(test);\n  }\n\n  private _massSkipTestsFromRemaining(testIds: Set<string>, errors: TestError[]) {\n    for (const test of this._remainingByTestId.values()) {\n      if (!testIds.has(test.id))\n        continue;\n      if (!this._failureTracker.hasReachedMaxFailures()) {\n        this._failTestWithErrors(test, errors);\n        errors = []; // Only report errors for the first test.\n      }\n      this._remainingByTestId.delete(test.id);\n    }\n    if (errors.length) {\n      // We had fatal errors after all tests have passed - most likely in some teardown.\n      // Let's just fail the test run.\n      this._failureTracker.onWorkerError();\n      for (const error of errors)\n        this._reporter.onError?.(error);\n    }\n  }\n\n  private _onDone(params: DonePayload & { unexpectedExitError?: TestError }) {\n    // We won't file remaining if:\n    // - there are no remaining\n    // - we are here not because something failed\n    // - no unrecoverable worker error\n    if (!this._remainingByTestId.size && !this._failedTests.size && !params.fatalErrors.length && !params.skipTestsDueToSetupFailure.length && !params.fatalUnknownTestIds && !params.unexpectedExitError) {\n      this._finished({ didFail: false });\n      return;\n    }\n\n    for (const testId of params.fatalUnknownTestIds || []) {\n      const test = this._remainingByTestId.get(testId);\n      if (test) {\n        this._remainingByTestId.delete(testId);\n        this._failTestWithErrors(test, [{ message: `Test not found in the worker process. Make sure test title does not change.` }]);\n      }\n    }\n\n    if (params.fatalErrors.length) {\n      // In case of fatal errors, report first remaining test as failing with these errors,\n      // and all others as skipped.\n      this._massSkipTestsFromRemaining(new Set(this._remainingByTestId.keys()), params.fatalErrors);\n    }\n    // Handle tests that should be skipped because of the setup failure.\n    this._massSkipTestsFromRemaining(new Set(params.skipTestsDueToSetupFailure), []);\n\n    if (params.unexpectedExitError) {\n      // When worker exits during a test, we blame the test itself.\n      //\n      // The most common situation when worker exits while not running a test is:\n      //   worker failed to require the test file (at the start) because of an exception in one of imports.\n      // In this case, \"skip\" all remaining tests, to avoid running into the same exception over and over.\n      if (this._currentlyRunning)\n        this._massSkipTestsFromRemaining(new Set([this._currentlyRunning.test.id]), [params.unexpectedExitError]);\n      else\n        this._massSkipTestsFromRemaining(new Set(this._remainingByTestId.keys()), [params.unexpectedExitError]);\n    }\n\n    const retryCandidates = new Set<TestCase>();\n    const serialSuitesWithFailures = new Set<Suite>();\n\n    for (const failedTest of this._failedTests) {\n      if (this._failedWithNonRetriableError.has(failedTest))\n        continue;\n      retryCandidates.add(failedTest);\n\n      let outermostSerialSuite: Suite | undefined;\n      for (let parent: Suite | undefined = failedTest.parent; parent; parent = parent.parent) {\n        if (parent._parallelMode ===  'serial')\n          outermostSerialSuite = parent;\n      }\n      if (outermostSerialSuite && !this._failedWithNonRetriableError.has(outermostSerialSuite))\n        serialSuitesWithFailures.add(outermostSerialSuite);\n    }\n\n    // If we have failed tests that belong to a serial suite,\n    // we should skip all future tests from the same serial suite.\n    const testsBelongingToSomeSerialSuiteWithFailures = [...this._remainingByTestId.values()].filter(test => {\n      let parent: Suite | undefined = test.parent;\n      while (parent && !serialSuitesWithFailures.has(parent))\n        parent = parent.parent;\n      return !!parent;\n    });\n    this._massSkipTestsFromRemaining(new Set(testsBelongingToSomeSerialSuiteWithFailures.map(test => test.id)), []);\n\n    for (const serialSuite of serialSuitesWithFailures) {\n      // Add all tests from failed serial suites for possible retry.\n      // These will only be retried together, because they have the same\n      // \"retries\" setting and the same number of previous runs.\n      serialSuite.allTests().forEach(test => retryCandidates.add(test));\n    }\n\n    const remaining = [...this._remainingByTestId.values()];\n    for (const test of retryCandidates) {\n      if (test.results.length < test.retries + 1)\n        remaining.push(test);\n    }\n\n    // This job is over, we will schedule another one.\n    const newJob = remaining.length ? { ...this.job, tests: remaining } : undefined;\n    this._finished({ didFail: true, newJob });\n  }\n\n  onExit(data: ProcessExitData) {\n    const unexpectedExitError: TestError | undefined = data.unexpectedly ? {\n      message: `Error: worker process exited unexpectedly (code=${data.code}, signal=${data.signal})`\n    } : undefined;\n    this._onDone({ skipTestsDueToSetupFailure: [], fatalErrors: [], unexpectedExitError });\n  }\n\n  private _finished(result: { newJob?: TestGroup, didFail: boolean }) {\n    eventsHelper.removeEventListeners(this._listeners);\n    this.jobResult.resolve(result);\n  }\n\n  runInWorker(worker: WorkerHost) {\n    this._parallelIndex = worker.parallelIndex;\n    this._workerIndex = worker.workerIndex;\n\n    const runPayload: RunPayload = {\n      file: this.job.requireFile,\n      entries: this.job.tests.map(test => {\n        return { testId: test.id, retry: test.results.length };\n      }),\n    };\n    worker.runTestGroup(runPayload);\n\n    this._listeners = [\n      eventsHelper.addEventListener(worker, 'testBegin', this._onTestBegin.bind(this)),\n      eventsHelper.addEventListener(worker, 'testEnd', this._onTestEnd.bind(this)),\n      eventsHelper.addEventListener(worker, 'stepBegin', this._onStepBegin.bind(this)),\n      eventsHelper.addEventListener(worker, 'stepEnd', this._onStepEnd.bind(this)),\n      eventsHelper.addEventListener(worker, 'attach', this._onAttach.bind(this)),\n      eventsHelper.addEventListener(worker, 'done', this._onDone.bind(this)),\n      eventsHelper.addEventListener(worker, 'exit', this.onExit.bind(this)),\n    ];\n  }\n\n  skipWholeJob(): boolean {\n    // If all the tests in a group are skipped, we report them immediately\n    // without sending anything to a worker. This avoids creating unnecessary worker processes.\n    //\n    // However, if there is at least one non-skipped test in a group, we'll send\n    // the whole group to the worker process and report tests in the natural order,\n    // with skipped tests mixed in-between non-skipped. This makes\n    // for a better reporter experience.\n    const allTestsSkipped = this.job.tests.every(test => test.expectedStatus === 'skipped');\n    if (allTestsSkipped && !this._failureTracker.hasReachedMaxFailures()) {\n      for (const test of this.job.tests) {\n        const result = test._appendTestResult();\n        this._reporter.onTestBegin?.(test, result);\n        result.status = 'skipped';\n        this._reportTestEnd(test, result);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  currentlyRunning() {\n    return this._currentlyRunning;\n  }\n\n  private _reportTestEnd(test: TestCase, result: TestResult) {\n    this._reporter.onTestEnd?.(test, result);\n    const hadMaxFailures = this._failureTracker.hasReachedMaxFailures();\n    this._failureTracker.onTestEnd(test, result);\n    if (this._failureTracker.hasReachedMaxFailures()) {\n      this._stopCallback();\n      if (!hadMaxFailures)\n        this._reporter.onError?.({ message: colors.red(`Testing stopped early after ${this._failureTracker.maxFailures()} maximum allowed failures.`) });\n    }\n  }\n}\n\nfunction chunkFromParams(params: TestOutputPayload): string | Buffer {\n  if (typeof params.text === 'string')\n    return params.text;\n  return Buffer.from(params.buffer!, 'base64');\n}\n"],
  "mappings": "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",
  "names": ["import_utils"]
}

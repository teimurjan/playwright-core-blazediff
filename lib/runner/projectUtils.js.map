{
  "version": 3,
  "sources": ["../../src/runner/projectUtils.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\n\nimport { escapeRegExp } from 'playwright-core/lib/utils';\nimport { minimatch } from 'playwright-core/lib/utilsBundle';\n\nimport { createFileMatcher } from '../util';\n\nimport type { FullProjectInternal } from '../common/config';\n\n\nconst readFileAsync = promisify(fs.readFile);\nconst readDirAsync = promisify(fs.readdir);\n\nfunction wildcardPatternToRegExp(pattern: string): RegExp {\n  return new RegExp('^' + pattern.split('*').map(escapeRegExp).join('.*') + '$', 'ig');\n}\n\nexport function filterProjects(projects: FullProjectInternal[], projectNames?: string[]): FullProjectInternal[] {\n  if (!projectNames)\n    return [...projects];\n\n  const projectNamesToFind = new Set<string>();\n  const unmatchedProjectNames = new Map<string, string>();\n  const patterns = new Set<RegExp>();\n  for (const name of projectNames!) {\n    const lowerCaseName = name.toLocaleLowerCase();\n    if (lowerCaseName.includes('*')) {\n      patterns.add(wildcardPatternToRegExp(lowerCaseName));\n    } else {\n      projectNamesToFind.add(lowerCaseName);\n      unmatchedProjectNames.set(lowerCaseName, name);\n    }\n  }\n\n  const result = projects.filter(project => {\n    const lowerCaseName = project.project.name.toLocaleLowerCase();\n    if (projectNamesToFind.has(lowerCaseName)) {\n      unmatchedProjectNames.delete(lowerCaseName);\n      return true;\n    }\n    for (const regex of patterns) {\n      regex.lastIndex = 0;\n      if (regex.test(lowerCaseName))\n        return true;\n    }\n    return false;\n  });\n\n  if (unmatchedProjectNames.size) {\n    const unknownProjectNames = Array.from(unmatchedProjectNames.values()).map(n => `\"${n}\"`).join(', ');\n    throw new Error(`Project(s) ${unknownProjectNames} not found. Available projects: ${projects.map(p => `\"${p.project.name}\"`).join(', ')}`);\n  }\n\n  if (!result.length) {\n    const allProjects = projects.map(p => `\"${p.project.name}\"`).join(', ');\n    throw new Error(`No projects matched. Available projects: ${allProjects}`);\n  }\n\n\n  return result;\n}\n\nexport function buildTeardownToSetupsMap(projects: FullProjectInternal[]): Map<FullProjectInternal, FullProjectInternal[]> {\n  const result = new Map<FullProjectInternal, FullProjectInternal[]>();\n  for (const project of projects) {\n    if (project.teardown) {\n      const setups = result.get(project.teardown) || [];\n      setups.push(project);\n      result.set(project.teardown, setups);\n    }\n  }\n  return result;\n}\n\nexport function buildProjectsClosure(projects: FullProjectInternal[], hasTests?: (project: FullProjectInternal) => boolean): Map<FullProjectInternal, 'top-level' | 'dependency'> {\n  const result = new Map<FullProjectInternal, 'top-level' | 'dependency'>();\n  const visit = (depth: number, project: FullProjectInternal) => {\n    if (depth > 100) {\n      const error = new Error('Circular dependency detected between projects.');\n      error.stack = '';\n      throw error;\n    }\n\n    if (depth === 0 && hasTests && !hasTests(project))\n      return;\n\n    if (result.get(project) !== 'dependency')\n      result.set(project, depth ? 'dependency' : 'top-level');\n\n    for (const dep of project.deps)\n      visit(depth + 1, dep);\n    if (project.teardown)\n      visit(depth + 1, project.teardown);\n  };\n  for (const p of projects)\n    visit(0, p);\n  return result;\n}\n\nexport function buildDependentProjects(forProjects: FullProjectInternal[], projects: FullProjectInternal[]): Set<FullProjectInternal> {\n  const reverseDeps = new Map<FullProjectInternal, FullProjectInternal[]>(projects.map(p => ([p, []])));\n  for (const project of projects) {\n    for (const dep of project.deps)\n      reverseDeps.get(dep)!.push(project);\n  }\n  const result = new Set<FullProjectInternal>();\n  const visit = (depth: number, project: FullProjectInternal) => {\n    if (depth > 100) {\n      const error = new Error('Circular dependency detected between projects.');\n      error.stack = '';\n      throw error;\n    }\n    result.add(project);\n    for (const reverseDep of reverseDeps.get(project)!)\n      visit(depth + 1, reverseDep);\n    if (project.teardown)\n      visit(depth + 1, project.teardown);\n  };\n  for (const forProject of forProjects)\n    visit(0, forProject);\n  return result;\n}\n\nexport async function collectFilesForProject(project: FullProjectInternal, fsCache = new Map<string, string[]>()): Promise<string[]> {\n  const extensions = new Set(['.js', '.ts', '.mjs', '.mts', '.cjs', '.cts', '.jsx', '.tsx', '.mjsx', '.mtsx', '.cjsx', '.ctsx']);\n  const testFileExtension = (file: string) => extensions.has(path.extname(file));\n  const allFiles = await cachedCollectFiles(project.project.testDir, project.respectGitIgnore, fsCache);\n  const testMatch = createFileMatcher(project.project.testMatch);\n  const testIgnore = createFileMatcher(project.project.testIgnore);\n  const testFiles = allFiles.filter(file => {\n    if (!testFileExtension(file))\n      return false;\n    const isTest = !testIgnore(file) && testMatch(file);\n    if (!isTest)\n      return false;\n    return true;\n  });\n  return testFiles;\n}\n\nasync function cachedCollectFiles(testDir: string, respectGitIgnore: boolean, fsCache: Map<string, string[]>) {\n  const key = testDir + ':' + respectGitIgnore;\n  let result = fsCache.get(key);\n  if (!result) {\n    result = await collectFiles(testDir, respectGitIgnore);\n    fsCache.set(key, result);\n  }\n  return result;\n}\n\nasync function collectFiles(testDir: string, respectGitIgnore: boolean): Promise<string[]> {\n  if (!fs.existsSync(testDir))\n    return [];\n  if (!fs.statSync(testDir).isDirectory())\n    return [];\n\n  type Rule = {\n    dir: string;\n    negate: boolean;\n    match: (s: string, partial?: boolean) => boolean\n  };\n  type IgnoreStatus = 'ignored' | 'included' | 'ignored-but-recurse';\n\n  const checkIgnores = (entryPath: string, rules: Rule[], isDirectory: boolean, parentStatus: IgnoreStatus) => {\n    let status = parentStatus;\n    for (const rule of rules) {\n      const ruleIncludes = rule.negate;\n      if ((status === 'included') === ruleIncludes)\n        continue;\n      const relative = path.relative(rule.dir, entryPath);\n      if (rule.match('/' + relative) || rule.match(relative)) {\n        // Matches \"/dir/file\" or \"dir/file\"\n        status = ruleIncludes ? 'included' : 'ignored';\n      } else if (isDirectory && (rule.match('/' + relative + '/') || rule.match(relative + '/'))) {\n        // Matches \"/dir/subdir/\" or \"dir/subdir/\" for directories.\n        status = ruleIncludes ? 'included' : 'ignored';\n      } else if (isDirectory && ruleIncludes && (rule.match('/' + relative, true) || rule.match(relative, true))) {\n        // Matches \"/dir/donotskip/\" when \"/dir\" is excluded, but \"!/dir/donotskip/file\" is included.\n        status = 'ignored-but-recurse';\n      }\n    }\n    return status;\n  };\n\n  const files: string[] = [];\n\n  const visit = async (dir: string, rules: Rule[], status: IgnoreStatus) => {\n    const entries = await readDirAsync(dir, { withFileTypes: true });\n    entries.sort((a, b) => a.name.localeCompare(b.name));\n\n    if (respectGitIgnore) {\n      const gitignore = entries.find(e => e.isFile() && e.name === '.gitignore');\n      if (gitignore) {\n        const content = await readFileAsync(path.join(dir, gitignore.name), 'utf8');\n        const newRules: Rule[] = content.split(/\\r?\\n/).map(s => {\n          s = s.trim();\n          if (!s)\n            return;\n          // Use flipNegate, because we handle negation ourselves.\n          const rule = new minimatch.Minimatch(s, { matchBase: true, dot: true, flipNegate: true }) as any;\n          if (rule.comment)\n            return;\n          rule.dir = dir;\n          return rule;\n        }).filter(rule => !!rule);\n        rules = [...rules, ...newRules];\n      }\n    }\n\n    for (const entry of entries) {\n      if (entry.name === '.' || entry.name === '..')\n        continue;\n      if (entry.isFile() && entry.name === '.gitignore')\n        continue;\n      if (entry.isDirectory() && entry.name === 'node_modules')\n        continue;\n      const entryPath = path.join(dir, entry.name);\n      const entryStatus = checkIgnores(entryPath, rules, entry.isDirectory(), status);\n      if (entry.isDirectory() && entryStatus !== 'ignored')\n        await visit(entryPath, rules, entryStatus);\n      else if (entry.isFile() && entryStatus === 'included')\n        files.push(entryPath);\n    }\n  };\n  await visit(testDir, [], 'included');\n  return files;\n}\n"],
  "mappings": "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",
  "names": ["import_util", "fs", "path"]
}

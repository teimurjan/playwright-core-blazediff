{
  "version": 3,
  "sources": ["../../src/protocol/serializers.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SerializedValue } from '@protocol/channels';\n\nexport function parseSerializedValue(value: SerializedValue, handles: any[] | undefined): any {\n  return innerParseSerializedValue(value, handles, new Map(), []);\n}\n\nfunction innerParseSerializedValue(value: SerializedValue, handles: any[] | undefined, refs: Map<number, object>, accessChain: Array<string | number>): any {\n  if (value.ref !== undefined)\n    return refs.get(value.ref);\n  if (value.n !== undefined)\n    return value.n;\n  if (value.s !== undefined)\n    return value.s;\n  if (value.b !== undefined)\n    return value.b;\n  if (value.v !== undefined) {\n    if (value.v === 'undefined')\n      return undefined;\n    if (value.v === 'null')\n      return null;\n    if (value.v === 'NaN')\n      return NaN;\n    if (value.v === 'Infinity')\n      return Infinity;\n    if (value.v === '-Infinity')\n      return -Infinity;\n    if (value.v === '-0')\n      return -0;\n  }\n  if (value.d !== undefined)\n    return new Date(value.d);\n  if (value.u !== undefined)\n    return new URL(value.u);\n  if (value.bi !== undefined)\n    return BigInt(value.bi);\n  if (value.e !== undefined) {\n    const error = new Error(value.e.m);\n    error.name = value.e.n;\n    error.stack = value.e.s;\n    return error;\n  }\n  if (value.r !== undefined)\n    return new RegExp(value.r.p, value.r.f);\n  if (value.ta !== undefined) {\n    const ctor = typedArrayKindToConstructor[value.ta.k] as any;\n    return new ctor(value.ta.b.buffer, value.ta.b.byteOffset, value.ta.b.length / ctor.BYTES_PER_ELEMENT);\n  }\n\n  if (value.a !== undefined) {\n    const result: any[] = [];\n    refs.set(value.id!, result);\n    for (let i = 0; i < value.a.length; i++)\n      result.push(innerParseSerializedValue(value.a[i], handles, refs, [...accessChain, i]));\n    return result;\n  }\n  if (value.o !== undefined) {\n    const result: any = {};\n    refs.set(value.id!, result);\n    for (const { k, v } of value.o)\n      result[k] = innerParseSerializedValue(v, handles, refs, [...accessChain, k]);\n    return result;\n  }\n  if (value.h !== undefined) {\n    if (handles === undefined)\n      throw new Error('Unexpected handle');\n    return handles[value.h];\n  }\n  throw new Error(`Attempting to deserialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);\n}\n\nexport type HandleOrValue = { h: number } | { fallThrough: any };\ntype VisitorInfo = {\n  visited: Map<object, number>;\n  lastId: number;\n};\n\nexport function serializeValue(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue {\n  return innerSerializeValue(value, handleSerializer, { lastId: 0, visited: new Map() }, []);\n}\n\nfunction innerSerializeValue(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo, accessChain: Array<string | number>): SerializedValue {\n  const handle = handleSerializer(value);\n  if ('fallThrough' in handle)\n    value = handle.fallThrough;\n  else\n    return handle;\n\n  if (typeof value === 'symbol')\n    return { v: 'undefined' };\n  if (Object.is(value, undefined))\n    return { v: 'undefined' };\n  if (Object.is(value, null))\n    return { v: 'null' };\n  if (Object.is(value, NaN))\n    return { v: 'NaN' };\n  if (Object.is(value, Infinity))\n    return { v: 'Infinity' };\n  if (Object.is(value, -Infinity))\n    return { v: '-Infinity' };\n  if (Object.is(value, -0))\n    return { v: '-0' };\n  if (typeof value === 'boolean')\n    return { b: value };\n  if (typeof value === 'number')\n    return { n: value };\n  if (typeof value === 'string')\n    return { s: value };\n  if (typeof value === 'bigint')\n    return { bi: value.toString() };\n  if (isError(value))\n    return { e: { n: value.name, m: value.message, s: value.stack || '' } };\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n\n  const typedArrayKind = constructorToTypedArrayKind.get(value.constructor);\n  if (typedArrayKind)\n    return { ta: { b: Buffer.from(value.buffer, value.byteOffset, value.byteLength), k: typedArrayKind } };\n\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n\n  if (Array.isArray(value)) {\n    const a = [];\n    const id = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id);\n    for (let i = 0; i < value.length; ++i)\n      a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo, [...accessChain, i]));\n    return { a, id };\n  }\n  if (typeof value === 'object') {\n    const o: { k: string, v: SerializedValue }[] = [];\n    const id = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id);\n    for (const name of Object.keys(value))\n      o.push({ k: name, v: innerSerializeValue(value[name], handleSerializer, visitorInfo, [...accessChain, name]) });\n    return { o, id };\n  }\n  // Likely only functions can reach here.\n  throw new Error(`Attempting to serialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);\n}\n\nfunction accessChainToDisplayString(accessChain: Array<string | number>): string {\n  const chainString = accessChain.map((accessor, i) => {\n    if (typeof accessor === 'string')\n      return i ? `.${accessor}` : accessor;\n    return `[${accessor}]`;\n  }).join('');\n\n  return chainString.length > 0 ? ` at position \"${chainString}\"` : '';\n}\n\nfunction isRegExp(obj: any): obj is RegExp {\n  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nfunction isDate(obj: any): obj is Date {\n  return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';\n}\n\nfunction isURL(obj: any): obj is URL {\n  return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';\n}\n\nfunction isError(obj: any): obj is Error {\n  const proto = obj ? Object.getPrototypeOf(obj) : null;\n  return obj instanceof Error || proto?.name === 'Error' || (proto && isError(proto));\n}\n\n\ntype TypedArrayKind = NonNullable<SerializedValue['ta']>['k'];\nconst typedArrayKindToConstructor: Record<TypedArrayKind, Function> = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array,\n};\nconst constructorToTypedArrayKind: Map<Function, TypedArrayKind> = new Map(Object.entries(typedArrayKindToConstructor).map(([k, v]) => [v, k as TypedArrayKind]));\n"],
  "mappings": "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",
  "names": ["id"]
}

{
  "version": 3,
  "sources": ["../../src/protocol/validatorPrimitives.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class ValidationError extends Error {}\nexport type Validator = (arg: any, path: string, context: ValidatorContext) => any;\nexport type ValidatorContext = {\n  tChannelImpl: (names: '*' | string[], arg: any, path: string, context: ValidatorContext) => any;\n  binary: 'toBase64' | 'fromBase64' | 'buffer';\n  isUnderTest: () => boolean;\n};\nexport const scheme: { [key: string]: Validator } = {};\n\nexport function findValidator(type: string, method: string, kind: 'Initializer' | 'Event' | 'Params' | 'Result'): Validator {\n  const validator = maybeFindValidator(type, method, kind);\n  if (!validator)\n    throw new ValidationError(`Unknown scheme for ${kind}: ${type}.${method}`);\n  return validator;\n}\nexport function maybeFindValidator(type: string, method: string, kind: 'Initializer' | 'Event' | 'Params' | 'Result'): Validator | undefined {\n  const schemeName = type + (kind === 'Initializer' ? '' : method[0].toUpperCase() + method.substring(1)) + kind;\n  return scheme[schemeName];\n}\nexport function createMetadataValidator(): Validator {\n  return tOptional(scheme['Metadata']);\n}\n\nexport const tFloat: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  if (arg instanceof Number)\n    return arg.valueOf();\n  if (typeof arg === 'number')\n    return arg;\n  throw new ValidationError(`${path}: expected float, got ${typeof arg}`);\n};\nexport const tInt: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  let value: number;\n  if (arg instanceof Number)\n    value = arg.valueOf();\n  else if (typeof arg === 'number')\n    value = arg;\n  else\n    throw new ValidationError(`${path}: expected integer, got ${typeof arg}`);\n  if (!Number.isInteger(value))\n    throw new ValidationError(`${path}: expected integer, got float ${value}`);\n  return value;\n};\nexport const tBoolean: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  if (arg instanceof Boolean)\n    return arg.valueOf();\n  if (typeof arg === 'boolean')\n    return arg;\n  throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);\n};\nexport const tString: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  if (arg instanceof String)\n    return arg.valueOf();\n  if (typeof arg === 'string')\n    return arg;\n  throw new ValidationError(`${path}: expected string, got ${typeof arg}`);\n};\nexport const tBinary: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  if (context.binary === 'fromBase64') {\n    if (arg instanceof String)\n      return Buffer.from(arg.valueOf(), 'base64');\n    if (typeof arg === 'string')\n      return Buffer.from(arg, 'base64');\n    throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);\n  }\n  if (context.binary === 'toBase64') {\n    if (!(arg instanceof Buffer))\n      throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);\n    return (arg as Buffer).toString('base64');\n  }\n  if (context.binary === 'buffer') {\n    if (!(arg instanceof Buffer))\n      throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);\n    return arg;\n  }\n  throw new ValidationError(`Unsupported binary behavior \"${context.binary}\"`);\n};\nexport const tUndefined: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  if (Object.is(arg, undefined))\n    return arg;\n  throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);\n};\nexport const tAny: Validator = (arg: any, path: string, context: ValidatorContext) => {\n  return arg;\n};\nexport const tOptional = (v: Validator): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    if (Object.is(arg, undefined))\n      return arg;\n    return v(arg, path, context);\n  };\n};\nexport const tArray = (v: Validator): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    if (!Array.isArray(arg))\n      throw new ValidationError(`${path}: expected array, got ${typeof arg}`);\n    return arg.map((x, index) => v(x, path + '[' + index + ']', context));\n  };\n};\nexport const tObject = (s: { [key: string]: Validator }): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    if (Object.is(arg, null))\n      throw new ValidationError(`${path}: expected object, got null`);\n    if (typeof arg !== 'object')\n      throw new ValidationError(`${path}: expected object, got ${typeof arg}`);\n    const result: any = {};\n    for (const [key, v] of Object.entries(s)) {\n      const value = v(arg[key], path ? path + '.' + key : key, context);\n      if (!Object.is(value, undefined))\n        result[key] = value;\n    }\n    if (context.isUnderTest()) {\n      for (const [key, value] of Object.entries(arg)) {\n        if (key.startsWith('__testHook'))\n          result[key] = value;\n      }\n    }\n    return result;\n  };\n};\nexport const tEnum = (e: string[]): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    if (!e.includes(arg))\n      throw new ValidationError(`${path}: expected one of (${e.join('|')})`);\n    return arg;\n  };\n};\nexport const tChannel = (names: '*' | string[]): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    return context.tChannelImpl(names, arg, path, context);\n  };\n};\nexport const tType = (name: string): Validator => {\n  return (arg: any, path: string, context: ValidatorContext) => {\n    const v = scheme[name];\n    if (!v)\n      throw new ValidationError(path + ': unknown type \"' + name + '\"');\n    return v(arg, path, context);\n  };\n};\n"],
  "mappings": "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",
  "names": []
}

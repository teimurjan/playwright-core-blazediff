{
  "version": 3,
  "sources": ["../src/util.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport url from 'url';\nimport util from 'util';\n\nimport { parseStackFrame, sanitizeForFilePath, calculateSha1, isRegExp, isString, stringifyStackFrames } from 'playwright-core/lib/utils';\nimport { colors, debug, mime, minimatch } from 'playwright-core/lib/utilsBundle';\n\nimport type { Location } from './../types/testReporter';\nimport type { TestInfoErrorImpl } from './common/ipc';\nimport type { StackFrame } from '@protocol/channels';\nimport type { RawStack } from 'playwright-core/lib/utils';\nimport type { TestCase } from './common/test';\n\nconst PLAYWRIGHT_TEST_PATH = path.join(__dirname, '..');\nconst PLAYWRIGHT_CORE_PATH = path.dirname(require.resolve('playwright-core/package.json'));\n\nexport function filterStackTrace(e: Error): { message: string, stack: string, cause?: ReturnType<typeof filterStackTrace> } {\n  const name = e.name ? e.name + ': ' : '';\n  const cause = e.cause instanceof Error ? filterStackTrace(e.cause) : undefined;\n  if (process.env.PWDEBUGIMPL)\n    return { message: name + e.message, stack: e.stack || '', cause };\n\n  const stackLines = stringifyStackFrames(filteredStackTrace(e.stack?.split('\\n') || []));\n  return {\n    message: name + e.message,\n    stack: `${name}${e.message}${stackLines.map(line => '\\n' + line).join('')}`,\n    cause,\n  };\n}\n\nexport function filterStackFile(file: string) {\n  if (!process.env.PWDEBUGIMPL && file.startsWith(PLAYWRIGHT_TEST_PATH))\n    return false;\n  if (!process.env.PWDEBUGIMPL && file.startsWith(PLAYWRIGHT_CORE_PATH))\n    return false;\n  return true;\n}\n\nexport function filteredStackTrace(rawStack: RawStack): StackFrame[] {\n  const frames: StackFrame[] = [];\n  for (const line of rawStack) {\n    const frame = parseStackFrame(line, path.sep, !!process.env.PWDEBUGIMPL);\n    if (!frame || !frame.file)\n      continue;\n    if (!filterStackFile(frame.file))\n      continue;\n    frames.push(frame);\n  }\n  return frames;\n}\n\nexport function serializeError(error: Error | any): TestInfoErrorImpl {\n  if (error instanceof Error)\n    return filterStackTrace(error);\n  return {\n    value: util.inspect(error)\n  };\n}\n\nexport type Matcher = (value: string) => boolean;\n\nexport type TestFileFilter = {\n  re?: RegExp;\n  exact?: string;\n  line: number | null;\n  column: number | null;\n};\n\nexport type TestCaseFilter = (test: TestCase) => boolean;\n\nexport function createFileFiltersFromArguments(args: string[]): TestFileFilter[] {\n  return args.map(arg => {\n    const match = /^(.*?):(\\d+):?(\\d+)?$/.exec(arg);\n    return {\n      re: forceRegExp(match ? match[1] : arg),\n      line: match ? parseInt(match[2], 10) : null,\n      column: match?.[3] ? parseInt(match[3], 10) : null,\n    };\n  });\n}\n\nexport function createFileMatcherFromArguments(args: string[]): Matcher {\n  const filters = createFileFiltersFromArguments(args);\n  return createFileMatcher(filters.map(filter => filter.re || filter.exact || ''));\n}\n\nexport function createFileMatcher(patterns: string | RegExp | (string | RegExp)[]): Matcher {\n  const reList: RegExp[] = [];\n  const filePatterns: string[] = [];\n  for (const pattern of Array.isArray(patterns) ? patterns : [patterns]) {\n    if (isRegExp(pattern)) {\n      reList.push(pattern);\n    } else {\n      if (!pattern.startsWith('**/'))\n        filePatterns.push('**/' + pattern);\n      else\n        filePatterns.push(pattern);\n    }\n  }\n  return (filePath: string) => {\n    for (const re of reList) {\n      re.lastIndex = 0;\n      if (re.test(filePath))\n        return true;\n    }\n    // Windows might still receive unix style paths from Cygwin or Git Bash.\n    // Check against the file url as well.\n    if (path.sep === '\\\\') {\n      const fileURL = url.pathToFileURL(filePath).href;\n      for (const re of reList) {\n        re.lastIndex = 0;\n        if (re.test(fileURL))\n          return true;\n      }\n    }\n    for (const pattern of filePatterns) {\n      if (minimatch(filePath, pattern, { nocase: true, dot: true }))\n        return true;\n    }\n    return false;\n  };\n}\n\nexport function createTitleMatcher(patterns: RegExp | RegExp[]): Matcher {\n  const reList = Array.isArray(patterns) ? patterns : [patterns];\n  return (value: string) => {\n    for (const re of reList) {\n      re.lastIndex = 0;\n      if (re.test(value))\n        return true;\n    }\n    return false;\n  };\n}\n\nexport function mergeObjects<A extends object, B extends object, C extends object>(a: A | undefined | void, b: B | undefined | void, c: C | undefined | void): A & B & C {\n  const result = { ...a } as any;\n  for (const x of [b, c].filter(Boolean)) {\n    for (const [name, value] of Object.entries(x as any)) {\n      if (!Object.is(value, undefined))\n        result[name] = value;\n    }\n  }\n  return result as any;\n}\n\nexport function forceRegExp(pattern: string): RegExp {\n  const match = pattern.match(/^\\/(.*)\\/([gi]*)$/);\n  if (match)\n    return new RegExp(match[1], match[2]);\n  return new RegExp(pattern, 'gi');\n}\n\nexport function relativeFilePath(file: string): string {\n  if (!path.isAbsolute(file))\n    return file;\n  return path.relative(process.cwd(), file);\n}\n\nexport function formatLocation(location: Location) {\n  return relativeFilePath(location.file) + ':' + location.line + ':' + location.column;\n}\n\nexport function errorWithFile(file: string, message: string) {\n  return new Error(`${relativeFilePath(file)}: ${message}`);\n}\n\nexport function expectTypes(receiver: any, types: string[], matcherName: string) {\n  if (typeof receiver !== 'object' || !types.includes(receiver.constructor.name)) {\n    const commaSeparated = types.slice();\n    const lastType = commaSeparated.pop();\n    const typesString = commaSeparated.length ? commaSeparated.join(', ') + ' or ' + lastType : lastType;\n    throw new Error(`${matcherName} can be only used with ${typesString} object${types.length > 1 ? 's' : ''}`);\n  }\n}\n\nexport const windowsFilesystemFriendlyLength = 60;\n\nexport function trimLongString(s: string, length = 100) {\n  if (s.length <= length)\n    return s;\n  const hash = calculateSha1(s);\n  const middle = `-${hash.substring(0, 5)}-`;\n  const start = Math.floor((length - middle.length) / 2);\n  const end = length - middle.length - start;\n  return s.substring(0, start) + middle + s.slice(-end);\n}\n\nexport function addSuffixToFilePath(filePath: string, suffix: string): string {\n  const ext = path.extname(filePath);\n  const base = filePath.substring(0, filePath.length - ext.length);\n  return base + suffix + ext;\n}\n\nexport function sanitizeFilePathBeforeExtension(filePath: string, ext?: string): string {\n  ext ??= path.extname(filePath);\n  const base = filePath.substring(0, filePath.length - ext.length);\n  return sanitizeForFilePath(base) + ext;\n}\n\n/**\n * Returns absolute path contained within parent directory.\n */\nexport function getContainedPath(parentPath: string, subPath: string = ''): string | null {\n  const resolvedPath = path.resolve(parentPath, subPath);\n  if (resolvedPath === parentPath || resolvedPath.startsWith(parentPath + path.sep))\n    return resolvedPath;\n  return null;\n}\n\nexport const debugTest = debug('pw:test');\n\nexport const callLogText = (log: string[] | undefined) => {\n  if (!log || !log.some(l => !!l))\n    return '';\n  return `\nCall log:\n${colors.dim(log.join('\\n'))}\n`;\n};\n\nconst folderToPackageJsonPath = new Map<string, string>();\n\nexport function getPackageJsonPath(folderPath: string): string {\n  const cached = folderToPackageJsonPath.get(folderPath);\n  if (cached !== undefined)\n    return cached;\n\n  const packageJsonPath = path.join(folderPath, 'package.json');\n  if (fs.existsSync(packageJsonPath)) {\n    folderToPackageJsonPath.set(folderPath, packageJsonPath);\n    return packageJsonPath;\n  }\n\n  const parentFolder = path.dirname(folderPath);\n  if (folderPath === parentFolder) {\n    folderToPackageJsonPath.set(folderPath, '');\n    return '';\n  }\n\n  const result = getPackageJsonPath(parentFolder);\n  folderToPackageJsonPath.set(folderPath, result);\n  return result;\n}\n\nexport function resolveReporterOutputPath(defaultValue: string, configDir: string, configValue: string | undefined) {\n  if (configValue)\n    return path.resolve(configDir, configValue);\n  let basePath = getPackageJsonPath(configDir);\n  basePath = basePath ? path.dirname(basePath) : process.cwd();\n  return path.resolve(basePath, defaultValue);\n}\n\nexport async function normalizeAndSaveAttachment(outputPath: string, name: string, options: { path?: string, body?: string | Buffer, contentType?: string } = {}): Promise<{ name: string; path?: string; body?: Buffer; contentType: string; }> {\n  if (options.path === undefined && options.body === undefined)\n    return { name, contentType: 'text/plain' };\n  if ((options.path !== undefined ? 1 : 0) + (options.body !== undefined ? 1 : 0) !== 1)\n    throw new Error(`Exactly one of \"path\" and \"body\" must be specified`);\n  if (options.path !== undefined) {\n    const hash = calculateSha1(options.path);\n\n    if (!isString(name))\n      throw new Error('\"name\" should be string.');\n\n    const sanitizedNamePrefix = sanitizeForFilePath(name) + '-';\n    const dest = path.join(outputPath, 'attachments', sanitizedNamePrefix + hash + path.extname(options.path));\n    await fs.promises.mkdir(path.dirname(dest), { recursive: true });\n    await fs.promises.copyFile(options.path, dest);\n    const contentType = options.contentType ?? (mime.getType(path.basename(options.path)) || 'application/octet-stream');\n    return { name, contentType, path: dest };\n  } else {\n    const contentType = options.contentType ?? (typeof options.body === 'string' ? 'text/plain' : 'application/octet-stream');\n    return { name, contentType, body: typeof options.body === 'string' ? Buffer.from(options.body) : options.body };\n  }\n}\n\nexport function fileIsModule(file: string): boolean {\n  if (file.endsWith('.mjs') || file.endsWith('.mts'))\n    return true;\n  if (file.endsWith('.cjs') || file.endsWith('.cts'))\n    return false;\n  const folder = path.dirname(file);\n  return folderIsModule(folder);\n}\n\nfunction folderIsModule(folder: string): boolean {\n  const packageJsonPath = getPackageJsonPath(folder);\n  if (!packageJsonPath)\n    return false;\n  // Rely on `require` internal caching logic.\n  return require(packageJsonPath).type === 'module';\n}\n\nconst packageJsonMainFieldCache = new Map<string, string | undefined>();\n\nfunction getMainFieldFromPackageJson(packageJsonPath: string) {\n  if (!packageJsonMainFieldCache.has(packageJsonPath)) {\n    let mainField: string | undefined;\n    try {\n      mainField = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).main;\n    } catch {\n    }\n    packageJsonMainFieldCache.set(packageJsonPath, mainField);\n  }\n  return packageJsonMainFieldCache.get(packageJsonPath);\n}\n\n// This method performs \"file extension subsitution\" to find the ts, js or similar source file\n// based on the import specifier, which might or might not have an extension. See TypeScript docs:\n// https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution.\nconst kExtLookups = new Map([\n  ['.js', ['.jsx', '.ts', '.tsx']],\n  ['.jsx', ['.tsx']],\n  ['.cjs', ['.cts']],\n  ['.mjs', ['.mts']],\n  ['', ['.js', '.ts', '.jsx', '.tsx', '.cjs', '.mjs', '.cts', '.mts']],\n]);\nfunction resolveImportSpecifierExtension(resolved: string): string | undefined {\n  if (fileExists(resolved))\n    return resolved;\n\n  for (const [ext, others] of kExtLookups) {\n    if (!resolved.endsWith(ext))\n      continue;\n    for (const other of others) {\n      const modified = resolved.substring(0, resolved.length - ext.length) + other;\n      if (fileExists(modified))\n        return modified;\n    }\n    break;  // Do not try '' when a more specific extension like '.jsx' matched.\n  }\n}\n\n// This method resolves directory imports and performs \"file extension subsitution\".\n// It is intended to be called after the path mapping resolution.\n//\n// Directory imports follow the --moduleResolution=bundler strategy from tsc.\n// https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution\n// https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler\n//\n// See also Node.js \"folder as module\" behavior:\n// https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-as-modules.\nexport function resolveImportSpecifierAfterMapping(resolved: string, afterPathMapping: boolean): string | undefined {\n  const resolvedFile = resolveImportSpecifierExtension(resolved);\n  if (resolvedFile)\n    return resolvedFile;\n\n  if (dirExists(resolved)) {\n    const packageJsonPath = path.join(resolved, 'package.json');\n\n    if (afterPathMapping) {\n      // Most notably, the module resolution algorithm is not performed after the path mapping.\n      // This means no node_modules lookup or package.json#exports.\n      //\n      // Only the \"folder as module\" Node.js behavior is respected:\n      //  - consult `package.json#main`;\n      //  - look for `index.js` or similar.\n      const mainField = getMainFieldFromPackageJson(packageJsonPath);\n      const mainFieldResolved = mainField ? resolveImportSpecifierExtension(path.resolve(resolved, mainField)) : undefined;\n      return mainFieldResolved || resolveImportSpecifierExtension(path.join(resolved, 'index'));\n    }\n\n    // If we import a package, let Node.js figure out the correct import based on package.json.\n    // This also covers the \"main\" field for \"folder as module\".\n    if (fileExists(packageJsonPath))\n      return resolved;\n\n    // Implement the \"folder as module\" Node.js behavior.\n    // Note that we do not delegate to Node.js, because we support this for ESM as well,\n    // following the TypeScript \"bundler\" mode.\n    const dirImport = path.join(resolved, 'index');\n    return resolveImportSpecifierExtension(dirImport);\n  }\n}\n\nfunction fileExists(resolved: string) {\n  return fs.statSync(resolved, { throwIfNoEntry: false })?.isFile();\n}\n\nexport async function fileExistsAsync(resolved: string) {\n  try {\n    const stat = await fs.promises.stat(resolved);\n    return stat.isFile();\n  } catch {\n    return false;\n  }\n}\n\nfunction dirExists(resolved: string) {\n  return fs.statSync(resolved, { throwIfNoEntry: false })?.isDirectory();\n}\n\nexport async function removeDirAndLogToConsole(dir: string) {\n  try {\n    if (!fs.existsSync(dir))\n      return;\n    // eslint-disable-next-line no-console\n    console.log(`Removing ${await fs.promises.realpath(dir)}`);\n    await fs.promises.rm(dir, { recursive: true, force: true });\n  } catch {\n  }\n}\n\nexport const ansiRegex = new RegExp('([\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~])))', 'g');\nexport function stripAnsiEscapes(str: string): string {\n  return str.replace(ansiRegex, '');\n}\n"],
  "mappings": "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",
  "names": ["path", "util", "url", "fs"]
}

{
  "version": 3,
  "sources": ["../../src/transform/transform.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport Module from 'module';\nimport path from 'path';\nimport url from 'url';\n\nimport crypto from 'crypto';\n\nimport { loadTsConfig } from '../third_party/tsconfig-loader';\nimport { createFileMatcher, fileIsModule, resolveImportSpecifierAfterMapping } from '../util';\nimport { sourceMapSupport } from '../utilsBundle';\nimport { belongsToNodeModules, currentFileDepsCollector, getFromCompilationCache, installSourceMapSupport } from './compilationCache';\nimport { addHook } from '../third_party/pirates';\n\nimport type { BabelPlugin, BabelTransformFunction } from './babelBundle';\nimport type { Location } from '../../types/testReporter';\nimport type { LoadedTsConfig } from '../third_party/tsconfig-loader';\nimport type { Matcher } from '../util';\n\n\nconst version = require('../../package.json').version;\n\ntype ParsedTsConfigData = {\n  pathsBase?: string;\n  paths: { key: string, values: string[] }[];\n  allowJs: boolean;\n};\nconst cachedTSConfigs = new Map<string, ParsedTsConfigData[]>();\n\nexport type TransformConfig = {\n  babelPlugins: [string, any?][];\n  external: string[];\n};\n\nlet _transformConfig: TransformConfig = {\n  babelPlugins: [],\n  external: [],\n};\n\nlet _externalMatcher: Matcher = () => false;\n\nexport function setTransformConfig(config: TransformConfig) {\n  _transformConfig = config;\n  _externalMatcher = createFileMatcher(_transformConfig.external);\n}\n\nexport function transformConfig(): TransformConfig {\n  return _transformConfig;\n}\n\nlet _singleTSConfigPath: string | undefined;\nlet _singleTSConfig: ParsedTsConfigData[] | undefined;\n\nexport function setSingleTSConfig(value: string | undefined) {\n  _singleTSConfigPath = value;\n}\n\nexport function singleTSConfig(): string | undefined {\n  return _singleTSConfigPath;\n}\n\nfunction validateTsConfig(tsconfig: LoadedTsConfig): ParsedTsConfigData {\n  // When no explicit baseUrl is set, resolve paths relative to the tsconfig file.\n  // See https://www.typescriptlang.org/tsconfig#paths\n  const pathsBase = tsconfig.absoluteBaseUrl ?? tsconfig.paths?.pathsBasePath;\n  // Only add the catch-all mapping when baseUrl is specified\n  const pathsFallback = tsconfig.absoluteBaseUrl ? [{ key: '*', values: ['*'] }] : [];\n  return {\n    allowJs: !!tsconfig.allowJs,\n    pathsBase,\n    paths: Object.entries(tsconfig.paths?.mapping || {}).map(([key, values]) => ({ key, values })).concat(pathsFallback)\n  };\n}\n\nfunction loadAndValidateTsconfigsForFile(file: string): ParsedTsConfigData[] {\n  if (_singleTSConfigPath && !_singleTSConfig)\n    _singleTSConfig = loadTsConfig(_singleTSConfigPath).map(validateTsConfig);\n  if (_singleTSConfig)\n    return _singleTSConfig;\n  return loadAndValidateTsconfigsForFolder(path.dirname(file));\n}\n\nfunction loadAndValidateTsconfigsForFolder(folder: string): ParsedTsConfigData[] {\n  const foldersWithConfig: string[] = [];\n  let currentFolder = path.resolve(folder);\n  let result: ParsedTsConfigData[] | undefined;\n  while (true) {\n    const cached = cachedTSConfigs.get(currentFolder);\n    if (cached) {\n      result = cached;\n      break;\n    }\n\n    foldersWithConfig.push(currentFolder);\n\n    for (const name of ['tsconfig.json', 'jsconfig.json']) {\n      const configPath = path.join(currentFolder, name);\n      if (fs.existsSync(configPath)) {\n        const loaded = loadTsConfig(configPath);\n        result = loaded.map(validateTsConfig);\n        break;\n      }\n    }\n    if (result)\n      break;\n\n    const parentFolder = path.resolve(currentFolder, '../');\n    if (currentFolder === parentFolder)\n      break;\n    currentFolder = parentFolder;\n  }\n\n  result = result || [];\n  for (const folder of foldersWithConfig)\n    cachedTSConfigs.set(folder, result);\n  return result;\n}\n\nconst pathSeparator = process.platform === 'win32' ? ';' : ':';\nconst builtins = new Set(Module.builtinModules);\n\nexport function resolveHook(filename: string, specifier: string): string | undefined {\n  if (specifier.startsWith('node:') || builtins.has(specifier))\n    return;\n  if (!shouldTransform(filename))\n    return;\n\n  if (isRelativeSpecifier(specifier))\n    return resolveImportSpecifierAfterMapping(path.resolve(path.dirname(filename), specifier), false);\n\n  /**\n   * TypeScript discourages path-mapping into node_modules:\n   * https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths-should-not-point-to-monorepo-packages-or-node_modules-packages\n   * However, if path-mapping doesn't yield a result, TypeScript falls back to the default resolution through node_modules.\n   */\n  const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx');\n  const tsconfigs = loadAndValidateTsconfigsForFile(filename);\n  for (const tsconfig of tsconfigs) {\n    if (!isTypeScript && !tsconfig.allowJs)\n      continue;\n    let longestPrefixLength = -1;\n    let pathMatchedByLongestPrefix: string | undefined;\n\n    for (const { key, values } of tsconfig.paths) {\n      let matchedPartOfSpecifier = specifier;\n\n      const [keyPrefix, keySuffix] = key.split('*');\n      if (key.includes('*')) {\n        // * If pattern contains '*' then to match pattern \"<prefix>*<suffix>\" module name must start with the <prefix> and end with <suffix>.\n        // * <MatchedStar> denotes part of the module name between <prefix> and <suffix>.\n        // * If module name can be matches with multiple patterns then pattern with the longest prefix will be picked.\n        // https://github.com/microsoft/TypeScript/blob/f82d0cb3299c04093e3835bc7e29f5b40475f586/src/compiler/moduleNameResolver.ts#L1049\n        if (keyPrefix) {\n          if (!specifier.startsWith(keyPrefix))\n            continue;\n          matchedPartOfSpecifier = matchedPartOfSpecifier.substring(keyPrefix.length, matchedPartOfSpecifier.length);\n        }\n        if (keySuffix) {\n          if (!specifier.endsWith(keySuffix))\n            continue;\n          matchedPartOfSpecifier = matchedPartOfSpecifier.substring(0, matchedPartOfSpecifier.length - keySuffix.length);\n        }\n      } else {\n        if (specifier !== key)\n          continue;\n        matchedPartOfSpecifier = specifier;\n      }\n\n      if (keyPrefix.length <= longestPrefixLength)\n        continue;\n\n      for (const value of values) {\n        let candidate = value;\n        if (value.includes('*'))\n          candidate = candidate.replace('*', matchedPartOfSpecifier);\n        candidate = path.resolve(tsconfig.pathsBase!, candidate);\n        const existing = resolveImportSpecifierAfterMapping(candidate, true);\n        if (existing) {\n          longestPrefixLength = keyPrefix.length;\n          pathMatchedByLongestPrefix = existing;\n        }\n      }\n    }\n    if (pathMatchedByLongestPrefix)\n      return pathMatchedByLongestPrefix;\n  }\n\n  if (path.isAbsolute(specifier)) {\n    // Handle absolute file paths like `import '/path/to/file'`\n    // Do not handle module imports like `import 'fs'`\n    return resolveImportSpecifierAfterMapping(specifier, false);\n  }\n}\n\nexport function shouldTransform(filename: string): boolean {\n  if (_externalMatcher(filename))\n    return false;\n  return !belongsToNodeModules(filename);\n}\n\nlet transformData: Map<string, any>;\n\nexport function setTransformData(pluginName: string, value: any) {\n  transformData.set(pluginName, value);\n}\n\nexport function transformHook(originalCode: string, filename: string, moduleUrl?: string): { code: string, serializedCache?: any } {\n  const hasPreprocessor =\n      process.env.PW_TEST_SOURCE_TRANSFORM &&\n      process.env.PW_TEST_SOURCE_TRANSFORM_SCOPE &&\n      process.env.PW_TEST_SOURCE_TRANSFORM_SCOPE.split(pathSeparator).some(f => filename.startsWith(f));\n  const pluginsPrologue = _transformConfig.babelPlugins;\n  const pluginsEpilogue = hasPreprocessor ? [[process.env.PW_TEST_SOURCE_TRANSFORM!]] as BabelPlugin[] : [];\n  const hash = calculateHash(originalCode, filename, !!moduleUrl, pluginsPrologue, pluginsEpilogue);\n  const { cachedCode, addToCache, serializedCache } = getFromCompilationCache(filename, hash, moduleUrl);\n  if (cachedCode !== undefined)\n    return { code: cachedCode, serializedCache };\n\n  // We don't use any browserslist data, but babel checks it anyway.\n  // Silence the annoying warning.\n  process.env.BROWSERSLIST_IGNORE_OLD_DATA = 'true';\n\n  const { babelTransform }: { babelTransform: BabelTransformFunction } = require('./babelBundle');\n  transformData = new Map<string, any>();\n  const babelResult = babelTransform(originalCode, filename, !!moduleUrl, pluginsPrologue, pluginsEpilogue);\n  if (!babelResult?.code)\n    return { code: originalCode, serializedCache };\n  const { code, map } = babelResult;\n  const added = addToCache!(code, map, transformData);\n  return { code, serializedCache: added.serializedCache };\n}\n\nfunction calculateHash(content: string, filePath: string, isModule: boolean, pluginsPrologue: BabelPlugin[], pluginsEpilogue: BabelPlugin[]): string {\n  const hash = crypto.createHash('sha1')\n      .update(isModule ? 'esm' : 'no_esm')\n      .update(content)\n      .update(filePath)\n      .update(version)\n      .update(pluginsPrologue.map(p => p[0]).join(','))\n      .update(pluginsEpilogue.map(p => p[0]).join(','))\n      .digest('hex');\n  return hash;\n}\n\nexport async function requireOrImport(file: string) {\n  installTransformIfNeeded();\n  const isModule = fileIsModule(file);\n  const esmImport = () => eval(`import(${JSON.stringify(url.pathToFileURL(file))})`);\n  if (isModule) {\n    return await esmImport().finally(async () => {\n      // Compilation cache, which includes source maps, is populated in a post task.\n      // When importing a module results in an error, the very next access to `error.stack`\n      // will need source maps. To make sure source maps have arrived, we insert a task\n      // that will be processed after compilation cache and guarantee that\n      // source maps are available, before `error.stack` is accessed.\n      await new Promise(resolve => setTimeout(resolve, 0));\n    });\n  }\n  const result = require(file);\n  const depsCollector = currentFileDepsCollector();\n  if (depsCollector) {\n    const module = require.cache[file];\n    if (module)\n      collectCJSDependencies(module, depsCollector);\n  }\n  return result;\n}\n\nlet transformInstalled = false;\n\nfunction installTransformIfNeeded() {\n  if (transformInstalled)\n    return;\n  transformInstalled = true;\n\n  installSourceMapSupport();\n\n  const originalResolveFilename = (Module as any)._resolveFilename;\n  function resolveFilename(this: any, specifier: string, parent: Module, ...rest: any[]) {\n    if (parent) {\n      const resolved = resolveHook(parent.filename, specifier);\n      if (resolved !== undefined)\n        specifier = resolved;\n    }\n    return originalResolveFilename.call(this, specifier, parent, ...rest);\n  }\n  (Module as any)._resolveFilename = resolveFilename;\n\n  // Hopefully, one day we can migrate to synchronous loader hooks instead, similar to our esmLoader...\n  addHook((code, filename) => {\n    return transformHook(code, filename).code;\n  }, shouldTransform, ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.mts', '.cjs', '.cts']);\n}\n\nconst collectCJSDependencies = (module: Module, dependencies: Set<string>) => {\n  module.children.forEach(child => {\n    if (!belongsToNodeModules(child.filename) && !dependencies.has(child.filename)) {\n      dependencies.add(child.filename);\n      collectCJSDependencies(child, dependencies);\n    }\n  });\n};\n\nexport function wrapFunctionWithLocation<A extends any[], R>(func: (location: Location, ...args: A) => R): (...args: A) => R {\n  return (...args) => {\n    const oldPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = (error, stackFrames) => {\n      const frame: NodeJS.CallSite = sourceMapSupport.wrapCallSite(stackFrames[1]);\n      const fileName = frame.getFileName();\n      // Node error stacks for modules use file:// urls instead of paths.\n      const file = (fileName && fileName.startsWith('file://')) ? url.fileURLToPath(fileName) : fileName;\n      return {\n        file,\n        line: frame.getLineNumber(),\n        column: frame.getColumnNumber(),\n      };\n    };\n    const oldStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 2;\n    const obj: { stack: Location } = {} as any;\n    Error.captureStackTrace(obj);\n    const location = obj.stack;\n    Error.stackTraceLimit = oldStackTraceLimit;\n    Error.prepareStackTrace = oldPrepareStackTrace;\n    return func(location, ...args);\n  };\n}\n\nfunction isRelativeSpecifier(specifier: string) {\n  return specifier === '.' || specifier === '..' || specifier.startsWith('./') || specifier.startsWith('../');\n}\n"],
  "mappings": "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",
  "names": ["file", "path", "result", "fs", "folder", "Module", "isModule", "crypto", "url", "module"]
}

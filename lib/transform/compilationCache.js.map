{
  "version": 3,
  "sources": ["../../src/transform/compilationCache.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport { isWorkerProcess } from '../common/globals';\nimport { sourceMapSupport } from '../utilsBundle';\n\nexport type MemoryCache = {\n  codePath: string;\n  sourceMapPath: string;\n  dataPath: string;\n  moduleUrl?: string;\n};\n\nexport type SerializedCompilationCache = {\n  sourceMaps: [string, string][],\n  memoryCache: [string, MemoryCache][],\n  fileDependencies: [string, string[]][],\n  externalDependencies: [string, string[]][],\n};\n\n// Assumptions for the compilation cache:\n// - Files in the temp directory we work with can disappear at any moment, either some of them or all together.\n// - Multiple workers can be trying to read from the compilation cache at the same time.\n// - There is a single invocation of the test runner at a time.\n//\n// Therefore, we implement the following logic:\n// - Never assume that file is present, always try to read it to determine whether it's actually present.\n// - Never write to the cache from worker processes to avoid \"multiple writers\" races.\n// - Since we perform all static imports in the runner beforehand, most of the time\n//   workers should be able to read from the cache.\n// - For workers-only dynamic imports or some cache problems, we will re-transpile files in\n//   each worker anew.\n\nexport const cacheDir = process.env.PWTEST_CACHE_DIR || (() => {\n  if (process.platform === 'win32')\n    return path.join(os.tmpdir(), `playwright-transform-cache`);\n  // Use `geteuid()` instead of more natural `os.userInfo().username`\n  // since `os.userInfo()` is not always available.\n  // Note: `process.geteuid()` is not available on windows.\n  // See https://github.com/microsoft/playwright/issues/22721\n  return path.join(os.tmpdir(), `playwright-transform-cache-` + process.geteuid?.());\n})();\n\nconst sourceMaps: Map<string, string> = new Map();\nconst memoryCache = new Map<string, MemoryCache>();\n// Dependencies resolved by the loader.\nconst fileDependencies = new Map<string, Set<string>>();\n// Dependencies resolved by the external bundler.\nconst externalDependencies = new Map<string, Set<string>>();\n\nexport function installSourceMapSupport() {\n  Error.stackTraceLimit = 200;\n\n  sourceMapSupport.install({\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap(source) {\n      if (!sourceMaps.has(source))\n        return null;\n      const sourceMapPath = sourceMaps.get(source)!;\n      try {\n        return {\n          map: JSON.parse(fs.readFileSync(sourceMapPath, 'utf-8')),\n          url: source,\n        };\n      } catch {\n        return null;\n      }\n    }\n  });\n}\n\nfunction _innerAddToCompilationCacheAndSerialize(filename: string, entry: MemoryCache) {\n  sourceMaps.set(entry.moduleUrl || filename, entry.sourceMapPath);\n  memoryCache.set(filename, entry);\n  return {\n    sourceMaps: [[entry.moduleUrl || filename, entry.sourceMapPath]],\n    memoryCache: [[filename, entry]],\n    fileDependencies: [],\n    externalDependencies: [],\n  };\n}\n\ntype CompilationCacheLookupResult = {\n  serializedCache?: any;\n  cachedCode?: string;\n  addToCache?: (code: string, map: any | undefined | null, data: Map<string, any>) => { serializedCache?: any };\n};\n\nexport function getFromCompilationCache(filename: string, hash: string, moduleUrl?: string): CompilationCacheLookupResult {\n  // First check the memory cache by filename, this cache will always work in the worker,\n  // because we just compiled this file in the loader.\n  const cache = memoryCache.get(filename);\n  if (cache?.codePath) {\n    try {\n      return { cachedCode: fs.readFileSync(cache.codePath, 'utf-8') };\n    } catch {\n      // Not able to read the file - fall through.\n    }\n  }\n\n  // Then do the disk cache, this cache works between the Playwright Test runs.\n  const cachePath = calculateCachePath(filename, hash);\n  const codePath = cachePath + '.js';\n  const sourceMapPath = cachePath + '.map';\n  const dataPath = cachePath + '.data';\n  try {\n    const cachedCode = fs.readFileSync(codePath, 'utf8');\n    const serializedCache = _innerAddToCompilationCacheAndSerialize(filename, { codePath, sourceMapPath, dataPath, moduleUrl });\n    return { cachedCode, serializedCache };\n  } catch {\n  }\n\n  return {\n    addToCache: (code: string, map: any | undefined | null, data: Map<string, any>) => {\n      if (isWorkerProcess())\n        return {};\n      fs.mkdirSync(path.dirname(cachePath), { recursive: true });\n      if (map)\n        fs.writeFileSync(sourceMapPath, JSON.stringify(map), 'utf8');\n      if (data.size)\n        fs.writeFileSync(dataPath, JSON.stringify(Object.fromEntries(data.entries()), undefined, 2), 'utf8');\n      fs.writeFileSync(codePath, code, 'utf8');\n      const serializedCache = _innerAddToCompilationCacheAndSerialize(filename, { codePath, sourceMapPath, dataPath, moduleUrl });\n      return { serializedCache };\n    }\n  };\n}\n\nexport function serializeCompilationCache(): SerializedCompilationCache {\n  return {\n    sourceMaps: [...sourceMaps.entries()],\n    memoryCache: [...memoryCache.entries()],\n    fileDependencies: [...fileDependencies.entries()].map(([filename, deps]) => ([filename, [...deps]])),\n    externalDependencies: [...externalDependencies.entries()].map(([filename, deps]) => ([filename, [...deps]])),\n  };\n}\n\nexport function addToCompilationCache(payload: SerializedCompilationCache) {\n  for (const entry of payload.sourceMaps)\n    sourceMaps.set(entry[0], entry[1]);\n  for (const entry of payload.memoryCache)\n    memoryCache.set(entry[0], entry[1]);\n  for (const entry of payload.fileDependencies) {\n    const existing = fileDependencies.get(entry[0]) || [];\n    fileDependencies.set(entry[0], new Set([...entry[1], ...existing]));\n  }\n  for (const entry of payload.externalDependencies) {\n    const existing = externalDependencies.get(entry[0]) || [];\n    externalDependencies.set(entry[0], new Set([...entry[1], ...existing]));\n  }\n}\n\nfunction calculateCachePath(filePath: string, hash: string): string {\n  const fileName = path.basename(filePath, path.extname(filePath)).replace(/\\W/g, '') + '_' + hash;\n  return path.join(cacheDir, hash[0] + hash[1], fileName);\n}\n\n// Since ESM and CJS collect dependencies differently,\n// we go via the global state to collect them.\nlet depsCollector: Set<string> | undefined;\n\nexport function startCollectingFileDeps() {\n  depsCollector = new Set();\n}\n\nexport function stopCollectingFileDeps(filename: string) {\n  if (!depsCollector)\n    return;\n  depsCollector.delete(filename);\n  for (const dep of depsCollector) {\n    if (belongsToNodeModules(dep))\n      depsCollector.delete(dep);\n  }\n  fileDependencies.set(filename, depsCollector);\n  depsCollector = undefined;\n}\n\nexport function currentFileDepsCollector(): Set<string> | undefined {\n  return depsCollector;\n}\n\nexport function setExternalDependencies(filename: string, deps: string[]) {\n  const depsSet = new Set(deps.filter(dep => !belongsToNodeModules(dep) && dep !== filename));\n  externalDependencies.set(filename, depsSet);\n}\n\nexport function fileDependenciesForTest() {\n  return fileDependencies;\n}\n\nexport function collectAffectedTestFiles(changedFile: string, testFileCollector: Set<string>) {\n  const isTestFile = (file: string) => fileDependencies.has(file);\n\n  if (isTestFile(changedFile))\n    testFileCollector.add(changedFile);\n\n  for (const [testFile, deps] of fileDependencies) {\n    if (deps.has(changedFile))\n      testFileCollector.add(testFile);\n  }\n\n  for (const [importingFile, depsOfImportingFile] of externalDependencies) {\n    if (depsOfImportingFile.has(changedFile)) {\n      if (isTestFile(importingFile))\n        testFileCollector.add(importingFile);\n\n      for (const [testFile, depsOfTestFile] of fileDependencies) {\n        if (depsOfTestFile.has(importingFile))\n          testFileCollector.add(testFile);\n      }\n    }\n  }\n}\n\nexport function affectedTestFiles(changes: string[]): string[] {\n  const result = new Set<string>();\n  for (const change of changes)\n    collectAffectedTestFiles(change, result);\n  return [...result];\n}\n\nexport function internalDependenciesForTestFile(filename: string): Set<string> | undefined{\n  return fileDependencies.get(filename);\n}\n\nexport function dependenciesForTestFile(filename: string): Set<string> {\n  const result = new Set<string>();\n  for (const testDependency of fileDependencies.get(filename) || []) {\n    result.add(testDependency);\n    for (const externalDependency of externalDependencies.get(testDependency) || [])\n      result.add(externalDependency);\n  }\n  for (const dep of externalDependencies.get(filename) || [])\n    result.add(dep);\n  return result;\n}\n\n// This is only used in the dev mode, specifically excluding\n// files from packages/playwright*. In production mode, node_modules covers\n// that.\nconst kPlaywrightInternalPrefix = path.resolve(__dirname, '../../../playwright');\n\nexport function belongsToNodeModules(file: string) {\n  if (file.includes(`${path.sep}node_modules${path.sep}`))\n    return true;\n  if (file.startsWith(kPlaywrightInternalPrefix) && (file.endsWith('.js') || file.endsWith('.mjs')))\n    return true;\n  return false;\n}\n\nexport async function getUserData(pluginName: string): Promise<Map<string, any>> {\n  const result = new Map<string, any>();\n  for (const [fileName, cache] of memoryCache) {\n    if (!cache.dataPath)\n      continue;\n    if (!fs.existsSync(cache.dataPath))\n      continue;\n    const data = JSON.parse(await fs.promises.readFile(cache.dataPath, 'utf8'));\n    if (data[pluginName])\n      result.set(fileName, data[pluginName]);\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["path", "os", "fs"]
}

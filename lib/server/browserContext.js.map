{
  "version": 3,
  "sources": ["../../src/server/browserContext.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { createGuid } from './utils/crypto';\nimport { debugMode } from './utils/debug';\nimport { Clock } from './clock';\nimport { Debugger } from './debugger';\nimport { DialogManager } from './dialog';\nimport { BrowserContextAPIRequestContext } from './fetch';\nimport { mkdirIfNeeded } from './utils/fileUtils';\nimport { rewriteErrorMessage } from '../utils/isomorphic/stackTrace';\nimport { HarRecorder } from './har/harRecorder';\nimport { helper } from './helper';\nimport { SdkObject } from './instrumentation';\nimport * as network from './network';\nimport { InitScript } from './page';\nimport { Page, PageBinding } from './page';\nimport { RecorderApp } from './recorder/recorderApp';\nimport { Selectors } from './selectors';\nimport { Tracing } from './trace/recorder/tracing';\nimport * as rawStorageSource from '../generated/storageScriptSource';\n\nimport type { Artifact } from './artifact';\nimport type { Browser, BrowserOptions } from './browser';\nimport type { Download } from './download';\nimport type * as frames from './frames';\nimport type { Progress } from './progress';\nimport type { ClientCertificatesProxy } from './socksClientCertificatesInterceptor';\nimport type { SerializedStorage } from '@injected/storageScript';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\n\nexport abstract class BrowserContext extends SdkObject {\n  static Events = {\n    Console: 'console',\n    Close: 'close',\n    Page: 'page',\n    // Can't use just 'error' due to node.js special treatment of error events.\n    // @see https://nodejs.org/api/events.html#events_error_events\n    PageError: 'pageerror',\n    Request: 'request',\n    Response: 'response',\n    RequestFailed: 'requestfailed',\n    RequestFinished: 'requestfinished',\n    RequestAborted: 'requestaborted',\n    RequestFulfilled: 'requestfulfilled',\n    RequestContinued: 'requestcontinued',\n    BeforeClose: 'beforeclose',\n    VideoStarted: 'videostarted',\n    RecorderEvent: 'recorderevent',\n  };\n\n  readonly _pageBindings = new Map<string, PageBinding>();\n  readonly _options: types.BrowserContextOptions;\n  readonly requestInterceptors: network.RouteHandler[] = [];\n  private _isPersistentContext: boolean;\n  private _closedStatus: 'open' | 'closing' | 'closed' = 'open';\n  readonly _closePromise: Promise<Error>;\n  private _closePromiseFulfill: ((error: Error) => void) | undefined;\n  readonly _permissions = new Map<string, string[]>();\n  readonly _downloads = new Set<Download>();\n  readonly _browser: Browser;\n  readonly _browserContextId: string | undefined;\n  private _selectors: Selectors;\n  private _origins = new Set<string>();\n  readonly _harRecorders = new Map<string, HarRecorder>();\n  readonly tracing: Tracing;\n  readonly fetchRequest: BrowserContextAPIRequestContext;\n  private _customCloseHandler?: () => Promise<any>;\n  readonly _tempDirs: string[] = [];\n  private _creatingStorageStatePage = false;\n  bindingsInitScript?: InitScript;\n  initScripts: InitScript[] = [];\n  private _routesInFlight = new Set<network.Route>();\n  private _debugger!: Debugger;\n  _closeReason: string | undefined;\n  readonly clock: Clock;\n  _clientCertificatesProxy: ClientCertificatesProxy | undefined;\n  private _playwrightBindingExposed = false;\n  readonly dialogManager: DialogManager;\n\n  constructor(browser: Browser, options: types.BrowserContextOptions, browserContextId: string | undefined) {\n    super(browser, 'browser-context');\n    this.attribution.context = this;\n    this._browser = browser;\n    this._options = options;\n    this._browserContextId = browserContextId;\n    this._isPersistentContext = !browserContextId;\n    this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);\n    this._selectors = new Selectors(options.selectorEngines || [], options.testIdAttributeName);\n\n    this.fetchRequest = new BrowserContextAPIRequestContext(this);\n    this.tracing = new Tracing(this, browser.options.tracesDir);\n    this.clock = new Clock(this);\n    this.dialogManager = new DialogManager(this.instrumentation);\n  }\n\n  isPersistentContext(): boolean {\n    return this._isPersistentContext;\n  }\n\n  selectors(): Selectors {\n    return this._selectors;\n  }\n\n  async _initialize() {\n    if (this.attribution.playwright.options.isInternalPlaywright)\n      return;\n    // Debugger will pause execution upon page.pause in headed mode.\n    this._debugger = new Debugger(this);\n\n    // When PWDEBUG=1, show inspector for each context.\n    if (debugMode() === 'inspector')\n      await RecorderApp.show(this, { pauseOnNextStatement: true });\n\n    // When paused, show inspector.\n    if (this._debugger.isPaused())\n      RecorderApp.showInspectorNoReply(this);\n\n    this._debugger.on(Debugger.Events.PausedStateChanged, () => {\n      if (this._debugger.isPaused())\n        RecorderApp.showInspectorNoReply(this);\n    });\n\n    if (debugMode() === 'console') {\n      await this.extendInjectedScript(`\n        function installConsoleApi(injectedScript) { injectedScript.consoleApi.install(); }\n        module.exports = { default: () => installConsoleApi };\n      `);\n    }\n    if (this._options.serviceWorkers === 'block')\n      await this.addInitScript(undefined, `\\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\\n`);\n\n    if (this._options.permissions)\n      await this.grantPermissions(this._options.permissions);\n  }\n\n  debugger(): Debugger {\n    return this._debugger;\n  }\n\n  async _ensureVideosPath() {\n    if (this._options.recordVideo)\n      await mkdirIfNeeded(path.join(this._options.recordVideo.dir, 'dummy'));\n  }\n\n  canResetForReuse(): boolean {\n    if (this._closedStatus !== 'open')\n      return false;\n    return true;\n  }\n\n  static reusableContextHash(params: channels.BrowserNewContextForReuseParams): string {\n    const paramsCopy = { ...params };\n\n    if (paramsCopy.selectorEngines?.length === 0)\n      delete paramsCopy.selectorEngines;\n\n    for (const k of Object.keys(paramsCopy)) {\n      const key = k as keyof channels.BrowserNewContextForReuseParams;\n      if (paramsCopy[key] === defaultNewContextParamValues[key])\n        delete paramsCopy[key];\n    }\n\n    for (const key of paramsThatAllowContextReuse)\n      delete paramsCopy[key];\n    return JSON.stringify(paramsCopy);\n  }\n\n  async resetForReuse(progress: Progress, params: channels.BrowserNewContextForReuseParams | null) {\n    await this.tracing.resetForReuse(progress);\n\n    if (params) {\n      for (const key of paramsThatAllowContextReuse)\n        (this._options as any)[key] = params[key];\n      if (params.testIdAttributeName)\n        this.selectors().setTestIdAttributeName(params.testIdAttributeName);\n    }\n\n    // Close extra pages early.\n    let page: Page | undefined = this.pages()[0];\n    const otherPages = this.possiblyUninitializedPages().filter(p => p !== page);\n    for (const p of otherPages)\n      await p.close();\n    if (page && page.hasCrashed()) {\n      await page.close();\n      page = undefined;\n    }\n\n    // Navigate to about:blank first to ensure no page scripts are running after this point.\n    await page?.mainFrame().gotoImpl(progress, 'about:blank', {});\n\n    // Note: we only need to reset properties from the \"paramsThatAllowContextReuse\" list.\n    // All other properties force a new context.\n    await this.clock.uninstall(progress);\n    await progress.race(this.setUserAgent(this._options.userAgent));\n    await progress.race(this.doUpdateDefaultEmulatedMedia());\n    await progress.race(this.doUpdateDefaultViewport());\n    await this.setStorageState(progress, this._options.storageState, 'resetForReuse');\n\n    await page?.resetForReuse(progress);\n  }\n\n  _browserClosed() {\n    for (const page of this.pages())\n      page._didClose();\n    this._didCloseInternal();\n  }\n\n  private _didCloseInternal() {\n    if (this._closedStatus === 'closed') {\n      // We can come here twice if we close browser context and browser\n      // at the same time.\n      return;\n    }\n    this._clientCertificatesProxy?.close().catch(() => {});\n    this.tracing.abort();\n    if (this._isPersistentContext)\n      this.onClosePersistent();\n    this._closePromiseFulfill!(new Error('Context closed'));\n    this.emit(BrowserContext.Events.Close);\n  }\n\n  pages(): Page[] {\n    return this.possiblyUninitializedPages().filter(page => page.initializedOrUndefined());\n  }\n\n  // BrowserContext methods.\n  abstract possiblyUninitializedPages(): Page[];\n  abstract doCreateNewPage(): Promise<Page>;\n  abstract addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n  abstract setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n  abstract setUserAgent(userAgent: string | undefined): Promise<void>;\n  abstract cancelDownload(uuid: string): Promise<void>;\n  abstract clearCache(): Promise<void>;\n  protected abstract doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n  protected abstract doClearCookies(): Promise<void>;\n  protected abstract doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n  protected abstract doClearPermissions(): Promise<void>;\n  protected abstract doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n  protected abstract doAddInitScript(initScript: InitScript): Promise<void>;\n  protected abstract doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n  protected abstract doUpdateExtraHTTPHeaders(): Promise<void>;\n  protected abstract doUpdateOffline(): Promise<void>;\n  protected abstract doUpdateRequestInterception(): Promise<void>;\n  protected abstract doUpdateDefaultViewport(): Promise<void>;\n  protected abstract doUpdateDefaultEmulatedMedia(): Promise<void>;\n  protected abstract doExposePlaywrightBinding(): Promise<void>;\n  protected abstract doClose(reason: string | undefined): Promise<void>;\n  protected abstract onClosePersistent(): void;\n\n  async cookies(urls: string | string[] | undefined = []): Promise<channels.NetworkCookie[]> {\n    if (urls && !Array.isArray(urls))\n      urls = [urls];\n    return await this.doGetCookies(urls as string[]);\n  }\n\n  async clearCookies(options: {name?: string | RegExp, domain?: string | RegExp, path?: string | RegExp}): Promise<void> {\n    const currentCookies = await this.cookies();\n    await this.doClearCookies();\n\n    const matches = (cookie: channels.NetworkCookie, prop: 'name' | 'domain' | 'path', value: string | RegExp | undefined) => {\n      if (!value)\n        return true;\n      if (value instanceof RegExp) {\n        value.lastIndex = 0;\n        return value.test(cookie[prop]);\n      }\n      return cookie[prop] === value;\n    };\n\n    const cookiesToReadd = currentCookies.filter(cookie => {\n      return !matches(cookie, 'name', options.name)\n        || !matches(cookie, 'domain', options.domain)\n        || !matches(cookie, 'path', options.path);\n    });\n\n    await this.addCookies(cookiesToReadd);\n  }\n\n  setHTTPCredentials(httpCredentials?: types.Credentials): Promise<void> {\n    return this.doSetHTTPCredentials(httpCredentials);\n  }\n\n  getBindingClient(name: string): unknown | undefined {\n    return this._pageBindings.get(name)?.forClient;\n  }\n\n  async exposePlaywrightBindingIfNeeded() {\n    if (this._playwrightBindingExposed)\n      return;\n    this._playwrightBindingExposed = true;\n    await this.doExposePlaywrightBinding();\n\n    this.bindingsInitScript = PageBinding.createInitScript();\n    this.initScripts.push(this.bindingsInitScript);\n    await this.doAddInitScript(this.bindingsInitScript);\n    await this.safeNonStallingEvaluateInAllFrames(this.bindingsInitScript.source, 'main');\n  }\n\n  needsPlaywrightBinding() {\n    return this._playwrightBindingExposed;\n  }\n\n  async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource, forClient?: unknown): Promise<PageBinding> {\n    if (this._pageBindings.has(name))\n      throw new Error(`Function \"${name}\" has been already registered`);\n    for (const page of this.pages()) {\n      if (page.getBinding(name))\n        throw new Error(`Function \"${name}\" has been already registered in one of the pages`);\n    }\n    await progress.race(this.exposePlaywrightBindingIfNeeded());\n    const binding = new PageBinding(name, playwrightBinding, needsHandle);\n    binding.forClient = forClient;\n    this._pageBindings.set(name, binding);\n    try {\n      await progress.race(this.doAddInitScript(binding.initScript));\n      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));\n      return binding;\n    } catch (error) {\n      this._pageBindings.delete(name);\n      throw error;\n    }\n  }\n\n  async removeExposedBindings(bindings: PageBinding[]) {\n    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);\n    for (const binding of bindings)\n      this._pageBindings.delete(binding.name);\n    await this.doRemoveInitScripts(bindings.map(binding => binding.initScript));\n    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\\n`).join('');\n    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');\n  }\n\n  async grantPermissions(permissions: string[], origin?: string) {\n    let resolvedOrigin = '*';\n    if (origin) {\n      const url = new URL(origin);\n      resolvedOrigin = url.origin;\n    }\n    const existing = new Set(this._permissions.get(resolvedOrigin) || []);\n    permissions.forEach(p => existing.add(p));\n    const list = [...existing.values()];\n    this._permissions.set(resolvedOrigin, list);\n    await this.doGrantPermissions(resolvedOrigin, list);\n  }\n\n  async clearPermissions() {\n    this._permissions.clear();\n    await this.doClearPermissions();\n  }\n\n  async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {\n    const oldHeaders = this._options.extraHTTPHeaders;\n    this._options.extraHTTPHeaders = headers;\n    try {\n      await progress.race(this.doUpdateExtraHTTPHeaders());\n    } catch (error) {\n      this._options.extraHTTPHeaders = oldHeaders;\n      // Note: no await, headers will be reset in the background as soon as possible.\n      this.doUpdateExtraHTTPHeaders().catch(() => {});\n      throw error;\n    }\n  }\n\n  async setOffline(progress: Progress, offline: boolean) {\n    const oldOffline = this._options.offline;\n    this._options.offline = offline;\n    try {\n      await progress.race(this.doUpdateOffline());\n    } catch (error) {\n      this._options.offline = oldOffline;\n      // Note: no await, offline will be reset in the background as soon as possible.\n      this.doUpdateOffline().catch(() => {});\n      throw error;\n    }\n  }\n\n  async _loadDefaultContextAsIs(progress: Progress): Promise<Page | undefined> {\n    if (!this.possiblyUninitializedPages().length) {\n      const waitForEvent = helper.waitForEvent(progress, this, BrowserContext.Events.Page);\n      // Race against BrowserContext.close\n      await Promise.race([waitForEvent.promise, this._closePromise]);\n    }\n    const page = this.possiblyUninitializedPages()[0];\n    if (!page)\n      return;\n    const pageOrError = await progress.race(page.waitForInitializedOrError());\n    if (pageOrError instanceof Error)\n      throw pageOrError;\n    await page.mainFrame()._waitForLoadState(progress, 'load');\n    return page;\n  }\n\n  async _loadDefaultContext(progress: Progress) {\n    const defaultPage = await this._loadDefaultContextAsIs(progress);\n    if (!defaultPage)\n      return;\n    const browserName = this._browser.options.name;\n    if ((this._options.isMobile && browserName === 'chromium') || (this._options.locale && browserName === 'webkit')) {\n      // Workaround for:\n      // - chromium fails to change isMobile for existing page;\n      // - webkit fails to change locale for existing page.\n      await this.newPage(progress);\n      await defaultPage.close();\n    }\n  }\n\n  protected _authenticateProxyViaHeader() {\n    const proxy = this._options.proxy || this._browser.options.proxy || { username: undefined, password: undefined };\n    const { username, password } = proxy;\n    if (username) {\n      this._options.httpCredentials = { username, password: password! };\n      const token = Buffer.from(`${username}:${password}`).toString('base64');\n      this._options.extraHTTPHeaders = network.mergeHeaders([\n        this._options.extraHTTPHeaders,\n        network.singleHeader('Proxy-Authorization', `Basic ${token}`),\n      ]);\n    }\n  }\n\n  protected _authenticateProxyViaCredentials() {\n    const proxy = this._options.proxy || this._browser.options.proxy;\n    if (!proxy)\n      return;\n    const { username, password } = proxy;\n    if (username)\n      this._options.httpCredentials = { username, password: password || '' };\n  }\n\n  async addInitScript(progress: Progress | undefined, source: string) {\n    const initScript = new InitScript(source);\n    this.initScripts.push(initScript);\n    try {\n      const promise = this.doAddInitScript(initScript);\n      if (progress)\n        await progress.race(promise);\n      else\n        await promise;\n      return initScript;\n    } catch (error) {\n      // Note: no await, init script will be removed in the background as soon as possible.\n      this.removeInitScripts([initScript]).catch(() => {});\n      throw error;\n    }\n  }\n\n  async removeInitScripts(initScripts: InitScript[]) {\n    const set = new Set(initScripts);\n    this.initScripts = this.initScripts.filter(script => !set.has(script));\n    await this.doRemoveInitScripts(initScripts);\n  }\n\n  async addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void> {\n    // Note: progress is intentionally ignored, because this operation is not cancellable and should not block in the browser anyway.\n    this.requestInterceptors.push(handler);\n    await this.doUpdateRequestInterception();\n  }\n\n  async removeRequestInterceptor(handler: network.RouteHandler): Promise<void> {\n    const index = this.requestInterceptors.indexOf(handler);\n    if (index === -1)\n      return;\n    this.requestInterceptors.splice(index, 1);\n    await this.notifyRoutesInFlightAboutRemovedHandler(handler);\n    await this.doUpdateRequestInterception();\n  }\n\n  isClosingOrClosed() {\n    return this._closedStatus !== 'open';\n  }\n\n  private async _deleteAllDownloads(): Promise<void> {\n    await Promise.all(Array.from(this._downloads).map(download => download.artifact.deleteOnContextClose()));\n  }\n\n  private async _deleteAllTempDirs(): Promise<void> {\n    await Promise.all(this._tempDirs.map(async dir => await fs.promises.unlink(dir).catch(e => {})));\n  }\n\n  setCustomCloseHandler(handler: (() => Promise<any>) | undefined) {\n    this._customCloseHandler = handler;\n  }\n\n  async close(options: { reason?: string }) {\n    if (this._closedStatus === 'open') {\n      if (options.reason)\n        this._closeReason = options.reason;\n      this.emit(BrowserContext.Events.BeforeClose);\n      this._closedStatus = 'closing';\n\n      for (const harRecorder of this._harRecorders.values())\n        await harRecorder.flush();\n      await this.tracing.flush();\n\n      // Cleanup.\n      const promises: Promise<void>[] = [];\n      for (const { context, artifact } of this._browser._idToVideo.values()) {\n        // Wait for the videos to finish.\n        if (context === this)\n          promises.push(artifact.finishedPromise());\n      }\n\n      if (this._customCloseHandler) {\n        await this._customCloseHandler();\n      } else {\n        // Close the context.\n        await this.doClose(options.reason);\n      }\n\n      // We delete downloads after context closure\n      // so that browser does not write to the download file anymore.\n      promises.push(this._deleteAllDownloads());\n      promises.push(this._deleteAllTempDirs());\n      await Promise.all(promises);\n\n      // Custom handler should trigger didCloseInternal itself.\n      if (!this._customCloseHandler)\n        this._didCloseInternal();\n    }\n    await this._closePromise;\n  }\n\n  async newPage(progress: Progress, forStorageState?: boolean): Promise<Page> {\n    let page: Page | undefined;\n    try {\n      this._creatingStorageStatePage = !!forStorageState;\n      page = await progress.race(this.doCreateNewPage());\n      const pageOrError = await progress.race(page.waitForInitializedOrError());\n      if (pageOrError instanceof Page) {\n        if (pageOrError.isClosed())\n          throw new Error('Page has been closed.');\n        return pageOrError;\n      }\n      throw pageOrError;\n    } catch (error) {\n      await page?.close({ reason: 'Failed to create page' }).catch(() => {});\n      throw error;\n    } finally {\n      this._creatingStorageStatePage = false;\n    }\n  }\n\n  addVisitedOrigin(origin: string) {\n    this._origins.add(origin);\n  }\n\n  async storageState(progress: Progress, indexedDB = false): Promise<channels.BrowserContextStorageStateResult> {\n    const result: channels.BrowserContextStorageStateResult = {\n      cookies: await this.cookies(),\n      origins: []\n    };\n    const originsToSave = new Set(this._origins);\n\n    const collectScript = `(() => {\n      const module = {};\n      ${rawStorageSource.source}\n      const script = new (module.exports.StorageScript())(${this._browser.options.name === 'firefox'});\n      return script.collect(${indexedDB});\n    })()`;\n\n    // First try collecting storage stage from existing pages.\n    for (const page of this.pages()) {\n      const origin = page.mainFrame().origin();\n      if (!origin || !originsToSave.has(origin))\n        continue;\n      try {\n        const storage: SerializedStorage = await page.mainFrame().nonStallingEvaluateInExistingContext(collectScript, 'utility');\n        if (storage.localStorage.length || storage.indexedDB?.length)\n          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });\n        originsToSave.delete(origin);\n      } catch {\n        // When failed on the live page, we'll retry on the blank page below.\n      }\n    }\n\n    // If there are still origins to save, create a blank page to iterate over origins.\n    if (originsToSave.size)  {\n      const page = await this.newPage(progress, true /* forStorageState */);\n      try {\n        await page.addRequestInterceptor(progress, route => {\n          route.fulfill({ body: '<html></html>' }).catch(() => {});\n        }, 'prepend');\n        for (const origin of originsToSave) {\n          const frame = page.mainFrame();\n          await frame.gotoImpl(progress, origin, {});\n          const storage: SerializedStorage = await progress.race(frame.evaluateExpression(collectScript, { world: 'utility' }));\n          if (storage.localStorage.length || storage.indexedDB?.length)\n            result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });\n        }\n      } finally {\n        await page.close();\n      }\n    }\n    return result;\n  }\n\n  isCreatingStorageStatePage(): boolean {\n    return this._creatingStorageStatePage;\n  }\n\n  async setStorageState(progress: Progress, state: channels.BrowserNewContextParams['storageState'], mode: 'initial' | 'resetForReuse') {\n    let page: Page | undefined;\n    let interceptor: network.RouteHandler | undefined;\n    try {\n      if (mode !== 'initial') {\n        await progress.race(this.clearCache());\n        await progress.race(this.doClearCookies());\n      }\n\n      if (state?.cookies)\n        await progress.race(this.addCookies(state.cookies));\n\n      const newOrigins = new Map(state?.origins?.map(p => [p.origin, p]) || []);\n      const allOrigins = new Set([...this._origins, ...newOrigins.keys()]);\n      if (allOrigins.size) {\n        if (mode === 'resetForReuse')\n          page = this.pages()[0];\n        if (!page)\n          page = await this.newPage(progress, mode !== 'resetForReuse' /* forStorageState */);\n\n        interceptor = (route: network.Route) => {\n          route.fulfill({ body: '<html></html>' }).catch(() => {});\n        };\n        await page.addRequestInterceptor(progress, interceptor, 'prepend');\n\n        for (const origin of allOrigins) {\n          const frame = page.mainFrame();\n          await frame.gotoImpl(progress, origin, {});\n          const restoreScript = `(() => {\n            const module = {};\n            ${rawStorageSource.source}\n            const script = new (module.exports.StorageScript())(${this._browser.options.name === 'firefox'});\n            return script.restore(${JSON.stringify(newOrigins.get(origin))});\n          })()`;\n          await progress.race(frame.evaluateExpression(restoreScript, { world: 'utility' }));\n        }\n      }\n      this._origins = new Set([...newOrigins.keys()]);\n    } catch (error) {\n      rewriteErrorMessage(error, `Error setting storage state:\\n` + error.message);\n      throw error;\n    } finally {\n      if (mode !== 'resetForReuse')\n        await page?.close();\n      else if (interceptor)\n        await page?.removeRequestInterceptor(interceptor);\n    }\n  }\n\n  async extendInjectedScript(source: string, arg?: any) {\n    const installInFrame = (frame: frames.Frame) => frame.extendInjectedScript(source, arg).catch(() => {});\n    const installInPage = (page: Page) => {\n      page.on(Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);\n      return Promise.all(page.frames().map(installInFrame));\n    };\n    this.on(BrowserContext.Events.Page, installInPage);\n    return Promise.all(this.pages().map(installInPage));\n  }\n\n  async safeNonStallingEvaluateInAllFrames(expression: string, world: types.World, options: { throwOnJSErrors?: boolean } = {}) {\n    await Promise.all(this.pages().map(page => page.safeNonStallingEvaluateInAllFrames(expression, world, options)));\n  }\n\n  harStart(page: Page | null, options: channels.RecordHarOptions): string {\n    const harId = createGuid();\n    this._harRecorders.set(harId, new HarRecorder(this, page, options));\n    return harId;\n  }\n\n  async harExport(harId: string | undefined): Promise<Artifact> {\n    const recorder = this._harRecorders.get(harId || '')!;\n    return recorder.export();\n  }\n\n  addRouteInFlight(route: network.Route) {\n    this._routesInFlight.add(route);\n  }\n\n  removeRouteInFlight(route: network.Route) {\n    this._routesInFlight.delete(route);\n  }\n\n  async notifyRoutesInFlightAboutRemovedHandler(handler: network.RouteHandler): Promise<void> {\n    await Promise.all([...this._routesInFlight].map(route => route.removeHandler(handler)));\n  }\n}\n\nexport function validateBrowserContextOptions(options: types.BrowserContextOptions, browserOptions: BrowserOptions) {\n  if (options.noDefaultViewport && options.deviceScaleFactor !== undefined)\n    throw new Error(`\"deviceScaleFactor\" option is not supported with null \"viewport\"`);\n  if (options.noDefaultViewport && !!options.isMobile)\n    throw new Error(`\"isMobile\" option is not supported with null \"viewport\"`);\n  if (options.acceptDownloads === undefined && browserOptions.name !== 'electron')\n    options.acceptDownloads = 'accept';\n  // Electron requires explicit acceptDownloads: true since we wait for\n  // https://github.com/electron/electron/pull/41718 to be widely shipped.\n  // In 6-12 months, we can remove this check.\n  else if (options.acceptDownloads === undefined && browserOptions.name === 'electron')\n    options.acceptDownloads = 'internal-browser-default';\n  if (!options.viewport && !options.noDefaultViewport)\n    options.viewport = { width: 1280, height: 720 };\n  if (options.recordVideo) {\n    if (!options.recordVideo.size) {\n      if (options.noDefaultViewport) {\n        options.recordVideo.size = { width: 800, height: 600 };\n      } else {\n        const size = options.viewport!;\n        const scale = Math.min(1, 800 / Math.max(size.width, size.height));\n        options.recordVideo.size = {\n          width: Math.floor(size.width * scale),\n          height: Math.floor(size.height * scale)\n        };\n      }\n    }\n    // Make sure both dimensions are odd, this is required for vp8\n    options.recordVideo.size!.width &= ~1;\n    options.recordVideo.size!.height &= ~1;\n  }\n  if (options.proxy)\n    options.proxy = normalizeProxySettings(options.proxy);\n  verifyGeolocation(options.geolocation);\n}\n\nexport function verifyGeolocation(geolocation?: types.Geolocation): asserts geolocation is types.Geolocation {\n  if (!geolocation)\n    return;\n  geolocation.accuracy = geolocation.accuracy || 0;\n  const { longitude, latitude, accuracy } = geolocation;\n  if (longitude < -180 || longitude > 180)\n    throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);\n  if (latitude < -90 || latitude > 90)\n    throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);\n  if (accuracy < 0)\n    throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);\n}\n\nexport function verifyClientCertificates(clientCertificates?: types.BrowserContextOptions['clientCertificates']) {\n  if (!clientCertificates)\n    return;\n  for (const cert of clientCertificates) {\n    if (!cert.origin)\n      throw new Error(`clientCertificates.origin is required`);\n    if (!cert.cert && !cert.key && !cert.passphrase && !cert.pfx)\n      throw new Error('None of cert, key, passphrase or pfx is specified');\n    if (cert.cert && !cert.key)\n      throw new Error('cert is specified without key');\n    if (!cert.cert && cert.key)\n      throw new Error('key is specified without cert');\n    if (cert.pfx && (cert.cert || cert.key))\n      throw new Error('pfx is specified together with cert, key or passphrase');\n  }\n}\n\nexport function normalizeProxySettings(proxy: types.ProxySettings): types.ProxySettings {\n  let { server, bypass } = proxy;\n  let url;\n  try {\n    // new URL('127.0.0.1:8080') throws\n    // new URL('localhost:8080') fails to parse host or protocol\n    // In both of these cases, we need to try re-parse URL with `http://` prefix.\n    url = new URL(server);\n    if (!url.host || !url.protocol)\n      url = new URL('http://' + server);\n  } catch (e) {\n    url = new URL('http://' + server);\n  }\n  if (url.protocol === 'socks4:' && (proxy.username || proxy.password))\n    throw new Error(`Socks4 proxy protocol does not support authentication`);\n  if (url.protocol === 'socks5:' && (proxy.username || proxy.password))\n    throw new Error(`Browser does not support socks5 proxy authentication`);\n  server = url.protocol + '//' + url.host;\n  if (bypass)\n    bypass = bypass.split(',').map(t => t.trim()).join(',');\n  return { ...proxy, server, bypass };\n}\n\nconst paramsThatAllowContextReuse: (keyof channels.BrowserNewContextForReuseParams)[] = [\n  'colorScheme',\n  'forcedColors',\n  'reducedMotion',\n  'contrast',\n  'screen',\n  'userAgent',\n  'viewport',\n  'testIdAttributeName',\n];\n\nconst defaultNewContextParamValues: channels.BrowserNewContextForReuseParams = {\n  noDefaultViewport: false,\n  ignoreHTTPSErrors: false,\n  javaScriptEnabled: true,\n  bypassCSP: false,\n  offline: false,\n  isMobile: false,\n  hasTouch: false,\n  acceptDownloads: 'accept',\n  strictSelectors: false,\n  serviceWorkers: 'allow',\n  locale: 'en-US',\n};\n"],
  "mappings": "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",
  "names": ["import_page", "path", "fs"]
}

{
  "version": 3,
  "sources": ["../../src/server/screenshotter.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { helper } from './helper';\nimport { assert } from '../utils';\nimport { MultiMap } from '../utils/isomorphic/multimap';\n\nimport type * as dom from './dom';\nimport type { Frame } from './frames';\nimport type { Page } from './page';\nimport type { Progress } from './progress';\nimport type * as types from './types';\nimport type { Rect } from '../utils/isomorphic/types';\nimport type { ParsedSelector } from '../utils/isomorphic/selectorParser';\n\n\ndeclare global {\n  interface Window {\n    __pwCleanupScreenshot?: () => void;\n  }\n}\n\nexport type ScreenshotOptions = {\n  type?: 'png' | 'jpeg';\n  quality?: number;\n  omitBackground?: boolean;\n  animations?: 'disabled' | 'allow';\n  mask?: { frame: Frame, selector: string}[];\n  maskColor?: string;\n  fullPage?: boolean;\n  clip?: Rect;\n  scale?: 'css' | 'device';\n  caret?: 'hide' | 'initial';\n  style?: string;\n};\n\nfunction inPagePrepareForScreenshots(screenshotStyle: string, hideCaret: boolean, disableAnimations: boolean, syncAnimations: boolean) {\n  // In WebKit, sync the animations.\n  if (syncAnimations) {\n    const style = document.createElement('style');\n    style.textContent = 'body {}';\n    document.head.appendChild(style);\n    document.documentElement.getBoundingClientRect();\n    style.remove();\n  }\n\n  if (!screenshotStyle && !hideCaret && !disableAnimations)\n    return;\n\n  const collectRoots = (root: Document | ShadowRoot, roots: (Document|ShadowRoot)[] = []): (Document|ShadowRoot)[] => {\n    roots.push(root);\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const node = walker.currentNode;\n      const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n      if (shadowRoot)\n        collectRoots(shadowRoot, roots);\n    } while (walker.nextNode());\n    return roots;\n  };\n\n  const roots = collectRoots(document);\n  const cleanupCallbacks: (() => void)[] = [];\n\n  if (screenshotStyle) {\n    for (const root of roots) {\n      const styleTag = document.createElement('style');\n      styleTag.textContent = screenshotStyle;\n      if (root === document)\n        document.documentElement.append(styleTag);\n      else\n        root.append(styleTag);\n\n      cleanupCallbacks.push(() => {\n        styleTag.remove();\n      });\n    }\n  }\n\n  if (hideCaret) {\n    const elements = new Map<HTMLElement, { value: string, priority: string }>();\n    for (const root of roots) {\n      root.querySelectorAll('input,textarea,[contenteditable]').forEach(element => {\n        elements.set(element as HTMLElement, {\n          value: (element as HTMLElement).style.getPropertyValue('caret-color'),\n          priority: (element as HTMLElement).style.getPropertyPriority('caret-color')\n        });\n        (element as HTMLElement).style.setProperty('caret-color', 'transparent', 'important');\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const [element, value] of elements)\n        element.style.setProperty('caret-color', value.value, value.priority);\n    });\n  }\n\n  if (disableAnimations) {\n    const infiniteAnimationsToResume: Set<Animation> = new Set();\n    const handleAnimations = (root: Document|ShadowRoot): void => {\n      for (const animation of root.getAnimations()) {\n        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))\n          continue;\n        const endTime = animation.effect.getComputedTiming().endTime;\n        if (Number.isFinite(endTime)) {\n          try {\n            animation.finish();\n          } catch (e) {\n            // animation.finish() should not throw for\n            // finite animations, but we'd like to be on the\n            // safe side.\n          }\n        } else {\n          try {\n            animation.cancel();\n            infiniteAnimationsToResume.add(animation);\n          } catch (e) {\n            // animation.cancel() should not throw for\n            // infinite animations, but we'd like to be on the\n            // safe side.\n          }\n        }\n      }\n    };\n    for (const root of roots) {\n      const handleRootAnimations: (() => void) = handleAnimations.bind(null, root);\n      handleRootAnimations();\n      root.addEventListener('transitionrun', handleRootAnimations);\n      root.addEventListener('animationstart', handleRootAnimations);\n      cleanupCallbacks.push(() => {\n        root.removeEventListener('transitionrun', handleRootAnimations);\n        root.removeEventListener('animationstart', handleRootAnimations);\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const animation of infiniteAnimationsToResume) {\n        try {\n          animation.play();\n        } catch (e) {\n          // animation.play() should never throw, but\n          // we'd like to be on the safe side.\n        }\n      }\n    });\n  }\n\n  window.__pwCleanupScreenshot = () => {\n    for (const cleanupCallback of cleanupCallbacks)\n      cleanupCallback();\n    delete window.__pwCleanupScreenshot;\n  };\n}\n\nexport class Screenshotter {\n  private _queue = new TaskQueue();\n  private _page: Page;\n\n  constructor(page: Page) {\n    this._page = page;\n    this._queue = new TaskQueue();\n  }\n\n  private async _originalViewportSize(progress: Progress): Promise<types.Size> {\n    let viewportSize = this._page.emulatedSize()?.viewport;\n    if (!viewportSize)\n      viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({ width: window.innerWidth, height: window.innerHeight }));\n    return viewportSize;\n  }\n\n  private async _fullPageSize(progress: Progress): Promise<types.Size> {\n    const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {\n      if (!document.body || !document.documentElement)\n        return null;\n      return {\n        width: Math.max(\n            document.body.scrollWidth, document.documentElement.scrollWidth,\n            document.body.offsetWidth, document.documentElement.offsetWidth,\n            document.body.clientWidth, document.documentElement.clientWidth\n        ),\n        height: Math.max(\n            document.body.scrollHeight, document.documentElement.scrollHeight,\n            document.body.offsetHeight, document.documentElement.offsetHeight,\n            document.body.clientHeight, document.documentElement.clientHeight\n        ),\n      };\n    });\n    return fullPageSize!;\n  }\n\n  async screenshotPage(progress: Progress, options: ScreenshotOptions): Promise<Buffer> {\n    const format = validateScreenshotOptions(options);\n    return this._queue.postTask(async () => {\n      progress.log('taking page screenshot');\n      const viewportSize = await this._originalViewportSize(progress);\n      await this._preparePageForScreenshot(progress, this._page.mainFrame(), options.style, options.caret !== 'initial', options.animations === 'disabled');\n      try {\n        if (options.fullPage) {\n          const fullPageSize = await this._fullPageSize(progress);\n          let documentRect = { x: 0, y: 0, width: fullPageSize.width, height: fullPageSize.height };\n          const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;\n          if (options.clip)\n            documentRect = trimClipToSize(options.clip, documentRect);\n          return await this._screenshot(progress, format, documentRect, undefined, fitsViewport, options);\n        }\n        const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : { x: 0, y: 0, ...viewportSize };\n        return await this._screenshot(progress, format, undefined, viewportRect, true, options);\n      } finally {\n        await this._restorePageAfterScreenshot();\n      }\n    });\n  }\n\n  async screenshotElement(progress: Progress, handle: dom.ElementHandle, options: ScreenshotOptions): Promise<Buffer> {\n    const format = validateScreenshotOptions(options);\n    return this._queue.postTask(async () => {\n      progress.log('taking element screenshot');\n      const viewportSize = await this._originalViewportSize(progress);\n\n      await this._preparePageForScreenshot(progress, handle._frame, options.style, options.caret !== 'initial', options.animations === 'disabled');\n      try {\n        await handle._waitAndScrollIntoViewIfNeeded(progress, true /* waitForVisible */);\n\n        const boundingBox = await progress.race(handle.boundingBox());\n        assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n        assert(boundingBox.width !== 0, 'Node has 0 width.');\n        assert(boundingBox.height !== 0, 'Node has 0 height.');\n\n        const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;\n        const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({ x: window.scrollX, y: window.scrollY }));\n        const documentRect = { ...boundingBox };\n        documentRect.x += scrollOffset.x;\n        documentRect.y += scrollOffset.y;\n        return await this._screenshot(progress, format, helper.enclosingIntRect(documentRect), undefined, fitsViewport, options);\n      } finally {\n        await this._restorePageAfterScreenshot();\n      }\n    });\n  }\n\n  async _preparePageForScreenshot(progress: Progress, frame: Frame, screenshotStyle: string | undefined, hideCaret: boolean, disableAnimations: boolean) {\n    if (disableAnimations)\n      progress.log('  disabled all CSS animations');\n    const syncAnimations = this._page.delegate.shouldToggleStyleSheetToSyncAnimations();\n    await progress.race(this._page.safeNonStallingEvaluateInAllFrames('(' + inPagePrepareForScreenshots.toString() + `)(${JSON.stringify(screenshotStyle)}, ${hideCaret}, ${disableAnimations}, ${syncAnimations})`, 'utility'));\n    try {\n      if (!process.env.PW_TEST_SCREENSHOT_NO_FONTS_READY) {\n        progress.log('waiting for fonts to load...');\n        await progress.race(frame.nonStallingEvaluateInExistingContext('document.fonts.ready', 'utility').catch(() => {}));\n        progress.log('fonts loaded');\n      }\n    } catch (error) {\n      await this._restorePageAfterScreenshot();\n      throw error;\n    }\n  }\n\n  async _restorePageAfterScreenshot() {\n    await this._page.safeNonStallingEvaluateInAllFrames('window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()', 'utility');\n  }\n\n  async _maskElements(progress: Progress, options: ScreenshotOptions): Promise<() => Promise<void>> {\n    if (!options.mask || !options.mask.length)\n      return () => Promise.resolve();\n\n    const framesToParsedSelectors: MultiMap<Frame, ParsedSelector> = new MultiMap();\n    await progress.race(Promise.all((options.mask || []).map(async ({ frame, selector }) => {\n      const pair = await frame.selectors.resolveFrameForSelector(selector);\n      if (pair)\n        framesToParsedSelectors.set(pair.frame, pair.info.parsed);\n    })));\n\n    const frames = [...framesToParsedSelectors.keys()];\n    const cleanup = async () => {\n      await Promise.all(frames.map(frame => frame.hideHighlight()));\n    };\n\n    try {\n      const promises = frames.map(frame => frame.maskSelectors(framesToParsedSelectors.get(frame), options.maskColor || '#F0F'));\n      await progress.race(Promise.all(promises));\n      return cleanup;\n    } catch (error) {\n      cleanup().catch(() => {});\n      throw error;\n    }\n  }\n\n  private async _screenshot(progress: Progress, format: 'png' | 'jpeg', documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, fitsViewport: boolean, options: ScreenshotOptions): Promise<Buffer> {\n    if ((options as any).__testHookBeforeScreenshot)\n      await progress.race((options as any).__testHookBeforeScreenshot());\n\n    const shouldSetDefaultBackground = options.omitBackground && format === 'png';\n    if (shouldSetDefaultBackground)\n      await progress.race(this._page.delegate.setBackgroundColor({ r: 0, g: 0, b: 0, a: 0 }));\n    const cleanupHighlight = await this._maskElements(progress, options);\n\n    try {\n      const quality = format === 'jpeg' ? options.quality ?? 80 : undefined;\n      const buffer = await this._page.delegate.takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, options.scale || 'device');\n      await cleanupHighlight();\n      if (shouldSetDefaultBackground)\n        await this._page.delegate.setBackgroundColor();\n      if ((options as any).__testHookAfterScreenshot)\n        await progress.race((options as any).__testHookAfterScreenshot());\n      return buffer;\n    } catch (error) {\n      // Cleanup without blocking, it will be done before the next playwright action.\n      cleanupHighlight().catch(() => {});\n      if (shouldSetDefaultBackground)\n        this._page.delegate.setBackgroundColor().catch(() => {});\n      throw error;\n    }\n  }\n}\n\nclass TaskQueue {\n  private _chain: Promise<any>;\n\n  constructor() {\n    this._chain = Promise.resolve();\n  }\n\n  postTask(task: () => any): Promise<any> {\n    const result = this._chain.then(task);\n    this._chain = result.catch(() => {});\n    return result;\n  }\n}\n\nfunction trimClipToSize(clip: types.Rect, size: types.Size): types.Rect {\n  const p1 = {\n    x: Math.max(0, Math.min(clip.x, size.width)),\n    y: Math.max(0, Math.min(clip.y, size.height))\n  };\n  const p2 = {\n    x: Math.max(0, Math.min(clip.x + clip.width, size.width)),\n    y: Math.max(0, Math.min(clip.y + clip.height, size.height))\n  };\n  const result = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };\n  assert(result.width && result.height, 'Clipped area is either empty or outside the resulting image');\n  return result;\n}\n\nexport function validateScreenshotOptions(options: ScreenshotOptions): 'png' | 'jpeg' {\n  let format: 'png' | 'jpeg' | null = null;\n  // options.type takes precedence over inferring the type from options.path\n  // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).\n  if (options.type) {\n    assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);\n    format = options.type;\n  }\n\n  if (!format)\n    format = 'png';\n\n  if (options.quality !== undefined) {\n    assert(format === 'jpeg', 'options.quality is unsupported for the ' + format + ' screenshots');\n    assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + (typeof options.quality));\n    assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');\n    assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);\n  }\n  if (options.clip) {\n    assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + (typeof options.clip.x));\n    assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + (typeof options.clip.y));\n    assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + (typeof options.clip.width));\n    assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + (typeof options.clip.height));\n    assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');\n    assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');\n  }\n  return format;\n}\n"],
  "mappings": "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",
  "names": ["roots"]
}

{
  "version": 3,
  "sources": ["../../src/server/browserType.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport { normalizeProxySettings, validateBrowserContextOptions } from './browserContext';\nimport { debugMode } from './utils/debug';\nimport { assert } from '../utils/isomorphic/assert';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\nimport { DEFAULT_PLAYWRIGHT_TIMEOUT } from '../utils/isomorphic/time';\nimport { existsAsync } from './utils/fileUtils';\nimport { helper } from './helper';\nimport { SdkObject } from './instrumentation';\nimport { PipeTransport } from './pipeTransport';\nimport { envArrayToObject, launchProcess } from './utils/processLauncher';\nimport {  isProtocolError } from './protocolError';\nimport { registry } from './registry';\nimport { ClientCertificatesProxy } from './socksClientCertificatesInterceptor';\nimport { WebSocketTransport } from './transport';\nimport { RecentLogsCollector } from './utils/debugLogger';\n\nimport type { Browser, BrowserOptions, BrowserProcess } from './browser';\nimport type { BrowserContext } from './browserContext';\nimport type { Env } from './utils/processLauncher';\nimport type { Progress } from './progress';\nimport type { ProtocolError } from './protocolError';\nimport type { BrowserName } from './registry';\nimport type { ConnectionTransport } from './transport';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\n\nexport const kNoXServerRunningError = 'Looks like you launched a headed browser without having a XServer running.\\n' +\n  'Set either \\'headless: true\\' or use \\'xvfb-run <your-playwright-app>\\' before running Playwright.\\n\\n<3 Playwright Team';\n\nexport abstract class BrowserType extends SdkObject {\n  private _name: BrowserName;\n\n  constructor(parent: SdkObject, browserName: BrowserName) {\n    super(parent, 'browser-type');\n    this.attribution.browserType = this;\n    this._name = browserName;\n    this.logName = 'browser';\n  }\n\n  executablePath(): string {\n    return registry.findExecutable(this._name).executablePath(this.attribution.playwright.options.sdkLanguage) || '';\n  }\n\n  name(): string {\n    return this._name;\n  }\n\n  async launch(progress: Progress, options: types.LaunchOptions, protocolLogger?: types.ProtocolLogger): Promise<Browser> {\n    options = this._validateLaunchOptions(options);\n    const seleniumHubUrl = (options as any).__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;\n    if (seleniumHubUrl)\n      return this._launchWithSeleniumHub(progress, seleniumHubUrl, options);\n    return this._innerLaunchWithRetries(progress, options, undefined, helper.debugProtocolLogger(protocolLogger)).catch(e => { throw this._rewriteStartupLog(e); });\n  }\n\n  async launchPersistentContext(progress: Progress, userDataDir: string, options: channels.BrowserTypeLaunchPersistentContextOptions & { cdpPort?: number, internalIgnoreHTTPSErrors?: boolean, socksProxyPort?: number }): Promise<BrowserContext> {\n    const launchOptions = this._validateLaunchOptions(options);\n    // Note: Any initial TLS requests will fail since we rely on the Page/Frames initialize which sets ignoreHTTPSErrors.\n    let clientCertificatesProxy: ClientCertificatesProxy | undefined;\n    if (options.clientCertificates?.length) {\n      clientCertificatesProxy = await ClientCertificatesProxy.create(progress, options);\n      launchOptions.proxyOverride = clientCertificatesProxy.proxySettings();\n      options = { ...options };\n      options.internalIgnoreHTTPSErrors = true;\n    }\n    try {\n      const browser = await this._innerLaunchWithRetries(progress, launchOptions, options, helper.debugProtocolLogger(), userDataDir).catch(e => { throw this._rewriteStartupLog(e); });\n      browser._defaultContext!._clientCertificatesProxy = clientCertificatesProxy;\n      return browser._defaultContext!;\n    } catch (error) {\n      await clientCertificatesProxy?.close().catch(() => {});\n      throw error;\n    }\n  }\n\n  async _innerLaunchWithRetries(progress: Progress, options: types.LaunchOptions, persistent: types.BrowserContextOptions | undefined, protocolLogger: types.ProtocolLogger, userDataDir?: string): Promise<Browser> {\n    try {\n      return await this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);\n    } catch (error) {\n      // @see https://github.com/microsoft/playwright/issues/5214\n      const errorMessage = typeof error === 'object' && typeof error.message === 'string' ? error.message : '';\n      if (errorMessage.includes('Inconsistency detected by ld.so')) {\n        progress.log(`<restarting browser due to hitting race condition in glibc>`);\n        return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);\n      }\n      throw error;\n    }\n  }\n\n  async _innerLaunch(progress: Progress, options: types.LaunchOptions, persistent: types.BrowserContextOptions | undefined, protocolLogger: types.ProtocolLogger, maybeUserDataDir?: string): Promise<Browser> {\n    options.proxy = options.proxy ? normalizeProxySettings(options.proxy) : undefined;\n    const browserLogsCollector = new RecentLogsCollector();\n    const { browserProcess, userDataDir, artifactsDir, transport } = await this._launchProcess(progress, options, !!persistent, browserLogsCollector, maybeUserDataDir);\n    try {\n      if ((options as any).__testHookBeforeCreateBrowser)\n        await progress.race((options as any).__testHookBeforeCreateBrowser());\n      const browserOptions: BrowserOptions = {\n        name: this._name,\n        isChromium: this._name === 'chromium',\n        channel: options.channel,\n        slowMo: options.slowMo,\n        persistent,\n        headful: !options.headless,\n        artifactsDir,\n        downloadsPath: (options.downloadsPath || artifactsDir)!,\n        tracesDir: (options.tracesDir || artifactsDir)!,\n        browserProcess,\n        customExecutablePath: options.executablePath,\n        proxy: options.proxy,\n        protocolLogger,\n        browserLogsCollector,\n        wsEndpoint: transport instanceof WebSocketTransport ? transport.wsEndpoint : undefined,\n        originalLaunchOptions: options,\n      };\n      if (persistent)\n        validateBrowserContextOptions(persistent, browserOptions);\n      copyTestHooks(options, browserOptions);\n      const browser = await progress.race(this.connectToTransport(transport, browserOptions, browserLogsCollector));\n      (browser as any)._userDataDirForTest = userDataDir;\n      // We assume no control when using custom arguments, and do not prepare the default context in that case.\n      if (persistent && !options.ignoreAllDefaultArgs)\n        await browser._defaultContext!._loadDefaultContext(progress);\n      return browser;\n    } catch (error) {\n      await browserProcess.close().catch(() => {});\n      throw error;\n    }\n  }\n\n  private async _prepareToLaunch(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string | undefined) {\n    const {\n      ignoreDefaultArgs,\n      ignoreAllDefaultArgs,\n      args = [],\n      executablePath = null,\n    } = options;\n    await this._createArtifactDirs(options);\n\n    const tempDirectories: string[] = [];\n    const artifactsDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'playwright-artifacts-'));\n    tempDirectories.push(artifactsDir);\n\n    if (userDataDir) {\n      assert(path.isAbsolute(userDataDir), 'userDataDir must be an absolute path');\n      // Firefox bails if the profile directory does not exist, Chrome creates it. We ensure consistent behavior here.\n      if (!await existsAsync(userDataDir))\n        await fs.promises.mkdir(userDataDir, { recursive: true, mode: 0o700 });\n    } else {\n      userDataDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));\n      tempDirectories.push(userDataDir);\n    }\n    await this.prepareUserDataDir(options, userDataDir);\n\n    const browserArguments: string[] = [];\n    if (ignoreAllDefaultArgs)\n      browserArguments.push(...args);\n    else if (ignoreDefaultArgs)\n      browserArguments.push(...this.defaultArgs(options, isPersistent, userDataDir).filter(arg => ignoreDefaultArgs.indexOf(arg) === -1));\n    else\n      browserArguments.push(...this.defaultArgs(options, isPersistent, userDataDir));\n\n    let executable: string;\n    if (executablePath) {\n      if (!(await existsAsync(executablePath)))\n        throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);\n      executable = executablePath;\n    } else {\n      const registryExecutable = registry.findExecutable(this.getExecutableName(options));\n      if (!registryExecutable || registryExecutable.browserName !== this._name)\n        throw new Error(`Unsupported ${this._name} channel \"${options.channel}\"`);\n      executable = registryExecutable.executablePathOrDie(this.attribution.playwright.options.sdkLanguage);\n      await registry.validateHostRequirementsForExecutablesIfNeeded([registryExecutable], this.attribution.playwright.options.sdkLanguage);\n    }\n\n    return { executable, browserArguments, userDataDir, artifactsDir, tempDirectories };\n  }\n\n  private async _launchProcess(progress: Progress, options: types.LaunchOptions, isPersistent: boolean, browserLogsCollector: RecentLogsCollector, userDataDir?: string): Promise<{ browserProcess: BrowserProcess, artifactsDir: string, userDataDir: string, transport: ConnectionTransport }> {\n    const {\n      handleSIGINT = true,\n      handleSIGTERM = true,\n      handleSIGHUP = true,\n    } = options;\n\n    const env = options.env ? envArrayToObject(options.env) : process.env;\n    const prepared = await progress.race(this._prepareToLaunch(options, isPersistent, userDataDir));\n\n    // Note: it is important to define these variables before launchProcess, so that we don't get\n    // \"Cannot access 'browserServer' before initialization\" if something went wrong.\n    let transport: ConnectionTransport | undefined = undefined;\n    let browserProcess: BrowserProcess | undefined = undefined;\n    const exitPromise = new ManualPromise();\n    const { launchedProcess, gracefullyClose, kill } = await launchProcess({\n      command: prepared.executable,\n      args: prepared.browserArguments,\n      env: this.amendEnvironment(env, prepared.userDataDir, isPersistent),\n      handleSIGINT,\n      handleSIGTERM,\n      handleSIGHUP,\n      log: (message: string) => {\n        progress.log(message);\n        browserLogsCollector.log(message);\n      },\n      stdio: 'pipe',\n      tempDirectories: prepared.tempDirectories,\n      attemptToGracefullyClose: async () => {\n        if ((options as any).__testHookGracefullyClose)\n          await (options as any).__testHookGracefullyClose();\n        if (transport) {\n          // We try to gracefully close to prevent crash reporting and core dumps.\n          this.attemptToGracefullyCloseBrowser(transport);\n        } else {\n          throw new Error('Force-killing the browser because no transport is available to gracefully close it.');\n        }\n      },\n      onExit: (exitCode, signal) => {\n        // Unblock launch when browser prematurely exits.\n        exitPromise.resolve();\n        if (browserProcess && browserProcess.onclose)\n          browserProcess.onclose(exitCode, signal);\n      },\n    });\n\n    async function closeOrKill(timeout: number): Promise<void> {\n      let timer: NodeJS.Timeout;\n      try {\n        await Promise.race([\n          gracefullyClose(),\n          new Promise((resolve, reject) => timer = setTimeout(reject, timeout)),\n        ]);\n      } catch (ignored) {\n        await kill().catch(ignored => {}); // Make sure to await actual process exit.\n      } finally {\n        clearTimeout(timer!);\n      }\n    }\n    browserProcess = {\n      onclose: undefined,\n      process: launchedProcess,\n      close: () => closeOrKill((options as any).__testHookBrowserCloseTimeout || DEFAULT_PLAYWRIGHT_TIMEOUT),\n      kill\n    };\n    try {\n      const { wsEndpoint } = await progress.race([\n        this.waitForReadyState(options, browserLogsCollector),\n        exitPromise.then(() => ({ wsEndpoint: undefined })),\n      ]);\n      if (options.cdpPort !== undefined || !this.supportsPipeTransport()) {\n        transport = await WebSocketTransport.connect(progress, wsEndpoint!);\n      } else {\n        const stdio = launchedProcess.stdio as unknown as [NodeJS.ReadableStream, NodeJS.WritableStream, NodeJS.WritableStream, NodeJS.WritableStream, NodeJS.ReadableStream];\n        transport = new PipeTransport(stdio[3], stdio[4]);\n      }\n      return { browserProcess, artifactsDir: prepared.artifactsDir, userDataDir: prepared.userDataDir, transport };\n    } catch (error) {\n      await closeOrKill(DEFAULT_PLAYWRIGHT_TIMEOUT).catch(() => {});\n      throw error;\n    }\n  }\n\n  async _createArtifactDirs(options: types.LaunchOptions): Promise<void> {\n    if (options.downloadsPath)\n      await fs.promises.mkdir(options.downloadsPath, { recursive: true });\n    if (options.tracesDir)\n      await fs.promises.mkdir(options.tracesDir, { recursive: true });\n  }\n\n  async connectOverCDP(progress: Progress, endpointURL: string, options: { slowMo?: number, timeout?: number, headers?: types.HeadersArray }): Promise<Browser> {\n    throw new Error('CDP connections are only supported by Chromium');\n  }\n\n  async _launchWithSeleniumHub(progress: Progress, hubUrl: string, options: types.LaunchOptions): Promise<Browser> {\n    throw new Error('Connecting to SELENIUM_REMOTE_URL is only supported by Chromium');\n  }\n\n  private _validateLaunchOptions(options: types.LaunchOptions): types.LaunchOptions {\n    const { devtools = false } = options;\n    let { headless = !devtools, downloadsPath, proxy } = options;\n    if (debugMode() === 'inspector')\n      headless = false;\n    if (downloadsPath && !path.isAbsolute(downloadsPath))\n      downloadsPath = path.join(process.cwd(), downloadsPath);\n    if (options.socksProxyPort)\n      proxy = { server: `socks5://127.0.0.1:${options.socksProxyPort}` };\n    return { ...options, devtools, headless, downloadsPath, proxy };\n  }\n\n  protected _createUserDataDirArgMisuseError(userDataDirArg: string): Error {\n    switch (this.attribution.playwright.options.sdkLanguage) {\n      case 'java':\n        return new Error(`Pass userDataDir parameter to 'BrowserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);\n      case 'python':\n        return new Error(`Pass user_data_dir parameter to 'browser_type.launch_persistent_context(user_data_dir, **kwargs)' instead of specifying '${userDataDirArg}' argument`);\n      case 'csharp':\n        return new Error(`Pass userDataDir parameter to 'BrowserType.LaunchPersistentContextAsync(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);\n      default:\n        return new Error(`Pass userDataDir parameter to 'browserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);\n    }\n  }\n\n  _rewriteStartupLog(error: Error): Error {\n    if (!isProtocolError(error))\n      return error;\n    return this.doRewriteStartupLog(error);\n  }\n\n  async waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{ wsEndpoint?: string }> {\n    return {};\n  }\n\n  async prepareUserDataDir(options: types.LaunchOptions, userDataDir: string): Promise<void> {\n  }\n\n  supportsPipeTransport(): boolean {\n    return true;\n  }\n\n  getExecutableName(options: types.LaunchOptions): string {\n    return options.channel || this._name;\n  }\n\n  abstract defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): string[];\n  abstract connectToTransport(transport: ConnectionTransport, options: BrowserOptions, browserLogsCollector: RecentLogsCollector): Promise<Browser>;\n  abstract amendEnvironment(env: Env, userDataDir: string, isPersistent: boolean): Env;\n  abstract doRewriteStartupLog(error: ProtocolError): ProtocolError;\n  abstract attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n}\n\nfunction copyTestHooks(from: object, to: object) {\n  for (const [key, value] of Object.entries(from)) {\n    if (key.startsWith('__testHook'))\n      (to as any)[key] = value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["fs", "path", "os", "ignored"]
}

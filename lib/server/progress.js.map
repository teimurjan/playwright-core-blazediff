{
  "version": 3,
  "sources": ["../../src/server/progress.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TimeoutError } from './errors';\nimport { assert } from '../utils';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\n\nimport type { Progress } from '@protocol/progress';\nimport type { CallMetadata } from './instrumentation';\n\nexport type { Progress } from '@protocol/progress';\n\nexport class ProgressController {\n  private _forceAbortPromise = new ManualPromise<any>();\n  private _donePromise = new ManualPromise<void>();\n  private _state: 'before' | 'running' | { error: Error } | 'finished' = 'before';\n  private _onCallLog?: (message: string) => void;\n\n  readonly metadata: CallMetadata;\n\n  constructor(metadata?: CallMetadata, onCallLog?: (message: string) => void) {\n    this.metadata = metadata || { id: '', startTime: 0, endTime: 0, type: 'Internal', method: '', params: {}, log: [], internal: true };\n    this._onCallLog = onCallLog;\n    this._forceAbortPromise.catch(e => null);  // Prevent unhandled promise rejection.\n  }\n\n  async abort(error: Error) {\n    if (this._state === 'running') {\n      (error as any)[kAbortErrorSymbol] = true;\n      this._state = { error };\n      this._forceAbortPromise.reject(error);\n    }\n    await this._donePromise;\n  }\n\n  async run<T>(task: (progress: Progress) => Promise<T>, timeout?: number): Promise<T> {\n    assert(this._state === 'before');\n    this._state = 'running';\n\n    const progress: Progress = {\n      log: message => {\n        if (this._state === 'running')\n          this.metadata.log.push(message);\n        // Note: we might be sending logs after progress has finished, for example browser logs.\n        this._onCallLog?.(message);\n      },\n      metadata: this.metadata,\n      race: <T>(promise: Promise<T> | Promise<T>[]) => {\n        const promises = Array.isArray(promise) ? promise : [promise];\n        return Promise.race([...promises, this._forceAbortPromise]);\n      },\n      wait: async (timeout: number) => {\n        let timer: NodeJS.Timeout;\n        const promise = new Promise<void>(f => timer = setTimeout(f, timeout));\n        return progress.race(promise).finally(() => clearTimeout(timer));\n      },\n    };\n\n    let timer: NodeJS.Timeout | undefined;\n    if (timeout) {\n      const timeoutError = new TimeoutError(`Timeout ${timeout}ms exceeded.`);\n      timer = setTimeout(() => {\n        if (this._state === 'running') {\n          (timeoutError as any)[kAbortErrorSymbol] = true;\n          this._state = { error: timeoutError };\n          this._forceAbortPromise.reject(timeoutError);\n        }\n      }, timeout);\n    }\n\n    try {\n      const result = await task(progress);\n      this._state = 'finished';\n      return result;\n    } catch (error) {\n      this._state = { error };\n      throw error;\n    } finally {\n      clearTimeout(timer);\n      this._donePromise.resolve();\n    }\n  }\n}\n\nconst kAbortErrorSymbol = Symbol('kAbortError');\n\nexport function isAbortError(error: Error): boolean {\n  return !!(error as any)[kAbortErrorSymbol];\n}\n\n// Use this method to race some external operation that you really want to undo\n// when it goes beyond the progress abort.\nexport async function raceUncancellableOperationWithCleanup<T>(progress: Progress, run: () => Promise<T>, cleanup: (t: T) => void | Promise<unknown>): Promise<T> {\n  let aborted = false;\n  try {\n    return await progress.race(run().then(async t => {\n      if (aborted)\n        await cleanup(t);\n      return t;\n    }));\n  } catch (error) {\n    aborted = true;\n    throw error;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,oBAA6B;AAC7B,mBAAuB;AACvB,2BAA8B;AAOvB,MAAM,mBAAmB;AAAA,EAQ9B,YAAY,UAAyB,WAAuC;AAP5E,SAAQ,qBAAqB,IAAI,mCAAmB;AACpD,SAAQ,eAAe,IAAI,mCAAoB;AAC/C,SAAQ,SAA+D;AAMrE,SAAK,WAAW,YAAY,EAAE,IAAI,IAAI,WAAW,GAAG,SAAS,GAAG,MAAM,YAAY,QAAQ,IAAI,QAAQ,CAAC,GAAG,KAAK,CAAC,GAAG,UAAU,KAAK;AAClI,SAAK,aAAa;AAClB,SAAK,mBAAmB,MAAM,OAAK,IAAI;AAAA,EACzC;AAAA,EAEA,MAAM,MAAM,OAAc;AACxB,QAAI,KAAK,WAAW,WAAW;AAC7B,MAAC,MAAc,iBAAiB,IAAI;AACpC,WAAK,SAAS,EAAE,MAAM;AACtB,WAAK,mBAAmB,OAAO,KAAK;AAAA,IACtC;AACA,UAAM,KAAK;AAAA,EACb;AAAA,EAEA,MAAM,IAAO,MAA0C,SAA8B;AACnF,6BAAO,KAAK,WAAW,QAAQ;AAC/B,SAAK,SAAS;AAEd,UAAM,WAAqB;AAAA,MACzB,KAAK,aAAW;AACd,YAAI,KAAK,WAAW;AAClB,eAAK,SAAS,IAAI,KAAK,OAAO;AAEhC,aAAK,aAAa,OAAO;AAAA,MAC3B;AAAA,MACA,UAAU,KAAK;AAAA,MACf,MAAM,CAAI,YAAuC;AAC/C,cAAM,WAAW,MAAM,QAAQ,OAAO,IAAI,UAAU,CAAC,OAAO;AAC5D,eAAO,QAAQ,KAAK,CAAC,GAAG,UAAU,KAAK,kBAAkB,CAAC;AAAA,MAC5D;AAAA,MACA,MAAM,OAAOA,aAAoB;AAC/B,YAAIC;AACJ,cAAM,UAAU,IAAI,QAAc,OAAKA,SAAQ,WAAW,GAAGD,QAAO,CAAC;AACrE,eAAO,SAAS,KAAK,OAAO,EAAE,QAAQ,MAAM,aAAaC,MAAK,CAAC;AAAA,MACjE;AAAA,IACF;AAEA,QAAI;AACJ,QAAI,SAAS;AACX,YAAM,eAAe,IAAI,2BAAa,WAAW,OAAO,cAAc;AACtE,cAAQ,WAAW,MAAM;AACvB,YAAI,KAAK,WAAW,WAAW;AAC7B,UAAC,aAAqB,iBAAiB,IAAI;AAC3C,eAAK,SAAS,EAAE,OAAO,aAAa;AACpC,eAAK,mBAAmB,OAAO,YAAY;AAAA,QAC7C;AAAA,MACF,GAAG,OAAO;AAAA,IACZ;AAEA,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,QAAQ;AAClC,WAAK,SAAS;AACd,aAAO;AAAA,IACT,SAAS,OAAO;AACd,WAAK,SAAS,EAAE,MAAM;AACtB,YAAM;AAAA,IACR,UAAE;AACA,mBAAa,KAAK;AAClB,WAAK,aAAa,QAAQ;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,MAAM,oBAAoB,OAAO,aAAa;AAEvC,SAAS,aAAa,OAAuB;AAClD,SAAO,CAAC,CAAE,MAAc,iBAAiB;AAC3C;AAIA,eAAsB,sCAAyC,UAAoB,KAAuB,SAAwD;AAChK,MAAI,UAAU;AACd,MAAI;AACF,WAAO,MAAM,SAAS,KAAK,IAAI,EAAE,KAAK,OAAM,MAAK;AAC/C,UAAI;AACF,cAAM,QAAQ,CAAC;AACjB,aAAO;AAAA,IACT,CAAC,CAAC;AAAA,EACJ,SAAS,OAAO;AACd,cAAU;AACV,UAAM;AAAA,EACR;AACF;",
  "names": ["timeout", "timer"]
}

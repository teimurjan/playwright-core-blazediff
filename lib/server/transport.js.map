{
  "version": 3,
  "sources": ["../../src/server/transport.ts"],
  "sourcesContent": ["/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { makeWaitForNextTask } from '../utils';\nimport { httpHappyEyeballsAgent, httpsHappyEyeballsAgent } from './utils/happyEyeballs';\nimport { ws } from '../utilsBundle';\n\nimport type { WebSocket } from '../utilsBundle';\nimport type { Progress } from './progress';\nimport type { HeadersArray } from './types';\nimport type { ClientRequest, IncomingMessage } from 'http';\n\nexport const perMessageDeflate = {\n  clientNoContextTakeover: true,\n  zlibDeflateOptions: {\n    level: 3,\n  },\n  zlibInflateOptions: {\n    chunkSize: 10 * 1024\n  },\n  threshold: 10 * 1024,\n};\n\nexport type ProtocolRequest = {\n  id: number;\n  method: string;\n  params: any;\n  sessionId?: string;\n};\n\nexport type ProtocolResponse = {\n  id?: number;\n  method?: string;\n  sessionId?: string;\n  error?: { message: string; data: any; code?: number };\n  params?: any;\n  result?: any;\n  pageProxyId?: string;\n  browserContextId?: string;\n};\n\nexport interface ConnectionTransport {\n  send(s: ProtocolRequest): void;\n  close(): void;  // Note: calling close is expected to issue onclose at some point.\n  onmessage?: (message: ProtocolResponse) => void,\n  onclose?: (reason?: string) => void,\n}\n\ntype WebSocketTransportOptions = {\n  headers?: { [key: string]: string; };\n  followRedirects?: boolean;\n  debugLogHeader?: string;\n};\n\nexport class WebSocketTransport implements ConnectionTransport {\n  private _ws: WebSocket;\n  private _progress?: Progress;\n  private _logUrl: string;\n\n  onmessage?: (message: ProtocolResponse) => void;\n  onclose?: (reason?: string) => void;\n  readonly wsEndpoint: string;\n  readonly headers: HeadersArray = [];\n\n  static async connect(progress: (Progress|undefined), url: string, options: WebSocketTransportOptions = {}): Promise<WebSocketTransport> {\n    return await WebSocketTransport._connect(progress, url, options, false /* hadRedirects */);\n  }\n\n  static async _connect(progress: (Progress|undefined), url: string, options: WebSocketTransportOptions, hadRedirects: boolean): Promise<WebSocketTransport> {\n    const logUrl = stripQueryParams(url);\n    progress?.log(`<ws connecting> ${logUrl}`);\n    const transport = new WebSocketTransport(progress, url, logUrl, { ...options, followRedirects: !!options.followRedirects && hadRedirects });\n    const resultPromise = new Promise<{ redirect?: IncomingMessage }>((fulfill, reject) => {\n      transport._ws.on('open', async () => {\n        progress?.log(`<ws connected> ${logUrl}`);\n        fulfill({});\n      });\n      transport._ws.on('error', event => {\n        progress?.log(`<ws connect error> ${logUrl} ${event.message}`);\n        reject(new Error('WebSocket error: ' + event.message));\n        transport._ws.close();\n      });\n      transport._ws.on('unexpected-response', (request: ClientRequest, response: IncomingMessage) => {\n        if (options.followRedirects && !hadRedirects && (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 307 || response.statusCode === 308)) {\n          fulfill({ redirect: response });\n          transport._ws.close();\n          return;\n        }\n        for (let i = 0; i < response.rawHeaders.length; i += 2) {\n          if (options.debugLogHeader && response.rawHeaders[i] === options.debugLogHeader)\n            progress?.log(response.rawHeaders[i + 1]);\n        }\n        const chunks: Buffer[] = [];\n        const errorPrefix = `${logUrl} ${response.statusCode} ${response.statusMessage}`;\n        response.on('data', chunk => chunks.push(chunk));\n        response.on('close', () => {\n          const error = chunks.length ? `${errorPrefix}\\n${Buffer.concat(chunks)}` : errorPrefix;\n          progress?.log(`<ws unexpected response> ${error}`);\n          reject(new Error('WebSocket error: ' + error));\n          transport._ws.close();\n        });\n      });\n    });\n    try {\n      const result = progress ? await progress.race(resultPromise) : await resultPromise;\n      if (result.redirect) {\n        // Strip authorization headers from the redirected request.\n        const newHeaders = Object.fromEntries(Object.entries(options.headers || {}).filter(([name]) => {\n          return !name.includes('access-key') && name.toLowerCase() !== 'authorization';\n        }));\n        return WebSocketTransport._connect(progress, result.redirect.headers.location!, { ...options, headers: newHeaders }, true /* hadRedirects */);\n      }\n      return transport;\n    } catch (error) {\n      await transport.closeAndWait();\n      throw error;\n    }\n  }\n\n  constructor(progress: Progress|undefined, url: string, logUrl: string, options: WebSocketTransportOptions) {\n    this.wsEndpoint = url;\n    this._logUrl = logUrl;\n    this._ws = new ws(url, [], {\n      maxPayload: 256 * 1024 * 1024, // 256Mb,\n      headers: options.headers,\n      followRedirects: options.followRedirects,\n      agent: (/^(https|wss):\\/\\//.test(url)) ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent,\n      perMessageDeflate,\n    });\n    this._ws.on('upgrade', response => {\n      for (let i = 0; i < response.rawHeaders.length; i += 2) {\n        this.headers.push({ name: response.rawHeaders[i], value: response.rawHeaders[i + 1] });\n        if (options.debugLogHeader && response.rawHeaders[i] === options.debugLogHeader)\n          progress?.log(response.rawHeaders[i + 1]);\n      }\n    });\n    this._progress = progress;\n    // The 'ws' module in node sometimes sends us multiple messages in a single task.\n    // In Web, all IO callbacks (e.g. WebSocket callbacks)\n    // are dispatched into separate tasks, so there's no need\n    // to do anything extra.\n    const messageWrap: (cb: () => void) => void = makeWaitForNextTask();\n\n    this._ws.addEventListener('message', event => {\n      messageWrap(() => {\n        const eventData = event.data as string;\n        let parsedJson;\n        try {\n          parsedJson = JSON.parse(eventData);\n        } catch (e) {\n          this._progress?.log(`<closing ws> Closing websocket due to malformed JSON. eventData=${eventData} e=${e?.message}`);\n          this._ws.close();\n          return;\n        }\n        try {\n          if (this.onmessage)\n            this.onmessage.call(null, parsedJson);\n        } catch (e) {\n          this._progress?.log(`<closing ws> Closing websocket due to failed onmessage callback. eventData=${eventData} e=${e?.message}`);\n          this._ws.close();\n        }\n      });\n    });\n\n    this._ws.addEventListener('close', event => {\n      this._progress?.log(`<ws disconnected> ${logUrl} code=${event.code} reason=${event.reason}`);\n      if (this.onclose)\n        this.onclose.call(null, event.reason);\n    });\n    // Prevent Error: read ECONNRESET.\n    this._ws.addEventListener('error', error => this._progress?.log(`<ws error> ${logUrl} ${error.type} ${error.message}`));\n  }\n\n  send(message: ProtocolRequest) {\n    this._ws.send(JSON.stringify(message));\n  }\n\n  close() {\n    this._progress?.log(`<ws disconnecting> ${this._logUrl}`);\n    this._ws.close();\n  }\n\n  async closeAndWait() {\n    if (this._ws.readyState === ws.CLOSED)\n      return;\n    const promise = new Promise(f => this._ws.once('close', f));\n    this.close();\n    await promise; // Make sure to await the actual disconnect.\n  }\n}\n\nfunction stripQueryParams(url: string): string {\n  try {\n    const u = new URL(url);\n    u.search = '';\n    u.hash = '';\n    return u.toString();\n  } catch {\n    return url;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../src/server/chromium/crBrowser.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport path from 'path';\n\nimport { assert } from '../../utils/isomorphic/assert';\nimport { createGuid } from '../utils/crypto';\nimport { Artifact } from '../artifact';\nimport { Browser } from '../browser';\nimport { BrowserContext, verifyGeolocation } from '../browserContext';\nimport { Frame } from '../frames';\nimport * as network from '../network';\nimport { Page } from '../page';\nimport { CRConnection, ConnectionEvents } from './crConnection';\nimport { CRPage } from './crPage';\nimport { saveProtocolStream } from './crProtocolHelper';\nimport { CRServiceWorker } from './crServiceWorker';\n\nimport type { InitScript, Worker } from '../page';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { CDPSession, CRSession } from './crConnection';\nimport type { CRDevTools } from './crDevTools';\nimport type { Protocol } from './protocol';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type * as channels from '@protocol/channels';\n\nexport class CRBrowser extends Browser {\n  readonly _connection: CRConnection;\n  _session: CRSession;\n  private _clientRootSessionPromise: Promise<CDPSession> | null = null;\n  readonly _contexts = new Map<string, CRBrowserContext>();\n  _crPages = new Map<string, CRPage>();\n  _backgroundPages = new Map<string, CRPage>();\n  _serviceWorkers = new Map<string, CRServiceWorker>();\n  _devtools?: CRDevTools;\n  private _version = '';\n\n  private _tracingRecording = false;\n  private _tracingClient: CRSession | undefined;\n  private _userAgent: string = '';\n\n  static async connect(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions, devtools?: CRDevTools): Promise<CRBrowser> {\n    // Make a copy in case we need to update `headful` property below.\n    options = { ...options };\n    const connection = new CRConnection(parent, transport, options.protocolLogger, options.browserLogsCollector);\n    const browser = new CRBrowser(parent, connection, options);\n    browser._devtools = devtools;\n    if (browser.isClank())\n      browser._isCollocatedWithServer = false;\n    const session = connection.rootSession;\n    if ((options as any).__testHookOnConnectToBrowser)\n      await (options as any).__testHookOnConnectToBrowser();\n\n    const version = await session.send('Browser.getVersion');\n    browser._version = version.product.substring(version.product.indexOf('/') + 1);\n    browser._userAgent = version.userAgent;\n    // We don't trust the option as it may lie in case of connectOverCDP where remote browser\n    // may have been launched with different options.\n    browser.options.headful = !version.userAgent.includes('Headless');\n    if (!options.persistent) {\n      await session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });\n      return browser;\n    }\n    browser._defaultContext = new CRBrowserContext(browser, undefined, options.persistent);\n    await Promise.all([\n      session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }).then(async () => {\n        // Target.setAutoAttach has a bug where it does not wait for new Targets being attached.\n        // However making a dummy call afterwards fixes this.\n        // This can be removed after https://chromium-review.googlesource.com/c/chromium/src/+/2885888 lands in stable.\n        await session.send('Target.getTargetInfo');\n      }),\n      (browser._defaultContext as CRBrowserContext)._initialize(),\n    ]);\n    await browser._waitForAllPagesToBeInitialized();\n    return browser;\n  }\n\n  constructor(parent: SdkObject, connection: CRConnection, options: BrowserOptions) {\n    super(parent, options);\n    this._connection = connection;\n    this._session = this._connection.rootSession;\n    this._connection.on(ConnectionEvents.Disconnected, () => this._didDisconnect());\n    this._session.on('Target.attachedToTarget', this._onAttachedToTarget.bind(this));\n    this._session.on('Target.detachedFromTarget', this._onDetachedFromTarget.bind(this));\n    this._session.on('Browser.downloadWillBegin', this._onDownloadWillBegin.bind(this));\n    this._session.on('Browser.downloadProgress', this._onDownloadProgress.bind(this));\n  }\n\n  async doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext> {\n    const proxy = options.proxyOverride || options.proxy;\n    let proxyBypassList = undefined;\n    if (proxy) {\n      if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)\n        proxyBypassList = proxy.bypass;\n      else\n        proxyBypassList = '<-loopback>' + (proxy.bypass ? `,${proxy.bypass}` : '');\n    }\n\n    const { browserContextId } = await this._session.send('Target.createBrowserContext', {\n      disposeOnDetach: true,\n      proxyServer: proxy ? proxy.server : undefined,\n      proxyBypassList,\n    });\n    const context = new CRBrowserContext(this, browserContextId, options);\n    await context._initialize();\n    this._contexts.set(browserContextId, context);\n    return context;\n  }\n\n  contexts(): BrowserContext[] {\n    return Array.from(this._contexts.values());\n  }\n\n  version(): string {\n    return this._version;\n  }\n\n  userAgent(): string {\n    return this._userAgent;\n  }\n\n  _platform(): 'mac' | 'linux' | 'win' {\n    if (this._userAgent.includes('Windows'))\n      return 'win';\n    if (this._userAgent.includes('Macintosh'))\n      return 'mac';\n    return 'linux';\n  }\n\n  isClank(): boolean {\n    return this.options.name === 'clank';\n  }\n\n  async _waitForAllPagesToBeInitialized() {\n    await Promise.all([...this._crPages.values()].map(crPage => crPage._page.waitForInitializedOrError()));\n  }\n\n  _onAttachedToTarget({ targetInfo, sessionId }: Protocol.Target.attachedToTargetPayload) {\n    if (targetInfo.type === 'browser')\n      return;\n    const session = this._session.createChildSession(sessionId);\n    assert(targetInfo.browserContextId, 'targetInfo: ' + JSON.stringify(targetInfo, null, 2));\n    let context = this._contexts.get(targetInfo.browserContextId) || null;\n    if (!context) {\n      // TODO: auto attach only to pages from our contexts.\n      // assert(this._defaultContext);\n      context = this._defaultContext as CRBrowserContext;\n    }\n\n    if (targetInfo.type === 'other' && targetInfo.url.startsWith('devtools://devtools') && this._devtools) {\n      this._devtools.install(session);\n      return;\n    }\n\n    const treatOtherAsPage = targetInfo.type === 'other' && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;\n\n    if (!context || (targetInfo.type === 'other' && !treatOtherAsPage)) {\n      session.detach().catch(() => {});\n      return;\n    }\n\n    assert(!this._crPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n    assert(!this._backgroundPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n    assert(!this._serviceWorkers.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);\n\n    if (targetInfo.type === 'background_page') {\n      const backgroundPage = new CRPage(session, targetInfo.targetId, context, null, { hasUIWindow: false, isBackgroundPage: true });\n      this._backgroundPages.set(targetInfo.targetId, backgroundPage);\n      return;\n    }\n\n    if (targetInfo.type === 'page' || treatOtherAsPage) {\n      const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;\n      const crPage = new CRPage(session, targetInfo.targetId, context, opener, { hasUIWindow: targetInfo.type === 'page', isBackgroundPage: false });\n      this._crPages.set(targetInfo.targetId, crPage);\n      return;\n    }\n\n    if (targetInfo.type === 'service_worker') {\n      const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);\n      this._serviceWorkers.set(targetInfo.targetId, serviceWorker);\n      context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);\n      return;\n    }\n\n    // Detach from any targets we are not interested in, to avoid side-effects.\n    //\n    // One example of a side effect: upon shared worker restart, we receive\n    // Inspector.targetReloadedAfterCrash and backend waits for Runtime.runIfWaitingForDebugger\n    // from any attached client. If we do not resume, shared worker will stall.\n    session.detach().catch(() => {});\n  }\n\n  _onDetachedFromTarget(payload: Protocol.Target.detachedFromTargetPayload) {\n    const targetId = payload.targetId!;\n    const crPage = this._crPages.get(targetId);\n    if (crPage) {\n      this._crPages.delete(targetId);\n      crPage.didClose();\n      return;\n    }\n    const backgroundPage = this._backgroundPages.get(targetId);\n    if (backgroundPage) {\n      this._backgroundPages.delete(targetId);\n      backgroundPage.didClose();\n      return;\n    }\n    const serviceWorker = this._serviceWorkers.get(targetId);\n    if (serviceWorker) {\n      this._serviceWorkers.delete(targetId);\n      serviceWorker.didClose();\n      return;\n    }\n  }\n\n  private _didDisconnect() {\n    for (const crPage of this._crPages.values())\n      crPage.didClose();\n    this._crPages.clear();\n    for (const backgroundPage of this._backgroundPages.values())\n      backgroundPage.didClose();\n    this._backgroundPages.clear();\n    for (const serviceWorker of this._serviceWorkers.values())\n      serviceWorker.didClose();\n    this._serviceWorkers.clear();\n    this._didClose();\n  }\n\n  private _findOwningPage(frameId: string) {\n    for (const crPage of this._crPages.values()) {\n      const frame = crPage._page.frameManager.frame(frameId);\n      if (frame)\n        return crPage;\n    }\n    return null;\n  }\n\n  _onDownloadWillBegin(payload: Protocol.Browser.downloadWillBeginPayload) {\n    const page = this._findOwningPage(payload.frameId);\n    if (!page) {\n      // There might be no page when download originates from something unusual, like\n      // a DevTools window or maybe an extension page.\n      // See https://github.com/microsoft/playwright/issues/22551.\n      return;\n    }\n    page.willBeginDownload();\n\n    let originPage = page._page.initializedOrUndefined();\n    // If it's a new window download, report it on the opener page.\n    if (!originPage && page._opener)\n      originPage = page._opener._page.initializedOrUndefined();\n    if (!originPage)\n      return;\n    this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);\n  }\n\n  _onDownloadProgress(payload: any) {\n    if (payload.state === 'completed')\n      this._downloadFinished(payload.guid, '');\n    if (payload.state === 'canceled')\n      this._downloadFinished(payload.guid, this._closeReason || 'canceled');\n  }\n\n  async _closePage(crPage: CRPage) {\n    await this._session.send('Target.closeTarget', { targetId: crPage._targetId });\n  }\n\n  async newBrowserCDPSession(): Promise<CDPSession> {\n    return await this._connection.createBrowserSession();\n  }\n\n  async startTracing(page?: Page, options: { screenshots?: boolean; categories?: string[]; } = {}) {\n    assert(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');\n    this._tracingClient = page ? (page.delegate as CRPage)._mainFrameSession._client : this._session;\n\n    const defaultCategories = [\n      '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',\n      'disabled-by-default-devtools.timeline.frame', 'toplevel',\n      'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',\n      'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'\n    ];\n    const {\n      screenshots = false,\n      categories = defaultCategories,\n    } = options;\n\n    if (screenshots)\n      categories.push('disabled-by-default-devtools.screenshot');\n\n    this._tracingRecording = true;\n    await this._tracingClient.send('Tracing.start', {\n      transferMode: 'ReturnAsStream',\n      categories: categories.join(',')\n    });\n  }\n\n  async stopTracing(): Promise<Artifact> {\n    assert(this._tracingClient, 'Tracing was not started.');\n    const [event] = await Promise.all([\n      new Promise(f => this._tracingClient!.once('Tracing.tracingComplete', f)),\n      this._tracingClient.send('Tracing.end')\n    ]);\n    const tracingPath = path.join(this.options.artifactsDir, createGuid() + '.crtrace');\n    await saveProtocolStream(this._tracingClient, (event as any).stream!, tracingPath);\n    this._tracingRecording = false;\n    const artifact = new Artifact(this, tracingPath);\n    artifact.reportFinished();\n    return artifact;\n  }\n\n  isConnected(): boolean {\n    return !this._connection._closed;\n  }\n\n  async _clientRootSession(): Promise<CDPSession> {\n    if (!this._clientRootSessionPromise)\n      this._clientRootSessionPromise = this._connection.createBrowserSession();\n    return this._clientRootSessionPromise;\n  }\n}\n\nexport class CRBrowserContext extends BrowserContext {\n  static CREvents = {\n    BackgroundPage: 'backgroundpage',\n    ServiceWorker: 'serviceworker',\n  };\n\n  declare readonly _browser: CRBrowser;\n\n  constructor(browser: CRBrowser, browserContextId: string | undefined, options: types.BrowserContextOptions) {\n    super(browser, options, browserContextId);\n    this._authenticateProxyViaCredentials();\n  }\n\n  override async _initialize() {\n    assert(!Array.from(this._browser._crPages.values()).some(page => page._browserContext === this));\n    const promises: Promise<any>[] = [super._initialize()];\n    if (this._browser.options.name !== 'clank' && this._options.acceptDownloads !== 'internal-browser-default') {\n      promises.push(this._browser._session.send('Browser.setDownloadBehavior', {\n        behavior: this._options.acceptDownloads === 'accept' ? 'allowAndName' : 'deny',\n        browserContextId: this._browserContextId,\n        downloadPath: this._browser.options.downloadsPath,\n        eventsEnabled: true,\n      }));\n    }\n    await Promise.all(promises);\n  }\n\n  private _crPages() {\n    return [...this._browser._crPages.values()].filter(crPage => crPage._browserContext === this);\n  }\n\n  override possiblyUninitializedPages(): Page[] {\n    return this._crPages().map(crPage => crPage._page);\n  }\n\n  override async doCreateNewPage(): Promise<Page> {\n    const { targetId } = await this._browser._session.send('Target.createTarget', { url: 'about:blank', browserContextId: this._browserContextId });\n    return this._browser._crPages.get(targetId)!._page;\n  }\n\n  async doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]> {\n    const { cookies } = await this._browser._session.send('Storage.getCookies', { browserContextId: this._browserContextId });\n    return network.filterCookies(cookies.map(c => {\n      const { name, value, domain, path, expires, httpOnly, secure, sameSite } = c;\n      const copy: channels.NetworkCookie = {\n        name,\n        value,\n        domain,\n        path,\n        expires,\n        httpOnly,\n        secure,\n        sameSite: sameSite ?? 'Lax',\n      };\n      // If hasCrossSiteAncestor is false, the cookie is a partitioned first party cookie,\n      // this is Chromium specific, see https://chromestatus.com/feature/5144832583663616\n      // and https://github.com/explainers-by-googlers/CHIPS-spec.\n      if (c.partitionKey) {\n        copy._crHasCrossSiteAncestor = c.partitionKey.hasCrossSiteAncestor;\n        copy.partitionKey = c.partitionKey.topLevelSite;\n      }\n      return copy;\n    }), urls);\n  }\n\n  async addCookies(cookies: channels.SetNetworkCookie[]) {\n    function toChromiumCookie(cookie: channels.SetNetworkCookie) {\n      const { name, value, url, domain, path, expires, httpOnly, secure, sameSite, partitionKey, _crHasCrossSiteAncestor } = cookie;\n      const copy: Protocol.Network.CookieParam = {\n        name,\n        value,\n        url,\n        domain,\n        path,\n        expires,\n        httpOnly,\n        secure,\n        sameSite\n      };\n      if (partitionKey) {\n        copy.partitionKey = {\n          topLevelSite: partitionKey,\n          // _crHasCrossSiteAncestor is non-standard, set it true by default if the cookie is partitioned.\n          hasCrossSiteAncestor: _crHasCrossSiteAncestor ?? true,\n        };\n      }\n      return copy;\n    }\n\n    await this._browser._session.send('Storage.setCookies', {\n      cookies: network.rewriteCookies(cookies).map(toChromiumCookie),\n      browserContextId: this._browserContextId\n    });\n  }\n\n  async doClearCookies() {\n    await this._browser._session.send('Storage.clearCookies', { browserContextId: this._browserContextId });\n  }\n\n  async doGrantPermissions(origin: string, permissions: string[]) {\n    const webPermissionToProtocol = new Map<string, Protocol.Browser.PermissionType>([\n      ['geolocation', 'geolocation'],\n      ['midi', 'midi'],\n      ['notifications', 'notifications'],\n      ['camera', 'videoCapture'],\n      ['microphone', 'audioCapture'],\n      ['background-sync', 'backgroundSync'],\n      ['ambient-light-sensor', 'sensors'],\n      ['accelerometer', 'sensors'],\n      ['gyroscope', 'sensors'],\n      ['magnetometer', 'sensors'],\n      ['clipboard-read', 'clipboardReadWrite'],\n      ['clipboard-write', 'clipboardSanitizedWrite'],\n      ['payment-handler', 'paymentHandler'],\n      // chrome-specific permissions we have.\n      ['midi-sysex', 'midiSysex'],\n      ['storage-access', 'storageAccess'],\n      ['local-fonts', 'localFonts'],\n    ]);\n    const filtered = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission)\n        throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._browser._session.send('Browser.grantPermissions', { origin: origin === '*' ? undefined : origin, browserContextId: this._browserContextId, permissions: filtered });\n  }\n\n  async doClearPermissions() {\n    await this._browser._session.send('Browser.resetPermissions', { browserContextId: this._browserContextId });\n  }\n\n  async setGeolocation(geolocation?: types.Geolocation): Promise<void> {\n    verifyGeolocation(geolocation);\n    this._options.geolocation = geolocation;\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateGeolocation();\n  }\n\n  async doUpdateExtraHTTPHeaders(): Promise<void> {\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateExtraHTTPHeaders();\n    for (const sw of this.serviceWorkers())\n      await (sw as CRServiceWorker).updateExtraHTTPHeaders();\n  }\n\n  async setUserAgent(userAgent: string | undefined): Promise<void> {\n    this._options.userAgent = userAgent;\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateUserAgent();\n    // TODO: service workers don't have Emulation domain?\n  }\n\n  async doUpdateOffline(): Promise<void> {\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateOffline();\n    for (const sw of this.serviceWorkers())\n      await (sw as CRServiceWorker).updateOffline();\n  }\n\n  async doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void> {\n    this._options.httpCredentials = httpCredentials;\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateHttpCredentials();\n    for (const sw of this.serviceWorkers())\n      await (sw as CRServiceWorker).updateHttpCredentials();\n  }\n\n  async doAddInitScript(initScript: InitScript) {\n    for (const page of this.pages())\n      await (page.delegate as CRPage).addInitScript(initScript);\n  }\n\n  async doRemoveInitScripts(initScripts: InitScript[]) {\n    for (const page of this.pages())\n      await (page.delegate as CRPage).removeInitScripts(initScripts);\n  }\n\n  async doUpdateRequestInterception(): Promise<void> {\n    for (const page of this.pages())\n      await (page.delegate as CRPage).updateRequestInterception();\n    for (const sw of this.serviceWorkers())\n      await (sw as CRServiceWorker).updateRequestInterception();\n  }\n\n  override async doUpdateDefaultViewport() {\n    // No-op, because each page resets its own viewport.\n  }\n\n  override async doUpdateDefaultEmulatedMedia() {\n    // No-op, because each page resets its own color scheme.\n  }\n\n  override async doExposePlaywrightBinding() {\n    for (const page of this._crPages())\n      await page.exposePlaywrightBinding();\n  }\n\n  async doClose(reason: string | undefined) {\n    // Headful chrome cannot dispose browser context with opened 'beforeunload'\n    // dialogs, so we should close all that are currently opened.\n    // We also won't get new ones since `Target.disposeBrowserContext` does not trigger\n    // beforeunload.\n    await this.dialogManager.closeBeforeUnloadDialogs();\n\n    if (!this._browserContextId) {\n      await this.stopVideoRecording();\n      // Closing persistent context should close the browser.\n      await this._browser.close({ reason });\n      return;\n    }\n\n    await this._browser._session.send('Target.disposeBrowserContext', { browserContextId: this._browserContextId });\n    this._browser._contexts.delete(this._browserContextId);\n    for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {\n      if (serviceWorker.browserContext !== this)\n        continue;\n      // When closing a browser context, service workers are shutdown\n      // asynchronously and we get detached from them later.\n      // To avoid the wrong order of notifications, we manually fire\n      // \"close\" event here and forget about the service worker.\n      serviceWorker.didClose();\n      this._browser._serviceWorkers.delete(targetId);\n    }\n  }\n\n  async stopVideoRecording() {\n    await Promise.all(this._crPages().map(crPage => crPage._mainFrameSession._stopVideoRecording()));\n  }\n\n  onClosePersistent() {\n    // When persistent context is closed, we do not necessary get Target.detachedFromTarget\n    // for all the background pages.\n    for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {\n      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined()) {\n        backgroundPage.didClose();\n        this._browser._backgroundPages.delete(targetId);\n      }\n    }\n  }\n\n  override async clearCache(): Promise<void> {\n    for (const page of this._crPages())\n      await page._networkManager.clearCache();\n  }\n\n  async cancelDownload(guid: string) {\n    // The upstream CDP method is implemented in a way that no explicit error would be given\n    // regarding the requested `guid`, even if the download is in a state not suitable for\n    // cancellation (finished, cancelled, etc.) or the guid is invalid at all.\n    await this._browser._session.send('Browser.cancelDownload', {\n      guid: guid,\n      browserContextId: this._browserContextId,\n    });\n  }\n\n  backgroundPages(): Page[] {\n    const result: Page[] = [];\n    for (const backgroundPage of this._browser._backgroundPages.values()) {\n      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined())\n        result.push(backgroundPage._page);\n    }\n    return result;\n  }\n\n  serviceWorkers(): Worker[] {\n    return Array.from(this._browser._serviceWorkers.values()).filter(serviceWorker => serviceWorker.browserContext === this);\n  }\n\n  async newCDPSession(page: Page | Frame): Promise<CDPSession> {\n    let targetId: string | null = null;\n    if (page instanceof Page) {\n      targetId = (page.delegate as CRPage)._targetId;\n    } else if (page instanceof Frame) {\n      const session = (page._page.delegate as CRPage)._sessions.get(page._id);\n      if (!session)\n        throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);\n      targetId = session._targetId;\n    } else {\n      throw new Error('page: expected Page or Frame');\n    }\n\n    const rootSession = await this._browser._clientRootSession();\n    return rootSession.attachToTarget(targetId);\n  }\n}\n"],
  "mappings": "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",
  "names": ["path"]
}

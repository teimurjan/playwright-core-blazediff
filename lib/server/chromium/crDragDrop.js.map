{
  "version": 3,
  "sources": ["../../../src/server/chromium/crDragDrop.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\nimport { toModifiersMask } from './crProtocolHelper';\nimport { assert } from '../../utils';\n\nimport type { CRPage } from './crPage';\nimport type * as types from '../types';\nimport type { Protocol } from './protocol';\nimport type { Progress } from '../progress';\n\n\ndeclare global {\n  interface Window {\n    __cleanupDrag?: () => Promise<boolean>;\n  }\n}\n\nexport class DragManager {\n  private _crPage: CRPage;\n  private _dragState: Protocol.Input.DragData | null = null;\n  private _lastPosition = { x: 0, y: 0 };\n  constructor(page: CRPage) {\n    this._crPage = page;\n  }\n\n  async cancelDrag() {\n    if (!this._dragState)\n      return false;\n    await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n      type: 'dragCancel',\n      x: this._lastPosition.x,\n      y: this._lastPosition.y,\n      data: {\n        items: [],\n        dragOperationsMask: 0xFFFF,\n      }\n    });\n    this._dragState = null;\n    return true;\n  }\n\n  async interceptDragCausedByMove(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, moveCallback: () => Promise<void>): Promise<void> {\n    this._lastPosition = { x, y };\n    if (this._dragState) {\n      await progress.race(this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n        type: 'dragOver',\n        x,\n        y,\n        data: this._dragState,\n        modifiers: toModifiersMask(modifiers),\n      }));\n      return;\n    }\n    if (button !== 'left')\n      return moveCallback();\n\n    const client = this._crPage._mainFrameSession._client;\n    let onDragIntercepted: (payload: Protocol.Input.dragInterceptedPayload) => void;\n    const dragInterceptedPromise = new Promise<Protocol.Input.dragInterceptedPayload>(x => onDragIntercepted = x);\n\n    function setupDragListeners() {\n      let didStartDrag = Promise.resolve(false);\n      let dragEvent: Event|null = null;\n      const dragListener = (event: Event) => dragEvent = event;\n      const mouseListener = () => {\n        didStartDrag = new Promise<boolean>(callback => {\n          window.addEventListener('dragstart', dragListener, { once: true, capture: true });\n          setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);\n        });\n      };\n      window.addEventListener('mousemove', mouseListener, { once: true, capture: true });\n      window.__cleanupDrag = async () => {\n        const val = await didStartDrag;\n        window.removeEventListener('mousemove', mouseListener, { capture: true });\n        window.removeEventListener('dragstart', dragListener, { capture: true });\n        delete window.__cleanupDrag;\n        return val;\n      };\n    }\n\n    try {\n      let expectingDrag = false;\n      await progress.race(this._crPage._page.safeNonStallingEvaluateInAllFrames(`(${setupDragListeners.toString()})()`, 'utility'));\n      client.on('Input.dragIntercepted', onDragIntercepted!);\n      await client.send('Input.setInterceptDrags', { enabled: true });\n      try {\n        await progress.race(moveCallback());\n        expectingDrag = (await Promise.all(this._crPage._page.frames().map(async frame => {\n          return frame.nonStallingEvaluateInExistingContext('window.__cleanupDrag?.()', 'utility').catch(() => false);\n        }))).some(x => x);\n      } finally {\n        client.off('Input.dragIntercepted', onDragIntercepted!);\n        await client.send('Input.setInterceptDrags', { enabled: false });\n      }\n      this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;\n    } catch (error) {\n      // Cleanup without blocking, it will be done before the next playwright action.\n      this._crPage._page.safeNonStallingEvaluateInAllFrames('window.__cleanupDrag?.()', 'utility').catch(() => {});\n      throw error;\n    }\n\n    if (this._dragState) {\n      await progress.race(this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n        type: 'dragEnter',\n        x,\n        y,\n        data: this._dragState,\n        modifiers: toModifiersMask(modifiers),\n      }));\n    }\n  }\n\n  isDragging() {\n    return !!this._dragState;\n  }\n\n  async drop(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>) {\n    assert(this._dragState, 'missing drag state');\n    await progress.race(this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x,\n      y,\n      data: this._dragState,\n      modifiers: toModifiersMask(modifiers),\n    }));\n    this._dragState = null;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA,8BAAgC;AAChC,mBAAuB;AAchB,MAAM,YAAY;AAAA,EAIvB,YAAY,MAAc;AAF1B,SAAQ,aAA6C;AACrD,SAAQ,gBAAgB,EAAE,GAAG,GAAG,GAAG,EAAE;AAEnC,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,aAAa;AACjB,QAAI,CAAC,KAAK;AACR,aAAO;AACT,UAAM,KAAK,QAAQ,kBAAkB,QAAQ,KAAK,2BAA2B;AAAA,MAC3E,MAAM;AAAA,MACN,GAAG,KAAK,cAAc;AAAA,MACtB,GAAG,KAAK,cAAc;AAAA,MACtB,MAAM;AAAA,QACJ,OAAO,CAAC;AAAA,QACR,oBAAoB;AAAA,MACtB;AAAA,IACF,CAAC;AACD,SAAK,aAAa;AAClB,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,0BAA0B,UAAoB,GAAW,GAAW,QAAoC,SAAiC,WAAwC,cAAkD;AACvO,SAAK,gBAAgB,EAAE,GAAG,EAAE;AAC5B,QAAI,KAAK,YAAY;AACnB,YAAM,SAAS,KAAK,KAAK,QAAQ,kBAAkB,QAAQ,KAAK,2BAA2B;AAAA,QACzF,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,MAAM,KAAK;AAAA,QACX,eAAW,yCAAgB,SAAS;AAAA,MACtC,CAAC,CAAC;AACF;AAAA,IACF;AACA,QAAI,WAAW;AACb,aAAO,aAAa;AAEtB,UAAM,SAAS,KAAK,QAAQ,kBAAkB;AAC9C,QAAI;AACJ,UAAM,yBAAyB,IAAI,QAA+C,CAAAA,OAAK,oBAAoBA,EAAC;AAE5G,aAAS,qBAAqB;AAC5B,UAAI,eAAe,QAAQ,QAAQ,KAAK;AACxC,UAAI,YAAwB;AAC5B,YAAM,eAAe,CAAC,UAAiB,YAAY;AACnD,YAAM,gBAAgB,MAAM;AAC1B,uBAAe,IAAI,QAAiB,cAAY;AAC9C,iBAAO,iBAAiB,aAAa,cAAc,EAAE,MAAM,MAAM,SAAS,KAAK,CAAC;AAChF,qBAAW,MAAM,SAAS,YAAY,CAAC,UAAU,mBAAmB,KAAK,GAAG,CAAC;AAAA,QAC/E,CAAC;AAAA,MACH;AACA,aAAO,iBAAiB,aAAa,eAAe,EAAE,MAAM,MAAM,SAAS,KAAK,CAAC;AACjF,aAAO,gBAAgB,YAAY;AACjC,cAAM,MAAM,MAAM;AAClB,eAAO,oBAAoB,aAAa,eAAe,EAAE,SAAS,KAAK,CAAC;AACxE,eAAO,oBAAoB,aAAa,cAAc,EAAE,SAAS,KAAK,CAAC;AACvE,eAAO,OAAO;AACd,eAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI;AACF,UAAI,gBAAgB;AACpB,YAAM,SAAS,KAAK,KAAK,QAAQ,MAAM,mCAAmC,IAAI,mBAAmB,SAAS,CAAC,OAAO,SAAS,CAAC;AAC5H,aAAO,GAAG,yBAAyB,iBAAkB;AACrD,YAAM,OAAO,KAAK,2BAA2B,EAAE,SAAS,KAAK,CAAC;AAC9D,UAAI;AACF,cAAM,SAAS,KAAK,aAAa,CAAC;AAClC,yBAAiB,MAAM,QAAQ,IAAI,KAAK,QAAQ,MAAM,OAAO,EAAE,IAAI,OAAM,UAAS;AAChF,iBAAO,MAAM,qCAAqC,4BAA4B,SAAS,EAAE,MAAM,MAAM,KAAK;AAAA,QAC5G,CAAC,CAAC,GAAG,KAAK,CAAAA,OAAKA,EAAC;AAAA,MAClB,UAAE;AACA,eAAO,IAAI,yBAAyB,iBAAkB;AACtD,cAAM,OAAO,KAAK,2BAA2B,EAAE,SAAS,MAAM,CAAC;AAAA,MACjE;AACA,WAAK,aAAa,iBAAiB,MAAM,wBAAwB,OAAO;AAAA,IAC1E,SAAS,OAAO;AAEd,WAAK,QAAQ,MAAM,mCAAmC,4BAA4B,SAAS,EAAE,MAAM,MAAM;AAAA,MAAC,CAAC;AAC3G,YAAM;AAAA,IACR;AAEA,QAAI,KAAK,YAAY;AACnB,YAAM,SAAS,KAAK,KAAK,QAAQ,kBAAkB,QAAQ,KAAK,2BAA2B;AAAA,QACzF,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,MAAM,KAAK;AAAA,QACX,eAAW,yCAAgB,SAAS;AAAA,MACtC,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,aAAa;AACX,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,KAAK,UAAoB,GAAW,GAAW,WAAwC;AAC3F,6BAAO,KAAK,YAAY,oBAAoB;AAC5C,UAAM,SAAS,KAAK,KAAK,QAAQ,kBAAkB,QAAQ,KAAK,2BAA2B;AAAA,MACzF,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,MAAM,KAAK;AAAA,MACX,eAAW,yCAAgB,SAAS;AAAA,IACtC,CAAC,CAAC;AACF,SAAK,aAAa;AAAA,EACpB;AACF;",
  "names": ["x"]
}

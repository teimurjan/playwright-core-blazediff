{
  "version": 3,
  "sources": ["../../../src/server/chromium/crNetworkManager.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, headersArrayToObject, headersObjectToArray } from '../../utils';\nimport { eventsHelper } from '../utils/eventsHelper';\nimport { helper } from '../helper';\nimport * as network from '../network';\nimport { isProtocolError, isSessionClosedError } from '../protocolError';\n\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nimport type { RegisteredListener } from '../utils/eventsHelper';\nimport type * as contexts from '../browserContext';\nimport type * as frames from '../frames';\nimport type { Page } from '../page';\nimport type * as types from '../types';\nimport type { CRPage } from './crPage';\nimport type { CRServiceWorker } from './crServiceWorker';\n\n\ntype SessionInfo = {\n  session: CRSession;\n  isMain?: boolean;\n  workerFrame?: frames.Frame;\n  eventListeners: RegisteredListener[];\n};\n\nexport class CRNetworkManager {\n  private _page: Page | null;\n  private _serviceWorker: CRServiceWorker | null;\n  private _requestIdToRequest = new Map<string, InterceptableRequest>();\n  private _requestIdToRequestWillBeSentEvent = new Map<string, { sessionInfo: SessionInfo, event: Protocol.Network.requestWillBeSentPayload }>();\n  private _credentials: {origin?: string, username: string, password: string} | null = null;\n  private _attemptedAuthentications = new Set<string>();\n  private _userRequestInterceptionEnabled = false;\n  private _protocolRequestInterceptionEnabled = false;\n  private _offline = false;\n  private _extraHTTPHeaders: types.HeadersArray = [];\n  private _requestIdToRequestPausedEvent = new Map<string, { sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload }>();\n  private _responseExtraInfoTracker = new ResponseExtraInfoTracker();\n  private _sessions = new Map<CRSession, SessionInfo>();\n\n  constructor(page: Page | null, serviceWorker: CRServiceWorker | null) {\n    this._page = page;\n    this._serviceWorker = serviceWorker;\n  }\n\n  async addSession(session: CRSession, workerFrame?: frames.Frame, isMain?: boolean) {\n    const sessionInfo: SessionInfo = { session, isMain, workerFrame, eventListeners: [] };\n    sessionInfo.eventListeners = [\n      eventsHelper.addEventListener(session, 'Fetch.requestPaused', this._onRequestPaused.bind(this, sessionInfo)),\n      eventsHelper.addEventListener(session, 'Fetch.authRequired', this._onAuthRequired.bind(this, sessionInfo)),\n      eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this, sessionInfo)),\n      eventsHelper.addEventListener(session, 'Network.requestWillBeSentExtraInfo', this._onRequestWillBeSentExtraInfo.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.requestServedFromCache', this._onRequestServedFromCache.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this, sessionInfo)),\n      eventsHelper.addEventListener(session, 'Network.responseReceivedExtraInfo', this._onResponseReceivedExtraInfo.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.loadingFinished', this._onLoadingFinished.bind(this, sessionInfo)),\n      eventsHelper.addEventListener(session, 'Network.loadingFailed', this._onLoadingFailed.bind(this, sessionInfo)),\n    ];\n    if (this._page) {\n      sessionInfo.eventListeners.push(...[\n        eventsHelper.addEventListener(session, 'Network.webSocketCreated', e => this._page!.frameManager.onWebSocketCreated(e.requestId, e.url)),\n        eventsHelper.addEventListener(session, 'Network.webSocketWillSendHandshakeRequest', e => this._page!.frameManager.onWebSocketRequest(e.requestId)),\n        eventsHelper.addEventListener(session, 'Network.webSocketHandshakeResponseReceived', e => this._page!.frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),\n        eventsHelper.addEventListener(session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page!.frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),\n        eventsHelper.addEventListener(session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page!.frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),\n        eventsHelper.addEventListener(session, 'Network.webSocketClosed', e => this._page!.frameManager.webSocketClosed(e.requestId)),\n        eventsHelper.addEventListener(session, 'Network.webSocketFrameError', e => this._page!.frameManager.webSocketError(e.requestId, e.errorMessage)),\n      ]);\n    }\n    this._sessions.set(session, sessionInfo);\n    await Promise.all([\n      session.send('Network.enable'),\n      this._updateProtocolRequestInterceptionForSession(sessionInfo, true /* initial */),\n      this._setOfflineForSession(sessionInfo, true /* initial */),\n      this._setExtraHTTPHeadersForSession(sessionInfo, true /* initial */),\n    ]);\n  }\n\n  removeSession(session: CRSession) {\n    const info = this._sessions.get(session);\n    if (info)\n      eventsHelper.removeEventListeners(info.eventListeners);\n    this._sessions.delete(session);\n  }\n\n  private async _forEachSession(cb: (sessionInfo: SessionInfo) => Promise<any>) {\n    await Promise.all([...this._sessions.values()].map(info => {\n      if (info.isMain)\n        return cb(info);\n      return cb(info).catch(e => {\n        // Broadcasting a message to the closed target should be a noop.\n        if (isSessionClosedError(e))\n          return;\n        throw e;\n      });\n    }));\n  }\n\n  async authenticate(credentials: types.Credentials | null) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async setOffline(offline: boolean) {\n    if (offline === this._offline)\n      return;\n    this._offline = offline;\n    await this._forEachSession(info => this._setOfflineForSession(info));\n  }\n\n  private async _setOfflineForSession(info: SessionInfo, initial?: boolean) {\n    if (initial && !this._offline)\n      return;\n    // Workers are affected by the owner frame's Network.emulateNetworkConditions.\n    if (info.workerFrame)\n      return;\n    await info.session.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n\n  async setRequestInterception(value: boolean) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled)\n      return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    await this._forEachSession(info => this._updateProtocolRequestInterceptionForSession(info));\n  }\n\n  private async _updateProtocolRequestInterceptionForSession(info: SessionInfo, initial?: boolean) {\n    const enabled = this._protocolRequestInterceptionEnabled;\n    if (initial && !enabled)\n      return;\n    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });\n    let fetchPromise = Promise.resolve<any>(undefined);\n    if (!info.workerFrame) {\n      if (enabled)\n        fetchPromise = info.session.send('Fetch.enable', { handleAuthRequests: true, patterns: [{ urlPattern: '*', requestStage: 'Request' }] });\n      else\n        fetchPromise = info.session.send('Fetch.disable');\n    }\n    await Promise.all([cachePromise, fetchPromise]);\n  }\n\n  async setExtraHTTPHeaders(extraHTTPHeaders: types.HeadersArray) {\n    if (!this._extraHTTPHeaders.length && !extraHTTPHeaders.length)\n      return;\n    this._extraHTTPHeaders = extraHTTPHeaders;\n    await this._forEachSession(info => this._setExtraHTTPHeadersForSession(info));\n  }\n\n  private async _setExtraHTTPHeadersForSession(info: SessionInfo, initial?: boolean) {\n    if (initial && !this._extraHTTPHeaders.length)\n      return;\n    await info.session.send('Network.setExtraHTTPHeaders', { headers: headersArrayToObject(this._extraHTTPHeaders, false /* lowerCase */) });\n  }\n\n  async clearCache() {\n    await this._forEachSession(async info => {\n      // Sending 'Network.setCacheDisabled' with 'cacheDisabled = true' will clear the MemoryCache.\n      await info.session.send('Network.setCacheDisabled', { cacheDisabled: true });\n      if (!this._protocolRequestInterceptionEnabled)\n        await info.session.send('Network.setCacheDisabled', { cacheDisabled: false });\n      if (!info.workerFrame)\n        await info.session.send('Network.clearBrowserCache');\n    });\n  }\n\n  _onRequestWillBeSent(sessionInfo: SessionInfo, event: Protocol.Network.requestWillBeSentPayload) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n      if (requestPausedEvent) {\n        this._onRequest(sessionInfo, event, requestPausedEvent.sessionInfo, requestPausedEvent.event);\n        this._requestIdToRequestPausedEvent.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, { sessionInfo, event });\n      }\n    } else {\n      this._onRequest(sessionInfo, event, undefined, undefined);\n    }\n  }\n\n  _onRequestServedFromCache(event: Protocol.Network.requestServedFromCachePayload) {\n    this._responseExtraInfoTracker.requestServedFromCache(event);\n  }\n\n  _onRequestWillBeSentExtraInfo(event: Protocol.Network.requestWillBeSentExtraInfoPayload) {\n    this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);\n  }\n\n  _onAuthRequired(sessionInfo: SessionInfo, event: Protocol.Fetch.authRequiredPayload) {\n    let response: 'Default' | 'CancelAuth' | 'ProvideCredentials' = 'Default';\n    const shouldProvideCredentials = this._shouldProvideCredentials(event.request.url);\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (shouldProvideCredentials) {\n      response = 'ProvideCredentials';\n      this._attemptedAuthentications.add(event.requestId);\n    }\n    const { username, password } =  shouldProvideCredentials && this._credentials ? this._credentials : { username: undefined, password: undefined };\n    sessionInfo.session._sendMayFail('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: { response, username, password },\n    });\n  }\n\n  _shouldProvideCredentials(url: string): boolean {\n    if (!this._credentials)\n      return false;\n    return !this._credentials.origin || new URL(url).origin.toLowerCase() === this._credentials.origin.toLowerCase();\n  }\n\n  _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload) {\n    if (!event.networkId) {\n      // Fetch without networkId means that request was not recognized by inspector, and\n      // it will never receive Network.requestWillBeSent. Continue the request to not affect it.\n      sessionInfo.session._sendMayFail('Fetch.continueRequest', { requestId: event.requestId });\n      return;\n    }\n    if (event.request.url.startsWith('data:'))\n      return;\n\n    const requestId = event.networkId;\n    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n    if (requestWillBeSentEvent) {\n      this._onRequest(requestWillBeSentEvent.sessionInfo, requestWillBeSentEvent.event, sessionInfo, event);\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      const existingRequest = this._requestIdToRequest.get(requestId);\n      const alreadyContinuedParams = existingRequest?._route?._alreadyContinuedParams;\n      if (alreadyContinuedParams && !event.redirectedRequestId) {\n        // Sometimes Chromium network stack restarts the request internally.\n        // For example, when no-cors request hits a \"less public address space\", it should be resent with cors.\n        // There are some more examples here: https://source.chromium.org/chromium/chromium/src/+/main:services/network/url_loader.cc;l=1205-1234;drc=d5dd931e0ad3d9ffe74888ec62a3cc106efd7ea6\n        // There are probably even more cases deep inside the network stack.\n        //\n        // Anyway, in this case, continue the request in the same way as before, and it should go through.\n        //\n        // Note: make sure not to prematurely continue the redirect, which shares the\n        // `networkId` between the original request and the redirect.\n        sessionInfo.session._sendMayFail('Fetch.continueRequest', {\n          ...alreadyContinuedParams,\n          requestId: event.requestId,\n        });\n        return;\n      }\n      this._requestIdToRequestPausedEvent.set(requestId, { sessionInfo, event });\n    }\n  }\n\n  _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined) {\n    if (requestWillBeSentEvent.request.url.startsWith('data:'))\n      return;\n    let redirectedFrom: InterceptableRequest | null = null;\n    if (requestWillBeSentEvent.redirectResponse) {\n      const request = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);\n        redirectedFrom = request;\n      }\n    }\n    let frame = requestWillBeSentEvent.frameId ? this._page?.frameManager.frame(requestWillBeSentEvent.frameId) : requestWillBeSentSessionInfo.workerFrame;\n    // Requests from workers lack frameId, because we receive Network.requestWillBeSent\n    // on the worker target. However, we receive Fetch.requestPaused on the page target,\n    // and lack workerFrame there. Luckily, Fetch.requestPaused provides a frameId.\n    if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId)\n      frame = this._page.frameManager.frame(requestPausedEvent.frameId);\n\n    // Check if it's main resource request interception (targetId === main frame id).\n    if (!frame && this._page && requestWillBeSentEvent.frameId === (this._page?.delegate as CRPage)._targetId) {\n      // Main resource request for the page is being intercepted so the Frame is not created\n      // yet. Precreate it here for the purposes of request interception. It will be updated\n      // later as soon as the request continues and we receive frame tree from the page.\n      frame = this._page.frameManager.frameAttached(requestWillBeSentEvent.frameId, null);\n    }\n\n    // CORS options preflight request is generated by the network stack. If interception is enabled,\n    // we accept all CORS options, assuming that this was intended when setting route.\n    //\n    // Note: it would be better to match the URL against interception patterns.\n    const isInterceptedOptionsPreflight = !!requestPausedEvent && requestPausedEvent.request.method === 'OPTIONS' && requestWillBeSentEvent.initiator.type === 'preflight';\n    if (isInterceptedOptionsPreflight && (this._page || this._serviceWorker)!.needsRequestInterception()) {\n      const requestHeaders = requestPausedEvent.request.headers;\n      const responseHeaders: Protocol.Fetch.HeaderEntry[] = [\n        { name: 'Access-Control-Allow-Origin', value: requestHeaders['Origin'] || '*' },\n        { name: 'Access-Control-Allow-Methods', value: requestHeaders['Access-Control-Request-Method'] || 'GET, POST, OPTIONS, DELETE' },\n        { name: 'Access-Control-Allow-Credentials', value: 'true' }\n      ];\n      if (requestHeaders['Access-Control-Request-Headers'])\n        responseHeaders.push({ name: 'Access-Control-Allow-Headers', value: requestHeaders['Access-Control-Request-Headers'] });\n      requestPausedSessionInfo!.session._sendMayFail('Fetch.fulfillRequest', {\n        requestId: requestPausedEvent.requestId,\n        responseCode: 204,\n        responsePhrase: network.statusText(204),\n        responseHeaders,\n        body: '',\n      });\n      return;\n    }\n\n    // Non-service-worker requests MUST have a frame\u2014if they don't, we pretend there was no request\n    if (!frame && !this._serviceWorker) {\n      if (requestPausedEvent)\n        requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId });\n      return;\n    }\n\n    let route = null;\n    let headersOverride: types.HeadersArray | undefined;\n    if (requestPausedEvent) {\n      // We do not support intercepting redirects.\n      if (redirectedFrom || (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled)) {\n        // Chromium does not preserve header overrides between redirects, so we have to do it ourselves.\n        headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;\n        requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });\n      } else {\n        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);\n      }\n    }\n    const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';\n    const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : undefined;\n    const request = new InterceptableRequest({\n      session: requestWillBeSentSessionInfo.session,\n      context: (this._page || this._serviceWorker)!.browserContext,\n      frame: frame || null,\n      serviceWorker: this._serviceWorker || null,\n      documentId,\n      route,\n      requestWillBeSentEvent,\n      requestPausedEvent,\n      redirectedFrom,\n      headersOverride: headersOverride || null,\n    });\n    this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);\n\n    if (route) {\n      // We may not receive extra info when intercepting the request.\n      // Use the headers from the Fetch.requestPausedPayload and release the allHeaders()\n      // right away, so that client can call it from the route handler.\n      request.request.setRawRequestHeaders(headersObjectToArray(requestPausedEvent!.request.headers, '\\n'));\n    }\n    (this._page?.frameManager || this._serviceWorker)!.requestStarted(request.request, route || undefined);\n  }\n\n  _createResponse(request: InterceptableRequest, responsePayload: Protocol.Network.Response, hasExtraInfo: boolean): network.Response {\n    const getResponseBody = async () => {\n      const contentLengthHeader = Object.entries(responsePayload.headers).find(header => header[0].toLowerCase() === 'content-length');\n      const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : undefined;\n\n      const session = request.session;\n      const response = await session.send('Network.getResponseBody', { requestId: request._requestId });\n      if (response.body || !expectedLength)\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n\n      // Make sure no network requests sent while reading the body for fulfilled requests.\n      if (request._route?._fulfilled)\n        return Buffer.from('');\n\n      // For <link prefetch we are going to receive empty body with non-empty content-length expectation. Reach out for the actual content.\n      const resource = await session.send('Network.loadNetworkResource', { url: request.request.url(), frameId: this._serviceWorker ? undefined : request.request.frame()!._id, options: { disableCache: false, includeCredentials: true } });\n      const chunks: Buffer[] = [];\n      while (resource.resource.stream) {\n        const chunk = await session.send('IO.read', { handle: resource.resource.stream });\n        chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? 'base64' : 'utf-8'));\n        if (chunk.eof) {\n          await session.send('IO.close', { handle: resource.resource.stream });\n          break;\n        }\n      }\n      return Buffer.concat(chunks);\n    };\n    const timingPayload = responsePayload.timing!;\n    let timing: network.ResourceTiming;\n    if (timingPayload && !this._responseExtraInfoTracker.servedFromCache(request._requestId)) {\n      timing = {\n        startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1000,\n        domainLookupStart: timingPayload.dnsStart,\n        domainLookupEnd: timingPayload.dnsEnd,\n        connectStart: timingPayload.connectStart,\n        secureConnectionStart: timingPayload.sslStart,\n        connectEnd: timingPayload.connectEnd,\n        requestStart: timingPayload.sendStart,\n        responseStart: timingPayload.receiveHeadersEnd,\n      };\n    } else {\n      timing = {\n        startTime: request._wallTime * 1000,\n        domainLookupStart: -1,\n        domainLookupEnd: -1,\n        connectStart: -1,\n        secureConnectionStart: -1,\n        connectEnd: -1,\n        requestStart: -1,\n        responseStart: -1,\n      };\n    }\n    const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, headersObjectToArray(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);\n    if (responsePayload?.remoteIPAddress && typeof responsePayload?.remotePort === 'number') {\n      response._serverAddrFinished({\n        ipAddress: responsePayload.remoteIPAddress,\n        port: responsePayload.remotePort,\n      });\n    } else {\n      response._serverAddrFinished();\n    }\n    response._securityDetailsFinished({\n      protocol: responsePayload?.securityDetails?.protocol,\n      subjectName: responsePayload?.securityDetails?.subjectName,\n      issuer: responsePayload?.securityDetails?.issuer,\n      validFrom: responsePayload?.securityDetails?.validFrom,\n      validTo: responsePayload?.securityDetails?.validTo,\n    });\n    this._responseExtraInfoTracker.processResponse(request._requestId, response, hasExtraInfo);\n    return response;\n  }\n\n  _deleteRequest(request: InterceptableRequest) {\n    this._requestIdToRequest.delete(request._requestId);\n    if (request._interceptionId)\n      this._attemptedAuthentications.delete(request._interceptionId);\n  }\n\n  _handleRequestRedirect(request: InterceptableRequest, responsePayload: Protocol.Network.Response, timestamp: number, hasExtraInfo: boolean) {\n    const response = this._createResponse(request, responsePayload, hasExtraInfo);\n    response.setTransferSize(null);\n    response.setEncodedBodySize(null);\n    response._requestFinished((timestamp - request._timestamp) * 1000);\n    this._deleteRequest(request);\n    (this._page?.frameManager || this._serviceWorker)!.requestReceivedResponse(response);\n    (this._page?.frameManager || this._serviceWorker)!.reportRequestFinished(request.request, response);\n  }\n\n  _onResponseReceivedExtraInfo(event: Protocol.Network.responseReceivedExtraInfoPayload) {\n    this._responseExtraInfoTracker.responseReceivedExtraInfo(event);\n  }\n\n  _onResponseReceived(sessionInfo: SessionInfo, event: Protocol.Network.responseReceivedPayload) {\n    let request = this._requestIdToRequest.get(event.requestId);\n    // For frame-level Requests that are handled by a Service Worker's fetch handler, we'll never get a requestPaused event, so we need to\n    // manually create the request. In an ideal world, crNetworkManager would be able to know this on Network.requestWillBeSent, but there\n    // is not enough metadata there.\n    if (!request && event.response.fromServiceWorker) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);\n      if (requestWillBeSentEvent) {\n        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);\n        this._onRequest(sessionInfo, requestWillBeSentEvent.event, undefined, undefined);\n        request = this._requestIdToRequest.get(event.requestId);\n      }\n    }\n    // FileUpload sends a response without a matching request.\n    if (!request)\n      return;\n    const response = this._createResponse(request, event.response, event.hasExtraInfo);\n    (this._page?.frameManager || this._serviceWorker)!.requestReceivedResponse(response);\n  }\n\n  _onLoadingFinished(sessionInfo: SessionInfo, event: Protocol.Network.loadingFinishedPayload) {\n    this._responseExtraInfoTracker.loadingFinished(event);\n\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    this._maybeUpdateRequestSession(sessionInfo, request);\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(event.encodedDataLength);\n      response.responseHeadersSize().then(size => response.setEncodedBodySize(event.encodedDataLength - size));\n      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    }\n    this._deleteRequest(request);\n    (this._page?.frameManager || this._serviceWorker)!.reportRequestFinished(request.request, response);\n  }\n\n  _onLoadingFailed(sessionInfo: SessionInfo, event: Protocol.Network.loadingFailedPayload) {\n    this._responseExtraInfoTracker.loadingFailed(event);\n\n    let request = this._requestIdToRequest.get(event.requestId);\n\n    if (!request) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);\n      if (requestWillBeSentEvent) {\n        // This is a case where request has failed before we had a chance to intercept it.\n        // We stop waiting for Fetch.requestPaused (it might never come), and dispatch request event\n        // right away, followed by requestfailed event.\n        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);\n        this._onRequest(sessionInfo, requestWillBeSentEvent.event, undefined, undefined);\n        request = this._requestIdToRequest.get(event.requestId);\n      }\n    }\n\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    this._maybeUpdateRequestSession(sessionInfo, request);\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(null);\n      response.setEncodedBodySize(null);\n      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request._timestamp));\n    } else {\n      // Loading failed before response has arrived - there will be no extra info events.\n      request.request.setRawRequestHeaders(null);\n    }\n    this._deleteRequest(request);\n    request.request._setFailureText(event.errorText || event.blockedReason || '');\n    (this._page?.frameManager || this._serviceWorker)!.requestFailed(request.request, !!event.canceled);\n  }\n\n  private _maybeUpdateRequestSession(sessionInfo: SessionInfo, request: InterceptableRequest) {\n    // OOPIF has a main request that starts in the parent session but finishes in the child session.\n    // We check for the main request by matching loaderId and requestId, and if it now belongs to\n    // a child session, migrate it there.\n    //\n    // Same goes for the main worker script with PlzDedicatedWorker enabled, which is the default.\n    // Here we check the `workerFrame`.\n    //\n    // In theory, we can always update the session. However, we try to be conservative here\n    // to make sure we understand all the scenarios where the session should be updated.\n    if (request.session !== sessionInfo.session && !sessionInfo.isMain && (request._documentId === request._requestId || sessionInfo.workerFrame))\n      request.session = sessionInfo.session;\n  }\n}\n\nclass InterceptableRequest {\n  readonly request: network.Request;\n  readonly _requestId: string;\n  readonly _interceptionId: string | undefined;\n  readonly _documentId: string | undefined;\n  readonly _timestamp: number;\n  readonly _wallTime: number;\n  readonly _route: RouteImpl | null;\n  // Only first request in the chain can be intercepted, so this will\n  // store the first and only Route in the chain (if any).\n  readonly _originalRequestRoute: RouteImpl | undefined;\n  session: CRSession;\n\n  constructor(options: {\n    session: CRSession,\n    context: contexts.BrowserContext;\n    frame: frames.Frame | null;\n    serviceWorker: CRServiceWorker | null;\n    documentId?: string;\n    route: RouteImpl | null;\n    requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload;\n    requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined;\n    redirectedFrom: InterceptableRequest | null;\n    headersOverride: types.HeadersArray | null;\n  }) {\n    const { session, context, frame, documentId, route, requestWillBeSentEvent, requestPausedEvent, redirectedFrom, serviceWorker, headersOverride } = options;\n    this.session = session;\n    this._timestamp = requestWillBeSentEvent.timestamp;\n    this._wallTime = requestWillBeSentEvent.wallTime;\n    this._requestId = requestWillBeSentEvent.requestId;\n    this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;\n    this._documentId = documentId;\n    this._route = route;\n    this._originalRequestRoute = route ?? redirectedFrom?._originalRequestRoute;\n\n    const {\n      headers,\n      method,\n      url,\n      postDataEntries = null,\n    } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;\n    const type = (requestWillBeSentEvent.type || '').toLowerCase();\n    let postDataBuffer = null;\n    const entries = postDataEntries?.filter(entry => entry.bytes);\n    if (entries && entries.length)\n      postDataBuffer = Buffer.concat(entries.map(entry => Buffer.from(entry.bytes!, 'base64')));\n\n    this.request = new network.Request(context, frame, serviceWorker, redirectedFrom?.request || null, documentId, url, type, method, postDataBuffer,  headersOverride || headersObjectToArray(headers));\n  }\n}\n\nclass RouteImpl implements network.RouteDelegate {\n  private readonly _session: CRSession;\n  private _interceptionId: string;\n  _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;\n  _fulfilled: boolean = false;\n\n  constructor(session: CRSession, interceptionId: string) {\n    this._session = session;\n    this._interceptionId = interceptionId;\n  }\n\n  async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {\n    this._alreadyContinuedParams = {\n      requestId: this._interceptionId!,\n      url: overrides.url,\n      headers: overrides.headers,\n      method: overrides.method,\n      postData: overrides.postData ? overrides.postData.toString('base64') : undefined\n    };\n    await catchDisallowedErrors(async () => {\n      await this._session.send('Fetch.continueRequest', this._alreadyContinuedParams);\n    });\n  }\n\n  async fulfill(response: types.NormalizedFulfillResponse) {\n    this._fulfilled = true;\n    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');\n\n    const responseHeaders = splitSetCookieHeader(response.headers);\n    await catchDisallowedErrors(async () => {\n      await this._session.send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId!,\n        responseCode: response.status,\n        responsePhrase: network.statusText(response.status),\n        responseHeaders,\n        body,\n      });\n    });\n  }\n\n  async abort(errorCode: string = 'failed') {\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    await catchDisallowedErrors(async () => {\n      await this._session.send('Fetch.failRequest', {\n        requestId: this._interceptionId!,\n        errorReason\n      });\n    });\n  }\n}\n\n// In certain cases, protocol will return error if the request was already canceled\n// or the page was closed. We should tolerate these errors but propagate other.\nasync function catchDisallowedErrors(callback: () => Promise<void>) {\n  try {\n    return await callback();\n  } catch (e) {\n    if (isProtocolError(e) && e.message.includes('Invalid http status code or phrase'))\n      throw e;\n    if (isProtocolError(e) && e.message.includes('Unsafe header'))\n      throw e;\n  }\n}\n\n\nfunction splitSetCookieHeader(headers: types.HeadersArray): types.HeadersArray {\n  const index = headers.findIndex(({ name }) => name.toLowerCase() === 'set-cookie');\n  if (index === -1)\n    return headers;\n\n  const header = headers[index];\n  const values = header.value.split('\\n');\n  if (values.length === 1)\n    return headers;\n  const result = headers.slice();\n  result.splice(index, 1, ...values.map(value => ({ name: header.name, value })));\n  return result;\n}\n\nconst errorReasons: { [reason: string]: Protocol.Network.ErrorReason } = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed',\n};\n\ntype RequestInfo = {\n  requestId: string,\n  // Events are replaced with \"undefined\" to avoid updating the same headers twice.\n  requestWillBeSentExtraInfo: (Protocol.Network.requestWillBeSentExtraInfoPayload | undefined)[],\n  responseReceivedExtraInfo: (Protocol.Network.responseReceivedExtraInfoPayload | undefined)[],\n  // Note: we only put the responses that expect extra info in this list.\n  // Since the order of responses and extraInfo events is the same, each response\n  // will get a pair of matching request/response extraInfo events in this list.\n  responses: network.Response[],\n  loadingFinished?: Protocol.Network.loadingFinishedPayload,\n  loadingFailed?: Protocol.Network.loadingFailedPayload,\n  servedFromCache?: boolean,\n};\n\n// This class aligns responses with response headers from extra info:\n//   - Network.requestWillBeSent, Network.responseReceived, Network.loadingFinished/loadingFailed are\n//     dispatched using one channel.\n//   - Network.requestWillBeSentExtraInfo and Network.responseReceivedExtraInfo are dispatched on\n//     another channel. Those channels are not associated, so events come in random order.\n//\n// This class will associate responses with the new headers. These extra info headers will become\n// available to client reliably upon requestfinished event only. It consumes CDP\n// signals on one end and processResponse(network.Response) signals on the other hands. It then makes\n// sure that responses have all the extra headers in place by the time request finishes.\n//\n// The shape of the instrumentation API is deliberately following the CDP, so that it\n// is clear what is called when and what this means to the tracker without extra\n// documentation.\nclass ResponseExtraInfoTracker {\n  private _requests = new Map<string, RequestInfo>();\n\n  requestWillBeSentExtraInfo(event: Protocol.Network.requestWillBeSentExtraInfoPayload) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.requestWillBeSentExtraInfo.push(event);\n    this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);\n    this._checkFinished(info);\n  }\n\n  requestServedFromCache(event: Protocol.Network.requestServedFromCachePayload) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.servedFromCache = true;\n  }\n\n  servedFromCache(requestId: string): boolean {\n    const info = this._requests.get(requestId);\n    return !!info?.servedFromCache;\n  }\n\n  responseReceivedExtraInfo(event: Protocol.Network.responseReceivedExtraInfoPayload) {\n    const info = this._getOrCreateEntry(event.requestId);\n    info.responseReceivedExtraInfo.push(event);\n    this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);\n    this._checkFinished(info);\n  }\n\n  processResponse(requestId: string, response: network.Response, hasExtraInfo: boolean) {\n    let info = this._requests.get(requestId);\n    // Cached responses have erroneous \"hasExtraInfo\" flag.\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1340398\n    if (!hasExtraInfo || info?.servedFromCache) {\n      // Use \"provisional\" headers as \"raw\" ones.\n      response.request().setRawRequestHeaders(null);\n      response.setResponseHeadersSize(null);\n      response.setRawResponseHeaders(null);\n      return;\n    }\n\n    info = this._getOrCreateEntry(requestId);\n    info.responses.push(response);\n    this._patchHeaders(info, info.responses.length - 1);\n  }\n\n  loadingFinished(event: Protocol.Network.loadingFinishedPayload) {\n    const info = this._requests.get(event.requestId);\n    if (!info)\n      return;\n    info.loadingFinished = event;\n    this._checkFinished(info);\n  }\n\n  loadingFailed(event: Protocol.Network.loadingFailedPayload) {\n    const info = this._requests.get(event.requestId);\n    if (!info)\n      return;\n    info.loadingFailed = event;\n    this._checkFinished(info);\n  }\n\n  _getOrCreateEntry(requestId: string): RequestInfo {\n    let info = this._requests.get(requestId);\n    if (!info) {\n      info = {\n        requestId: requestId,\n        requestWillBeSentExtraInfo: [],\n        responseReceivedExtraInfo: [],\n        responses: [],\n      };\n      this._requests.set(requestId, info);\n    }\n    return info;\n  }\n\n  private _patchHeaders(info: RequestInfo, index: number) {\n    const response = info.responses[index];\n    const requestExtraInfo = info.requestWillBeSentExtraInfo[index];\n    if (response && requestExtraInfo) {\n      response.request().setRawRequestHeaders(headersObjectToArray(requestExtraInfo.headers, '\\n'));\n      info.requestWillBeSentExtraInfo[index] = undefined;\n    }\n    const responseExtraInfo = info.responseReceivedExtraInfo[index];\n    if (response && responseExtraInfo) {\n      response.setResponseHeadersSize(responseExtraInfo.headersText?.length || 0);\n      response.setRawResponseHeaders(headersObjectToArray(responseExtraInfo.headers, '\\n'));\n      info.responseReceivedExtraInfo[index] = undefined;\n    }\n  }\n\n  private _checkFinished(info: RequestInfo) {\n    if (!info.loadingFinished && !info.loadingFailed)\n      return;\n\n    if (info.responses.length <= info.responseReceivedExtraInfo.length) {\n      // We have extra info for each response.\n      this._stopTracking(info.requestId);\n      return;\n    }\n\n    // We are not done yet.\n  }\n\n  private _stopTracking(requestId: string) {\n    this._requests.delete(requestId);\n  }\n}\n"],
  "mappings": "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",
  "names": ["request", "response"]
}

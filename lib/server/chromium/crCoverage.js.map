{
  "version": 3,
  "sources": ["../../../src/server/chromium/crCoverage.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '../../utils';\nimport { eventsHelper } from '../utils/eventsHelper';\nimport { raceUncancellableOperationWithCleanup } from '../progress';\n\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nimport type { RegisteredListener } from '../utils/eventsHelper';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\n\n\nexport class CRCoverage {\n  private _jsCoverage: JSCoverage;\n  private _cssCoverage: CSSCoverage;\n\n  constructor(client: CRSession) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n\n  async startJSCoverage(progress: Progress, options: channels.PageStartJSCoverageParams) {\n    await raceUncancellableOperationWithCleanup(progress, () => this._jsCoverage.start(options), () => this._jsCoverage.stop());\n  }\n\n  async stopJSCoverage(): Promise<channels.PageStopJSCoverageResult> {\n    return await this._jsCoverage.stop();\n  }\n\n  async startCSSCoverage(progress: Progress, options: channels.PageStartCSSCoverageParams) {\n    await raceUncancellableOperationWithCleanup(progress, () => this._cssCoverage.start(options), () => this._cssCoverage.stop());\n  }\n\n  async stopCSSCoverage(): Promise<channels.PageStopCSSCoverageResult> {\n    return await this._cssCoverage.stop();\n  }\n}\n\nclass JSCoverage {\n  _client: CRSession;\n  _enabled: boolean;\n  _scriptIds: Set<string>;\n  _scriptSources: Map<string, string>;\n  _eventListeners: RegisteredListener[];\n  _resetOnNavigation: boolean;\n  _reportAnonymousScripts = false;\n\n  constructor(client: CRSession) {\n    this._client = client;\n    this._enabled = false;\n    this._scriptIds = new Set();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  async start(options: channels.PageStartJSCoverageParams) {\n    assert(!this._enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._reportAnonymousScripts = reportAnonymousScripts;\n    this._enabled = true;\n    this._scriptIds.clear();\n    this._scriptSources.clear();\n    this._eventListeners = [\n      eventsHelper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),\n      eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n      eventsHelper.addEventListener(this._client, 'Debugger.paused', this._onDebuggerPaused.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('Profiler.enable'),\n      this._client.send('Profiler.startPreciseCoverage', { callCount: true, detailed: true }),\n      this._client.send('Debugger.enable'),\n      this._client.send('Debugger.setSkipAllPauses', { skip: true })\n    ]);\n  }\n\n  _onDebuggerPaused() {\n    this._client.send('Debugger.resume');\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._scriptIds.clear();\n    this._scriptSources.clear();\n  }\n\n  async _onScriptParsed(event: Protocol.Debugger.scriptParsedPayload) {\n    this._scriptIds.add(event.scriptId);\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this._reportAnonymousScripts)\n      return;\n    // This might fail if the page has already navigated away.\n    const response = await this._client._sendMayFail('Debugger.getScriptSource', { scriptId: event.scriptId });\n    if (response)\n      this._scriptSources.set(event.scriptId, response.scriptSource);\n  }\n\n  async stop(): Promise<channels.PageStopJSCoverageResult> {\n    if (!this._enabled)\n      return { entries: [] };\n    const [profileResponse] = await Promise.all([\n      this._client.send('Profiler.takePreciseCoverage'),\n      this._client.send('Profiler.stopPreciseCoverage'),\n      this._client.send('Profiler.disable'),\n      this._client.send('Debugger.disable'),\n    ] as const);\n    eventsHelper.removeEventListeners(this._eventListeners);\n    this._enabled = false;\n\n    const coverage: channels.PageStopJSCoverageResult = { entries: [] };\n    for (const entry of profileResponse.result) {\n      if (!this._scriptIds.has(entry.scriptId))\n        continue;\n      if (!entry.url && !this._reportAnonymousScripts)\n        continue;\n      const source = this._scriptSources.get(entry.scriptId);\n      if (source)\n        coverage.entries.push({ ...entry, source });\n      else\n        coverage.entries.push(entry);\n    }\n    return coverage;\n  }\n}\n\nclass CSSCoverage {\n  _client: CRSession;\n  _enabled: boolean;\n  _stylesheetURLs: Map<string, string>;\n  _stylesheetSources: Map<string, string>;\n  _eventListeners: RegisteredListener[];\n  _resetOnNavigation: boolean;\n\n  constructor(client: CRSession) {\n    this._client = client;\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  async start(options: channels.PageStartCSSCoverageParams) {\n    assert(!this._enabled, 'CSSCoverage is already enabled');\n    const { resetOnNavigation = true } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._enabled = true;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n    this._eventListeners = [\n      eventsHelper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),\n      eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('DOM.enable'),\n      this._client.send('CSS.enable'),\n      this._client.send('CSS.startRuleUsageTracking'),\n    ]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n  }\n\n  async _onStyleSheet(event: Protocol.CSS.styleSheetAddedPayload) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL)\n      return;\n    // This might fail if the page has already navigated away.\n    const response = await this._client._sendMayFail('CSS.getStyleSheetText', { styleSheetId: header.styleSheetId });\n    if (response) {\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    }\n  }\n\n  async stop(): Promise<channels.PageStopCSSCoverageResult> {\n    if (!this._enabled)\n      return { entries: [] };\n    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([\n      this._client.send('CSS.disable'),\n      this._client.send('DOM.disable'),\n    ]);\n    eventsHelper.removeEventListeners(this._eventListeners);\n    this._enabled = false;\n\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0,\n      });\n    }\n\n    const coverage: channels.PageStopCSSCoverageResult = { entries: [] };\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId)!;\n      const text = this._stylesheetSources.get(styleSheetId)!;\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.entries.push({ url, ranges, text });\n    }\n\n    return coverage;\n  }\n}\n\nfunction convertToDisjointRanges(nestedRanges: {\n  startOffset: number;\n  endOffset: number;\n  count: number; }[]): { start: number; end: number; }[] {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({ offset: range.startOffset, type: 0, range });\n    points.push({ offset: range.endOffset, type: 1, range });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset)\n      return a.offset - b.offset;\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type)\n      return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0)\n      return bLength - aLength;\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n\n  const hitCountStack = [];\n  const results: { start: number; end: number; }[] = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset)\n        lastResult.end = point.offset;\n      else\n        results.push({ start: lastOffset, end: point.offset });\n    }\n    lastOffset = point.offset;\n    if (point.type === 0)\n      hitCountStack.push(point.range.count);\n    else\n      hitCountStack.pop();\n  }\n  // Filter out empty ranges.\n  return results.filter(range => range.end - range.start > 1);\n}\n"],
  "mappings": "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",
  "names": []
}

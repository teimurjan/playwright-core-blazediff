{
  "version": 3,
  "sources": ["../../src/server/dom.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\n\nimport * as js from './javascript';\nimport { isUnderTest } from '../utils';\nimport { prepareFilesForUpload } from './fileUploadUtils';\nimport * as rawInjectedScriptSource from '../generated/injectedScriptSource';\n\nimport type * as frames from './frames';\nimport type { ElementState, HitTargetInterceptionResult, InjectedScript, InjectedScriptOptions } from '@injected/injectedScript';\nimport type { Page } from './page';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\n\nexport type InputFilesItems = {\n  filePayloads?: types.FilePayload[],\n  localPaths?: string[]\n  localDirectory?: string\n};\n\ntype ActionName = 'click' | 'hover' | 'dblclick' | 'tap' | 'move and up' | 'move and down';\ntype PerformActionResult = 'error:notvisible' | 'error:notconnected' | 'error:notinviewport' | 'error:optionsnotfound' | 'error:optionnotenabled' | { missingState: ElementState } | { hitTargetDescription: string } | 'done';\n\nexport class NonRecoverableDOMError extends Error {\n}\n\nexport function isNonRecoverableDOMError(error: Error) {\n  return error instanceof NonRecoverableDOMError;\n}\n\nexport class FrameExecutionContext extends js.ExecutionContext {\n  readonly frame: frames.Frame;\n  private _injectedScriptPromise?: Promise<js.JSHandle>;\n  readonly world: types.World | null;\n\n  constructor(delegate: js.ExecutionContextDelegate, frame: frames.Frame, world: types.World|null) {\n    super(frame, delegate, world || 'content-script');\n    this.frame = frame;\n    this.world = world;\n  }\n\n  override adoptIfNeeded(handle: js.JSHandle): Promise<js.JSHandle> | null {\n    if (handle instanceof ElementHandle && handle._context !== this)\n      return this.frame._page.delegate.adoptElementHandle(handle, this);\n    return null;\n  }\n\n  async evaluate<Arg, R>(pageFunction: js.Func1<Arg, R>, arg?: Arg): Promise<R> {\n    return js.evaluate(this, true /* returnByValue */, pageFunction, arg);\n  }\n\n  async evaluateHandle<Arg, R>(pageFunction: js.Func1<Arg, R>, arg?: Arg): Promise<js.SmartHandle<R>> {\n    return js.evaluate(this, false /* returnByValue */, pageFunction, arg);\n  }\n\n  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg?: any): Promise<any> {\n    return js.evaluateExpression(this, expression, { ...options, returnByValue: true }, arg);\n  }\n\n  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg?: any): Promise<js.JSHandle<any>> {\n    return js.evaluateExpression(this, expression, { ...options, returnByValue: false }, arg);\n  }\n\n  injectedScript(): Promise<js.JSHandle<InjectedScript>> {\n    if (!this._injectedScriptPromise) {\n      const customEngines: InjectedScriptOptions['customEngines'] = [];\n      const selectorsRegistry = this.frame._page.browserContext.selectors();\n      for (const [name, { source }] of selectorsRegistry._engines)\n        customEngines.push({ name, source: `(${source})` });\n      const sdkLanguage = this.frame._page.browserContext._browser.sdkLanguage();\n      const options: InjectedScriptOptions = {\n        isUnderTest: isUnderTest(),\n        sdkLanguage,\n        testIdAttributeName: selectorsRegistry.testIdAttributeName(),\n        stableRafCount: this.frame._page.delegate.rafCountForStablePosition(),\n        browserName: this.frame._page.browserContext._browser.options.name,\n        customEngines,\n      };\n      const source = `\n        (() => {\n        const module = {};\n        ${rawInjectedScriptSource.source}\n        return new (module.exports.InjectedScript())(globalThis, ${JSON.stringify(options)});\n        })();\n      `;\n      this._injectedScriptPromise = this.rawEvaluateHandle(source)\n          .then(handle => {\n            handle._setPreview('InjectedScript');\n            return handle;\n          });\n    }\n    return this._injectedScriptPromise;\n  }\n}\n\nexport class ElementHandle<T extends Node = Node> extends js.JSHandle<T> {\n  __elementhandle: T = true as any;\n  declare readonly _context: FrameExecutionContext;\n  readonly _page: Page;\n  declare readonly _objectId: string;\n  readonly _frame: frames.Frame;\n\n  constructor(context: FrameExecutionContext, objectId: string) {\n    super(context, 'node', undefined, objectId);\n    this._page = context.frame._page;\n    this._frame = context.frame;\n    this._initializePreview().catch(e => {});\n  }\n\n  async _initializePreview() {\n    const utility = await this._context.injectedScript();\n    this._setPreview(await utility.evaluate((injected, e) => 'JSHandle@' + injected.previewNode(e), this));\n  }\n\n  override asElement(): ElementHandle<T> | null {\n    return this;\n  }\n\n  async evaluateInUtility<R, Arg>(pageFunction: js.Func1<[js.JSHandle<InjectedScript>, ElementHandle<T>, Arg], R>, arg: Arg): Promise<R | 'error:notconnected'> {\n    try {\n      const utility = await this._frame._utilityContext();\n      return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);\n    } catch (e) {\n      if (this._frame.isNonRetriableError(e))\n        throw e;\n      return 'error:notconnected';\n    }\n  }\n\n  async evaluateHandleInUtility<R, Arg>(pageFunction: js.Func1<[js.JSHandle<InjectedScript>, ElementHandle<T>, Arg], R>, arg: Arg): Promise<js.JSHandle<R> | 'error:notconnected'> {\n    try {\n      const utility = await this._frame._utilityContext();\n      return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);\n    } catch (e) {\n      if (this._frame.isNonRetriableError(e))\n        throw e;\n      return 'error:notconnected';\n    }\n  }\n\n  async ownerFrame(): Promise<frames.Frame | null> {\n    const frameId = await this._page.delegate.getOwnerFrame(this);\n    if (!frameId)\n      return null;\n    const frame = this._page.frameManager.frame(frameId);\n    if (frame)\n      return frame;\n    for (const page of this._page.browserContext.pages()) {\n      const frame = page.frameManager.frame(frameId);\n      if (frame)\n        return frame;\n    }\n    return null;\n  }\n\n  async isIframeElement(): Promise<boolean | 'error:notconnected'> {\n    return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});\n  }\n\n  async contentFrame(): Promise<frames.Frame | null> {\n    const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());\n    if (!isFrameElement)\n      return null;\n    return this._page.delegate.getContentFrame(this);\n  }\n\n  async getAttribute(progress: Progress, name: string): Promise<string | null> {\n    return this._frame.getAttribute(progress, ':scope', name, {}, this);\n  }\n\n  async inputValue(progress: Progress): Promise<string> {\n    return this._frame.inputValue(progress, ':scope', {}, this);\n  }\n\n  async textContent(progress: Progress): Promise<string | null> {\n    return this._frame.textContent(progress, ':scope', {}, this);\n  }\n\n  async innerText(progress: Progress): Promise<string> {\n    return this._frame.innerText(progress, ':scope', {}, this);\n  }\n\n  async innerHTML(progress: Progress): Promise<string> {\n    return this._frame.innerHTML(progress, ':scope', {}, this);\n  }\n\n  async dispatchEvent(progress: Progress, type: string, eventInit: Object = {}) {\n    return this._frame.dispatchEvent(progress, ':scope', type, eventInit, {}, this);\n  }\n\n  async _scrollRectIntoViewIfNeeded(progress: Progress, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'> {\n    return await progress.race(this._page.delegate.scrollRectIntoViewIfNeeded(this, rect));\n  }\n\n  async _waitAndScrollIntoViewIfNeeded(progress: Progress, waitForVisible: boolean): Promise<void> {\n    const result = await this._retryAction(progress, 'scroll into view', async () => {\n      progress.log(`  waiting for element to be stable`);\n      const waitResult = await progress.race(this.evaluateInUtility(async ([injected, node, { waitForVisible }]) => {\n        return await injected.checkElementStates(node, waitForVisible ? ['visible', 'stable'] : ['stable']);\n      }, { waitForVisible }));\n      if (waitResult)\n        return waitResult;\n      return await this._scrollRectIntoViewIfNeeded(progress);\n    }, {});\n    assertDone(throwRetargetableDOMError(result));\n  }\n\n  async scrollIntoViewIfNeeded(progress: Progress) {\n    await this._waitAndScrollIntoViewIfNeeded(progress, false /* waitForVisible */);\n  }\n\n  private async _clickablePoint(): Promise<types.Point | 'error:notvisible' | 'error:notinviewport' | 'error:notconnected'> {\n    const intersectQuadWithViewport = (quad: types.Quad): types.Quad => {\n      return quad.map(point => ({\n        x: Math.min(Math.max(point.x, 0), metrics.width),\n        y: Math.min(Math.max(point.y, 0), metrics.height),\n      })) as types.Quad;\n    };\n\n    const computeQuadArea = (quad: types.Quad) => {\n      // Compute sum of all directed areas of adjacent triangles\n      // https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n      let area = 0;\n      for (let i = 0; i < quad.length; ++i) {\n        const p1 = quad[i];\n        const p2 = quad[(i + 1) % quad.length];\n        area += (p1.x * p2.y - p2.x * p1.y) / 2;\n      }\n      return Math.abs(area);\n    };\n\n    const [quads, metrics] = await Promise.all([\n      this._page.delegate.getContentQuads(this),\n      this._page.mainFrame()._utilityContext().then(utility => utility.evaluate(() => ({ width: innerWidth, height: innerHeight }))),\n    ] as const);\n    if (quads === 'error:notconnected')\n      return quads;\n    if (!quads || !quads.length)\n      return 'error:notvisible';\n\n    // Allow 1x1 elements. Compensate for rounding errors by comparing with 0.99 instead.\n    const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 0.99);\n    if (!filtered.length)\n      return 'error:notinviewport';\n    if (this._page.browserContext._browser.options.name === 'firefox') {\n      // Firefox internally uses integer coordinates, so 8.x is converted to 8 or 9 when clicking.\n      //\n      // This does not work nicely for small elements. For example, 1x1 square with corners\n      // (8;8) and (9;9) is targeted when clicking at (8;8) but not when clicking at (9;9).\n      // So, clicking at (8.x;8.y) will sometimes click at (9;9) and miss the target.\n      //\n      // Therefore, we try to find an integer point within a quad to make sure we click inside the element.\n      for (const quad of filtered) {\n        const integerPoint = findIntegerPointInsideQuad(quad);\n        if (integerPoint)\n          return integerPoint;\n      }\n    }\n    // Return the middle point of the first quad.\n    return quadMiddlePoint(filtered[0]);\n  }\n\n  private async _offsetPoint(offset: types.Point): Promise<types.Point | 'error:notvisible' | 'error:notconnected'> {\n    const [box, border] = await Promise.all([\n      this.boundingBox(),\n      this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(e => {}),\n    ]);\n    if (!box || !border)\n      return 'error:notvisible';\n    if (border === 'error:notconnected')\n      return border;\n    // Make point relative to the padding box to align with offsetX/offsetY.\n    return {\n      x: box.x + border.left + offset.x,\n      y: box.y + border.top + offset.y,\n    };\n  }\n\n  async _retryAction(progress: Progress, actionName: string, action: (retry: number) => Promise<PerformActionResult>, options: { trial?: boolean, force?: boolean, skipActionPreChecks?: boolean }): Promise<'error:notconnected' | 'done'> {\n    let retry = 0;\n    // We progressively wait longer between retries, up to 500ms.\n    const waitTime = [0, 20, 100, 100, 500];\n\n    while (true) {\n      if (retry) {\n        progress.log(`retrying ${actionName} action${options.trial ? ' (trial run)' : ''}`);\n        const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];\n        if (timeout) {\n          progress.log(`  waiting ${timeout}ms`);\n          const result = await progress.race(this.evaluateInUtility(([injected, node, timeout]) => new Promise<void>(f => setTimeout(f, timeout)), timeout));\n          if (result === 'error:notconnected')\n            return result;\n        }\n      } else {\n        progress.log(`attempting ${actionName} action${options.trial ? ' (trial run)' : ''}`);\n      }\n      if (!options.skipActionPreChecks && !options.force)\n        await this._frame._page.performActionPreChecks(progress);\n      const result = await action(retry);\n      ++retry;\n      if (result === 'error:notvisible') {\n        if (options.force)\n          throw new NonRecoverableDOMError('Element is not visible');\n        progress.log('  element is not visible');\n        continue;\n      }\n      if (result === 'error:notinviewport') {\n        if (options.force)\n          throw new NonRecoverableDOMError('Element is outside of the viewport');\n        progress.log('  element is outside of the viewport');\n        continue;\n      }\n      if (result === 'error:optionsnotfound') {\n        progress.log('  did not find some options');\n        continue;\n      }\n      if (result === 'error:optionnotenabled') {\n        progress.log('  option being selected is not enabled');\n        continue;\n      }\n      if (typeof result === 'object' && 'hitTargetDescription' in result) {\n        progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);\n        continue;\n      }\n      if (typeof result === 'object' && 'missingState' in result) {\n        progress.log(`  element is not ${result.missingState}`);\n        continue;\n      }\n      return result;\n    }\n  }\n\n  async _retryPointerAction(progress: Progress, actionName: ActionName, waitForEnabled: boolean, action: (point: types.Point) => Promise<void>,\n    options: { waitAfter: boolean | 'disabled' } & types.PointerActionOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    // Note: do not perform locator handlers checkpoint to avoid moving the mouse in the middle of a drag operation.\n    const skipActionPreChecks = actionName === 'move and up';\n    return await this._retryAction(progress, actionName, async retry => {\n      // By default, we scroll with protocol method to reveal the action point.\n      // However, that might not work to scroll from under position:sticky elements\n      // that overlay the target element. To fight this, we cycle through different\n      // scroll alignments. This works in most scenarios.\n      const scrollOptions: (ScrollIntoViewOptions | undefined)[] = [\n        undefined,\n        { block: 'end', inline: 'end' },\n        { block: 'center', inline: 'center' },\n        { block: 'start', inline: 'start' },\n      ];\n      const forceScrollOptions = scrollOptions[retry % scrollOptions.length];\n      return await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);\n    }, { ...options, skipActionPreChecks });\n  }\n\n  async _performPointerAction(\n    progress: Progress,\n    actionName: ActionName,\n    waitForEnabled: boolean,\n    action: (point: types.Point) => Promise<void>,\n    forceScrollOptions: ScrollIntoViewOptions | undefined,\n    options: { waitAfter: boolean | 'disabled' } & types.PointerActionOptions & types.PointerActionWaitOptions,\n  ): Promise<PerformActionResult> {\n    const { force = false, position } = options;\n\n    const doScrollIntoView = async () => {\n      if (forceScrollOptions) {\n        return await this.evaluateInUtility(([injected, node, options]) => {\n          if (node.nodeType === 1 /* Node.ELEMENT_NODE */)\n            (node as Node as Element).scrollIntoView(options);\n          return 'done' as const;\n        }, forceScrollOptions);\n      }\n      return await this._scrollRectIntoViewIfNeeded(progress, position ? { x: position.x, y: position.y, width: 0, height: 0 } : undefined);\n    };\n\n    if (this._frame.parentFrame()) {\n      // Best-effort scroll to make sure any iframes containing this element are scrolled\n      // into view and visible, so they are not throttled.\n      // See https://github.com/microsoft/playwright/issues/27196 for an example.\n      await progress.race(doScrollIntoView().catch(() => {}));\n    }\n\n    if ((options as any).__testHookBeforeStable)\n      await progress.race((options as any).__testHookBeforeStable());\n\n    if (!force) {\n      const elementStates: ElementState[] = waitForEnabled ? ['visible', 'enabled', 'stable'] : ['visible', 'stable'];\n      progress.log(`  waiting for element to be ${waitForEnabled ? 'visible, enabled and stable' : 'visible and stable'}`);\n      const result = await progress.race(this.evaluateInUtility(async ([injected, node, { elementStates }]) => {\n        return await injected.checkElementStates(node, elementStates);\n      }, { elementStates }));\n      if (result)\n        return result;\n      progress.log(`  element is ${waitForEnabled ? 'visible, enabled and stable' : 'visible and stable'}`);\n    }\n\n    if ((options as any).__testHookAfterStable)\n      await progress.race((options as any).__testHookAfterStable());\n\n    progress.log('  scrolling into view if needed');\n    const scrolled = await progress.race(doScrollIntoView());\n    if (scrolled !== 'done')\n      return scrolled;\n    progress.log('  done scrolling');\n\n    const maybePoint = position ? await progress.race(this._offsetPoint(position)) : await progress.race(this._clickablePoint());\n    if (typeof maybePoint === 'string')\n      return maybePoint;\n    const point = roundPoint(maybePoint);\n    progress.metadata.point = point;\n    await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n\n    let hitTargetInterceptionHandle: js.JSHandle<HitTargetInterceptionResult> | undefined;\n    if (force) {\n      progress.log(`  forcing action`);\n    } else {\n      if ((options as any).__testHookBeforeHitTarget)\n        await progress.race((options as any).__testHookBeforeHitTarget());\n\n      const frameCheckResult = await progress.race(this._checkFrameIsHitTarget(point));\n      if (frameCheckResult === 'error:notconnected' || ('hitTargetDescription' in frameCheckResult))\n        return frameCheckResult;\n      const hitPoint = frameCheckResult.framePoint;\n      const actionType = actionName === 'move and up' ? 'drag' : ((actionName === 'hover' || actionName === 'tap') ? actionName : 'mouse');\n      const handle = await progress.race(this.evaluateHandleInUtility(([injected, node, { actionType, hitPoint, trial }]) => injected.setupHitTargetInterceptor(node, actionType, hitPoint, trial), { actionType, hitPoint, trial: !!options.trial } as const));\n      if (handle === 'error:notconnected')\n        return handle;\n      if (!handle._objectId) {\n        const error = handle.rawValue() as string;\n        if (error === 'error:notconnected')\n          return error;\n        return { hitTargetDescription: error };\n      }\n      hitTargetInterceptionHandle = handle as any;\n    }\n\n    const actionResult = await this._page.frameManager.waitForSignalsCreatedBy(progress, options.waitAfter === true, async () => {\n      if ((options as any).__testHookBeforePointerAction)\n        await progress.race((options as any).__testHookBeforePointerAction());\n      let restoreModifiers: types.KeyboardModifier[] | undefined;\n      if (options && options.modifiers)\n        restoreModifiers = await this._page.keyboard.ensureModifiers(progress, options.modifiers);\n      progress.log(`  performing ${actionName} action`);\n      await action(point);\n      if (restoreModifiers)\n        await this._page.keyboard.ensureModifiers(progress, restoreModifiers);\n      if (hitTargetInterceptionHandle) {\n        const stopHitTargetInterception = this._frame.raceAgainstEvaluationStallingEvents(() => {\n          return hitTargetInterceptionHandle.evaluate(h => h.stop());\n        }).catch(e => 'done' as const).finally(() => {\n          hitTargetInterceptionHandle?.dispose();\n        });\n        if (options.waitAfter !== false) {\n          // When noWaitAfter is passed, we do not want to accidentally stall on\n          // non-committed navigation blocking the evaluate.\n          const hitTargetResult = await progress.race(stopHitTargetInterception);\n          if (hitTargetResult !== 'done')\n            return hitTargetResult;\n        }\n      }\n      progress.log(`  ${options.trial ? 'trial ' : ''}${actionName} action done`);\n      progress.log('  waiting for scheduled navigations to finish');\n      if ((options as any).__testHookAfterPointerAction)\n        await progress.race((options as any).__testHookAfterPointerAction());\n      return 'done';\n    }).finally(() => {\n      // Do not await here, just in case the renderer is stuck (e.g. on alert)\n      // and we won't be able to cleanup.\n      const stopPromise = hitTargetInterceptionHandle?.evaluate(h => h.stop()).catch(() => {});\n      stopPromise?.then(() => hitTargetInterceptionHandle?.dispose());\n    });\n    if (actionResult !== 'done')\n      return actionResult;\n    progress.log('  navigations have finished');\n    return 'done';\n  }\n\n  private async _markAsTargetElement(progress: Progress) {\n    if (!progress.metadata.id)\n      return;\n    await progress.race(this.evaluateInUtility(([injected, node, callId]) => {\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */)\n        injected.markTargetElements(new Set([node as Node as Element]), callId);\n    }, progress.metadata.id));\n  }\n\n  async hover(progress: Progress, options: types.PointerActionOptions & types.PointerActionWaitOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._hover(progress, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  _hover(progress: Progress, options: types.PointerActionOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    return this._retryPointerAction(progress, 'hover', false /* waitForEnabled */, point => this._page.mouse.move(progress, point.x, point.y), { ...options, waitAfter: 'disabled' });\n  }\n\n  async click(progress: Progress, options: { noWaitAfter?: boolean } & types.MouseClickOptions & types.PointerActionWaitOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._click(progress, { ...options, waitAfter: !options.noWaitAfter });\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  _click(progress: Progress, options: { waitAfter: boolean | 'disabled' } & types.MouseClickOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    return this._retryPointerAction(progress, 'click', true /* waitForEnabled */, point => this._page.mouse.click(progress, point.x, point.y, options), options);\n  }\n\n  async dblclick(progress: Progress, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._dblclick(progress, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  _dblclick(progress: Progress, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    return this._retryPointerAction(progress, 'dblclick', true /* waitForEnabled */, point => this._page.mouse.click(progress, point.x, point.y, { ...options, clickCount: 2 }), { ...options, waitAfter: 'disabled' });\n  }\n\n  async tap(progress: Progress, options: types.PointerActionWaitOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._tap(progress, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  _tap(progress: Progress, options: types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    return this._retryPointerAction(progress, 'tap', true /* waitForEnabled */, point => this._page.touchscreen.tap(progress, point.x, point.y), { ...options, waitAfter: 'disabled' });\n  }\n\n  async selectOption(progress: Progress, elements: ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[]> {\n    await this._markAsTargetElement(progress);\n    const result = await this._selectOption(progress, elements, values, options);\n    return throwRetargetableDOMError(result);\n  }\n\n  async _selectOption(progress: Progress, elements: ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[] | 'error:notconnected'> {\n    let resultingOptions: string[] = [];\n    const result = await this._retryAction(progress, 'select option', async () => {\n      await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n      if (!options.force)\n        progress.log(`  waiting for element to be visible and enabled`);\n      const optionsToSelect = [...elements, ...values];\n      const result = await progress.race(this.evaluateInUtility(async ([injected, node, { optionsToSelect, force }]) => {\n        if (!force) {\n          const checkResult = await injected.checkElementStates(node, ['visible', 'enabled']);\n          if (checkResult)\n            return checkResult;\n        }\n        return injected.selectOptions(node, optionsToSelect);\n      }, { optionsToSelect, force: options.force }));\n      if (Array.isArray(result)) {\n        progress.log('  selected specified option(s)');\n        resultingOptions = result;\n        return 'done';\n      }\n      return result;\n    }, options);\n    if (result === 'error:notconnected')\n      return result;\n    return resultingOptions;\n  }\n\n  async fill(progress: Progress, value: string, options: types.CommonActionOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._fill(progress, value, options);\n    assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _fill(progress: Progress, value: string, options: types.CommonActionOptions): Promise<'error:notconnected' | 'done'> {\n    progress.log(`  fill(\"${value}\")`);\n    return await this._retryAction(progress, 'fill', async () => {\n      await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n      if (!options.force)\n        progress.log('  waiting for element to be visible, enabled and editable');\n      const result = await progress.race(this.evaluateInUtility(async ([injected, node, { value, force }]) => {\n        if (!force) {\n          const checkResult = await injected.checkElementStates(node, ['visible', 'enabled', 'editable']);\n          if (checkResult)\n            return checkResult;\n        }\n        return injected.fill(node, value);\n      }, { value, force: options.force }));\n      if (result === 'needsinput') {\n        if (value)\n          await this._page.keyboard.insertText(progress, value);\n        else\n          await this._page.keyboard.press(progress, 'Delete');\n        return 'done';\n      } else {\n        return result;\n      }\n    }, options);\n  }\n\n  async selectText(progress: Progress, options: types.CommonActionOptions): Promise<void> {\n    const result = await this._retryAction(progress, 'selectText', async () => {\n      if (!options.force)\n        progress.log('  waiting for element to be visible');\n      return await progress.race(this.evaluateInUtility(async ([injected, node, { force }]) => {\n        if (!force) {\n          const checkResult = await injected.checkElementStates(node, ['visible']);\n          if (checkResult)\n            return checkResult;\n        }\n        return injected.selectText(node);\n      }, { force: options.force }));\n    }, options);\n    assertDone(throwRetargetableDOMError(result));\n  }\n\n  async setInputFiles(progress: Progress, params: Omit<channels.ElementHandleSetInputFilesParams, 'timeout'>) {\n    const inputFileItems = await progress.race(prepareFilesForUpload(this._frame, params));\n    await this._markAsTargetElement(progress);\n    const result = await this._setInputFiles(progress, inputFileItems);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _setInputFiles(progress: Progress, items: InputFilesItems): Promise<'error:notconnected' | 'done'> {\n    const { filePayloads, localPaths, localDirectory } = items;\n    const multiple = filePayloads && filePayloads.length > 1 || localPaths && localPaths.length > 1;\n    const result = await progress.race(this.evaluateHandleInUtility(([injected, node, { multiple, directoryUpload }]): Element | undefined => {\n      const element = injected.retarget(node, 'follow-label');\n      if (!element)\n        return;\n      if (element.tagName !== 'INPUT')\n        throw injected.createStacklessError('Node is not an HTMLInputElement');\n      const inputElement = element as HTMLInputElement;\n      if (multiple && !inputElement.multiple && !inputElement.webkitdirectory)\n        throw injected.createStacklessError('Non-multiple file input can only accept single file');\n      if (directoryUpload && !inputElement.webkitdirectory)\n        throw injected.createStacklessError('File input does not support directories, pass individual files instead');\n      if (!directoryUpload && inputElement.webkitdirectory)\n        throw injected.createStacklessError('[webkitdirectory] input requires passing a path to a directory');\n      return inputElement;\n    }, { multiple, directoryUpload: !!localDirectory }));\n    if (result === 'error:notconnected' || !result.asElement())\n      return 'error:notconnected';\n    const retargeted = result.asElement() as ElementHandle<HTMLInputElement>;\n    await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n    if (localPaths || localDirectory) {\n      const localPathsOrDirectory = localDirectory ? [localDirectory] : localPaths!;\n      await progress.race(Promise.all((localPathsOrDirectory).map(localPath => (\n        fs.promises.access(localPath, fs.constants.F_OK)\n      ))));\n      // Browsers traverse the given directory asynchronously and we want to ensure all files are uploaded.\n      const waitForInputEvent = localDirectory ? this.evaluate(node => new Promise<any>(fulfill => {\n        node.addEventListener('input', fulfill, { once: true });\n      })).catch(() => {}) : Promise.resolve();\n      await progress.race(this._page.delegate.setInputFilePaths(retargeted, localPathsOrDirectory));\n      await progress.race(waitForInputEvent);\n    } else {\n      await progress.race(retargeted.evaluateInUtility(([injected, node, files]) =>\n        injected.setInputFiles(node, files), filePayloads!));\n    }\n    return 'done';\n  }\n\n  async focus(progress: Progress): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._focus(progress);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _focus(progress: Progress, resetSelectionIfNotFocused?: boolean): Promise<'error:notconnected' | 'done'> {\n    return await progress.race(this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused]) => injected.focusNode(node, resetSelectionIfNotFocused), resetSelectionIfNotFocused));\n  }\n\n  async _blur(progress: Progress): Promise<'error:notconnected' | 'done'> {\n    return await progress.race(this.evaluateInUtility(([injected, node]) => injected.blurNode(node), {}));\n  }\n\n  async type(progress: Progress, text: string, options: { delay?: number } & types.StrictOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._type(progress, text, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _type(progress: Progress, text: string, options: { delay?: number } & types.StrictOptions): Promise<'error:notconnected' | 'done'> {\n    progress.log(`elementHandle.type(\"${text}\")`);\n    await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n    const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);\n    if (result !== 'done')\n      return result;\n    await this._page.keyboard.type(progress, text, options);\n    return 'done';\n  }\n\n  async press(progress: Progress, key: string, options: { delay?: number, noWaitAfter?: boolean } & types.StrictOptions): Promise<void> {\n    await this._markAsTargetElement(progress);\n    const result = await this._press(progress, key, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _press(progress: Progress, key: string, options: { delay?: number, noWaitAfter?: boolean } & types.StrictOptions): Promise<'error:notconnected' | 'done'> {\n    progress.log(`elementHandle.press(\"${key}\")`);\n    await progress.race(this.instrumentation.onBeforeInputAction(this, progress.metadata));\n    return this._page.frameManager.waitForSignalsCreatedBy(progress, !options.noWaitAfter, async () => {\n      const result = await this._focus(progress, true /* resetSelectionIfNotFocused */);\n      if (result !== 'done')\n        return result;\n      await this._page.keyboard.press(progress, key, options);\n      return 'done';\n    });\n  }\n\n  async check(progress: Progress, options: { position?: types.Point } & types.PointerActionWaitOptions) {\n    const result = await this._setChecked(progress, true, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async uncheck(progress: Progress, options: { position?: types.Point } & types.PointerActionWaitOptions) {\n    const result = await this._setChecked(progress, false, options);\n    return assertDone(throwRetargetableDOMError(result));\n  }\n\n  async _setChecked(progress: Progress, state: boolean, options: { position?: types.Point } & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'> {\n    const isChecked = async () => {\n      const result = await progress.race(this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'checked'), {}));\n      if (result === 'error:notconnected' || result.received === 'error:notconnected')\n        throwElementIsNotAttached();\n      return { matches: result.matches, isRadio: result.isRadio };\n    };\n    await this._markAsTargetElement(progress);\n    const checkedState = await isChecked();\n    if (checkedState.matches === state)\n      return 'done';\n    if (!state && checkedState.isRadio)\n      throw new NonRecoverableDOMError('Cannot uncheck radio button. Radio buttons can only be unchecked by selecting another radio button in the same group.');\n    const result = await this._click(progress, { ...options, waitAfter: 'disabled' });\n    if (result !== 'done')\n      return result;\n    if (options.trial)\n      return 'done';\n    const finalState = await isChecked();\n    if (finalState.matches !== state)\n      throw new NonRecoverableDOMError('Clicking the checkbox did not change its state');\n    return 'done';\n  }\n\n  async boundingBox(): Promise<types.Rect | null> {\n    return this._page.delegate.getBoundingBox(this);\n  }\n\n  async ariaSnapshot(): Promise<string> {\n    return await this.evaluateInUtility(([injected, element]) => injected.ariaSnapshot(element, { mode: 'expect' }), {});\n  }\n\n  async screenshot(progress: Progress, options: ScreenshotOptions): Promise<Buffer> {\n    return await this._page.screenshotter.screenshotElement(progress, this, options);\n  }\n\n  async querySelector(selector: string, options: types.StrictOptions): Promise<ElementHandle | null> {\n    return this._frame.selectors.query(selector, options, this);\n  }\n\n  async querySelectorAll(selector: string): Promise<ElementHandle<Element>[]> {\n    return this._frame.selectors.queryAll(selector, this);\n  }\n\n  async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {\n    return this._frame.evalOnSelector(selector, strict, expression, isFunction, arg, this);\n  }\n\n  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {\n    return this._frame.evalOnSelectorAll(selector, expression, isFunction, arg, this);\n  }\n\n  async isVisible(progress: Progress): Promise<boolean> {\n    return this._frame.isVisible(progress, ':scope', {}, this);\n  }\n\n  async isHidden(progress: Progress): Promise<boolean> {\n    return this._frame.isHidden(progress, ':scope', {}, this);\n  }\n\n  async isEnabled(progress: Progress): Promise<boolean> {\n    return this._frame.isEnabled(progress, ':scope', {}, this);\n  }\n\n  async isDisabled(progress: Progress): Promise<boolean> {\n    return this._frame.isDisabled(progress, ':scope', {}, this);\n  }\n\n  async isEditable(progress: Progress): Promise<boolean> {\n    return this._frame.isEditable(progress, ':scope', {}, this);\n  }\n\n  async isChecked(progress: Progress): Promise<boolean> {\n    return this._frame.isChecked(progress, ':scope', {}, this);\n  }\n\n  async waitForElementState(progress: Progress, state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled' | 'editable'): Promise<void> {\n    const actionName = `wait for ${state}`;\n    const result = await this._retryAction(progress, actionName, async () => {\n      return await progress.race(this.evaluateInUtility(async ([injected, node, state]) => {\n        return (await injected.checkElementStates(node, [state])) || 'done';\n      }, state));\n    }, {});\n    assertDone(throwRetargetableDOMError(result));\n  }\n\n  async waitForSelector(progress: Progress, selector: string, options: types.WaitForElementOptions): Promise<ElementHandle<Element> | null> {\n    return await this._frame.waitForSelector(progress, selector, true, options, this);\n  }\n\n  async _adoptTo(context: FrameExecutionContext): Promise<ElementHandle<T>> {\n    if (this._context !== context) {\n      const adopted = await this._page.delegate.adoptElementHandle(this, context);\n      this.dispose();\n      return adopted;\n    }\n    return this;\n  }\n\n  async _checkFrameIsHitTarget(point: types.Point): Promise<{ framePoint: types.Point | undefined } | 'error:notconnected' | { hitTargetDescription: string }> {\n    let frame = this._frame;\n    const data: { frame: frames.Frame, frameElement: ElementHandle<Element> | null, pointInFrame: types.Point }[] = [];\n    while (frame.parentFrame()) {\n      const frameElement = await frame.frameElement() as ElementHandle<Element>;\n      const box = await frameElement.boundingBox();\n      const style = await frameElement.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch(e => 'error:notconnected' as const);\n      if (!box || style === 'error:notconnected')\n        return 'error:notconnected';\n      if (style === 'transformed') {\n        // We cannot translate coordinates when iframe has any transform applied.\n        // The best we can do right now is to skip the hitPoint check,\n        // and solely rely on the event interceptor.\n        return { framePoint: undefined };\n      }\n      // Translate from viewport coordinates to frame coordinates.\n      const pointInFrame = { x: point.x - box.x - style.left, y: point.y - box.y - style.top };\n      data.push({ frame, frameElement, pointInFrame });\n      frame = frame.parentFrame()!;\n    }\n    // Add main frame.\n    data.push({ frame, frameElement: null, pointInFrame: point });\n\n    for (let i = data.length - 1; i > 0; i--) {\n      const element = data[i - 1].frameElement!;\n      const point = data[i].pointInFrame;\n      // Hit target in the parent frame should hit the child frame element.\n      const hitTargetResult = await element.evaluateInUtility(([injected, element, hitPoint]) => {\n        return injected.expectHitTarget(hitPoint, element);\n      }, point);\n      if (hitTargetResult !== 'done')\n        return hitTargetResult;\n    }\n    return { framePoint: data[0].pointInFrame };\n  }\n}\n\nexport function throwRetargetableDOMError<T>(result: T | 'error:notconnected'): T {\n  if (result === 'error:notconnected')\n    throwElementIsNotAttached();\n  return result;\n}\n\nexport function throwElementIsNotAttached(): never {\n  throw new Error('Element is not attached to the DOM');\n}\n\nexport function assertDone(result: 'done'): void {\n  // This function converts 'done' to void and ensures typescript catches unhandled errors.\n}\n\nfunction roundPoint(point: types.Point): types.Point {\n  return {\n    x: (point.x * 100 | 0) / 100,\n    y: (point.y * 100 | 0) / 100,\n  };\n}\n\nfunction quadMiddlePoint(quad: types.Quad): types.Point {\n  const result = { x: 0, y: 0 };\n  for (const point of quad) {\n    result.x += point.x / 4;\n    result.y += point.y / 4;\n  }\n  return result;\n}\n\nfunction triangleArea(p1: types.Point, p2: types.Point, p3: types.Point): number {\n  return Math.abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2;\n}\n\nfunction isPointInsideQuad(point: types.Point, quad: types.Quad): boolean {\n  const area1 = triangleArea(point, quad[0], quad[1]) + triangleArea(point, quad[1], quad[2]) + triangleArea(point, quad[2], quad[3]) + triangleArea(point, quad[3], quad[0]);\n  const area2 = triangleArea(quad[0], quad[1], quad[2]) + triangleArea(quad[1], quad[2], quad[3]);\n  // Check that point is inside the quad.\n  if (Math.abs(area1 - area2) > 0.1)\n    return false;\n  // Check that point is not on the right/bottom edge, because clicking\n  // there does not actually click the element.\n  return point.x < Math.max(quad[0].x, quad[1].x, quad[2].x, quad[3].x) &&\n         point.y < Math.max(quad[0].y, quad[1].y, quad[2].y, quad[3].y);\n}\n\nfunction findIntegerPointInsideQuad(quad: types.Quad): types.Point | undefined {\n  // Try all four rounding directions of the middle point.\n  const point = quadMiddlePoint(quad);\n  point.x = Math.floor(point.x);\n  point.y = Math.floor(point.y);\n  if (isPointInsideQuad(point, quad))\n    return point;\n  point.x += 1;\n  if (isPointInsideQuad(point, quad))\n    return point;\n  point.y += 1;\n  if (isPointInsideQuad(point, quad))\n    return point;\n  point.x -= 1;\n  if (isPointInsideQuad(point, quad))\n    return point;\n}\n\nexport const kUnableToAdoptErrorMessage = 'Unable to adopt element handle from a different document';\n"],
  "mappings": "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",
  "names": ["source", "frame", "waitForVisible", "result", "timeout", "options", "elementStates", "actionType", "hitPoint", "optionsToSelect", "value", "multiple", "fs", "resetSelectionIfNotFocused", "state", "point", "element"]
}

{
  "version": 3,
  "sources": ["../../../src/server/utils/zipFile.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { yauzl } from '../../zipBundle';\n\nimport type { Entry, UnzipFile } from '../../zipBundle';\n\nexport class ZipFile {\n  private _fileName: string;\n  private _zipFile: UnzipFile | undefined;\n  private _entries = new Map<string, Entry>();\n  private _openedPromise: Promise<void>;\n\n  constructor(fileName: string) {\n    this._fileName = fileName;\n    this._openedPromise = this._open();\n  }\n\n  private async _open() {\n    await new Promise<UnzipFile>((fulfill, reject) => {\n      yauzl.open(this._fileName, { autoClose: false }, (e, z) => {\n        if (e) {\n          reject(e);\n          return;\n        }\n        this._zipFile = z;\n        this._zipFile!.on('entry', (entry: Entry) => {\n          this._entries.set(entry.fileName, entry);\n        });\n        this._zipFile!.on('end', fulfill);\n      });\n    });\n  }\n\n  async entries(): Promise<string[]> {\n    await this._openedPromise;\n    return [...this._entries.keys()];\n  }\n\n  async read(entryPath: string): Promise<Buffer> {\n    await this._openedPromise;\n    const entry = this._entries.get(entryPath)!;\n    if (!entry)\n      throw new Error(`${entryPath} not found in file ${this._fileName}`);\n\n    return new Promise((resolve, reject) => {\n      this._zipFile!.openReadStream(entry, (error, readStream) => {\n        if (error || !readStream) {\n          reject(error || 'Entry not found');\n          return;\n        }\n\n        const buffers: Buffer[] = [];\n        readStream.on('data', data => buffers.push(data));\n        readStream.on('end', () => resolve(Buffer.concat(buffers)));\n      });\n    });\n  }\n\n  close() {\n    this._zipFile?.close();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,uBAAsB;AAIf,MAAM,QAAQ;AAAA,EAMnB,YAAY,UAAkB;AAH9B,SAAQ,WAAW,oBAAI,IAAmB;AAIxC,SAAK,YAAY;AACjB,SAAK,iBAAiB,KAAK,MAAM;AAAA,EACnC;AAAA,EAEA,MAAc,QAAQ;AACpB,UAAM,IAAI,QAAmB,CAAC,SAAS,WAAW;AAChD,6BAAM,KAAK,KAAK,WAAW,EAAE,WAAW,MAAM,GAAG,CAAC,GAAG,MAAM;AACzD,YAAI,GAAG;AACL,iBAAO,CAAC;AACR;AAAA,QACF;AACA,aAAK,WAAW;AAChB,aAAK,SAAU,GAAG,SAAS,CAAC,UAAiB;AAC3C,eAAK,SAAS,IAAI,MAAM,UAAU,KAAK;AAAA,QACzC,CAAC;AACD,aAAK,SAAU,GAAG,OAAO,OAAO;AAAA,MAClC,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAA6B;AACjC,UAAM,KAAK;AACX,WAAO,CAAC,GAAG,KAAK,SAAS,KAAK,CAAC;AAAA,EACjC;AAAA,EAEA,MAAM,KAAK,WAAoC;AAC7C,UAAM,KAAK;AACX,UAAM,QAAQ,KAAK,SAAS,IAAI,SAAS;AACzC,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,GAAG,SAAS,sBAAsB,KAAK,SAAS,EAAE;AAEpE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,WAAK,SAAU,eAAe,OAAO,CAAC,OAAO,eAAe;AAC1D,YAAI,SAAS,CAAC,YAAY;AACxB,iBAAO,SAAS,iBAAiB;AACjC;AAAA,QACF;AAEA,cAAM,UAAoB,CAAC;AAC3B,mBAAW,GAAG,QAAQ,UAAQ,QAAQ,KAAK,IAAI,CAAC;AAChD,mBAAW,GAAG,OAAO,MAAM,QAAQ,OAAO,OAAO,OAAO,CAAC,CAAC;AAAA,MAC5D,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,QAAQ;AACN,SAAK,UAAU,MAAM;AAAA,EACvB;AACF;",
  "names": []
}

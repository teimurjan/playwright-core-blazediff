{
  "version": 3,
  "sources": ["../../../src/server/utils/processLauncher.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as childProcess from 'child_process';\nimport fs from 'fs';\nimport * as readline from 'readline';\n\nimport { removeFolders } from './fileUtils';\nimport { isUnderTest } from '../../utils';\n\nexport type Env = {[key: string]: string | number | boolean | undefined};\n\nexport type LaunchProcessOptions = {\n  command: string,\n  args?: string[],\n  env?: Env,\n  shell?: boolean,\n\n  handleSIGINT?: boolean,\n  handleSIGTERM?: boolean,\n  handleSIGHUP?: boolean,\n  stdio: 'pipe' | 'stdin',\n  tempDirectories: string[],\n\n  cwd?: string,\n\n  // Note: attemptToGracefullyClose should reject if it does not close the browser.\n  attemptToGracefullyClose: () => Promise<any>,\n  onExit: (exitCode: number | null, signal: string | null) => void,\n  log: (message: string) => void,\n};\n\ntype LaunchResult = {\n  launchedProcess: childProcess.ChildProcess,\n  gracefullyClose: () => Promise<void>,\n  kill: () => Promise<void>,\n};\n\nexport const gracefullyCloseSet = new Set<() => Promise<void>>();\nconst killSet = new Set<() => void>();\n\nexport async function gracefullyCloseAll() {\n  await Promise.all(Array.from(gracefullyCloseSet).map(gracefullyClose => gracefullyClose().catch(e => {})));\n}\n\nexport function gracefullyProcessExitDoNotHang(code: number) {\n  // Force exit after 30 seconds.\n  // eslint-disable-next-line no-restricted-properties\n  setTimeout(() => process.exit(code), 30000);\n  // Meanwhile, try to gracefully close all browsers.\n  gracefullyCloseAll().then(() => {\n    // eslint-disable-next-line no-restricted-properties\n    process.exit(code);\n  });\n}\n\nfunction exitHandler() {\n  for (const kill of killSet)\n    kill();\n}\n\nlet sigintHandlerCalled = false;\nfunction sigintHandler() {\n  const exitWithCode130 = () => {\n    // Give tests a chance to see that launched process did exit and dispatch any async calls.\n    if (isUnderTest()) {\n      // eslint-disable-next-line no-restricted-properties\n      setTimeout(() => process.exit(130), 1000);\n    } else {\n      // eslint-disable-next-line no-restricted-properties\n      process.exit(130);\n    }\n  };\n\n  if (sigintHandlerCalled) {\n    // Resort to default handler from this point on, just in case we hang/stall.\n    process.off('SIGINT', sigintHandler);\n\n    // Upon second Ctrl+C, immediately kill browsers and exit.\n    // This prevents hanging in the case where closing the browser takes a lot of time or is buggy.\n    for (const kill of killSet)\n      kill();\n    exitWithCode130();\n  } else {\n    sigintHandlerCalled = true;\n    gracefullyCloseAll().then(() => exitWithCode130());\n  }\n}\n\nfunction sigtermHandler() {\n  gracefullyCloseAll();\n}\n\nfunction sighupHandler() {\n  gracefullyCloseAll();\n}\n\nconst installedHandlers = new Set<'exit' | 'SIGINT' | 'SIGTERM' | 'SIGHUP'>();\nconst processHandlers = {\n  exit: exitHandler,\n  SIGINT: sigintHandler,\n  SIGTERM: sigtermHandler,\n  SIGHUP: sighupHandler,\n};\nfunction addProcessHandlerIfNeeded(name: 'exit' | 'SIGINT' | 'SIGTERM' | 'SIGHUP') {\n  if (!installedHandlers.has(name)) {\n    installedHandlers.add(name);\n    process.on(name, processHandlers[name]);\n  }\n}\nfunction removeProcessHandlersIfNeeded() {\n  if (killSet.size)\n    return;\n  for (const handler of installedHandlers)\n    process.off(handler, processHandlers[handler]);\n  installedHandlers.clear();\n}\n\nexport async function launchProcess(options: LaunchProcessOptions): Promise<LaunchResult> {\n  const stdio: ('ignore' | 'pipe')[] = options.stdio === 'pipe' ? ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'] : ['pipe', 'pipe', 'pipe'];\n  options.log(`<launching> ${options.command} ${options.args ? options.args.join(' ') : ''}`);\n  const spawnOptions: childProcess.SpawnOptions = {\n    // On non-windows platforms, `detached: true` makes child process a leader of a new\n    // process group, making it possible to kill child process tree with `.kill(-pid)` command.\n    // @see https://nodejs.org/api/child_process.html#child_process_options_detached\n    detached: process.platform !== 'win32',\n    env: (options.env as {[key: string]: string}),\n    cwd: options.cwd,\n    shell: options.shell,\n    stdio,\n  };\n  const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);\n\n  const cleanup = async () => {\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);\n    const errors = await removeFolders(options.tempDirectories);\n    for (let i = 0; i < options.tempDirectories.length; ++i) {\n      if (errors[i])\n        options.log(`[pid=${spawnedProcess.pid || 'N/A'}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);\n    }\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);\n  };\n\n  // Prevent Unhandled 'error' event.\n  spawnedProcess.on('error', () => {});\n\n  if (!spawnedProcess.pid) {\n    let failed: (e: Error) => void;\n    const failedPromise = new Promise<Error>((f, r) => failed = f);\n    spawnedProcess.once('error', error => {\n      failed(new Error('Failed to launch: ' + error));\n    });\n    return failedPromise.then(async error => {\n      await cleanup();\n      throw error;\n    });\n  }\n  options.log(`<launched> pid=${spawnedProcess.pid}`);\n\n  const stdout = readline.createInterface({ input: spawnedProcess.stdout! });\n  stdout.on('line', (data: string) => {\n    options.log(`[pid=${spawnedProcess.pid}][out] ` + data);\n  });\n\n  const stderr = readline.createInterface({ input: spawnedProcess.stderr! });\n  stderr.on('line', (data: string) => {\n    options.log(`[pid=${spawnedProcess.pid}][err] ` + data);\n  });\n\n  let processClosed = false;\n  let fulfillCleanup = () => {};\n  const waitForCleanup = new Promise<void>(f => fulfillCleanup = f);\n  spawnedProcess.once('close', (exitCode, signal) => {\n    options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);\n    processClosed = true;\n    gracefullyCloseSet.delete(gracefullyClose);\n    killSet.delete(killProcessAndCleanup);\n    removeProcessHandlersIfNeeded();\n    options.onExit(exitCode, signal);\n    // Cleanup as process exits.\n    cleanup().then(fulfillCleanup);\n  });\n\n  addProcessHandlerIfNeeded('exit');\n  if (options.handleSIGINT)\n    addProcessHandlerIfNeeded('SIGINT');\n  if (options.handleSIGTERM)\n    addProcessHandlerIfNeeded('SIGTERM');\n  if (options.handleSIGHUP)\n    addProcessHandlerIfNeeded('SIGHUP');\n  gracefullyCloseSet.add(gracefullyClose);\n  killSet.add(killProcessAndCleanup);\n\n  let gracefullyClosing = false;\n  async function gracefullyClose(): Promise<void> {\n    // We keep listeners until we are done, to handle 'exit' and 'SIGINT' while\n    // asynchronously closing to prevent zombie processes. This might introduce\n    // reentrancy to this function, for example user sends SIGINT second time.\n    // In this case, let's forcefully kill the process.\n    if (gracefullyClosing) {\n      options.log(`[pid=${spawnedProcess.pid}] <forcefully close>`);\n      killProcess();\n      await waitForCleanup;  // Ensure the process is dead and we have cleaned up.\n      return;\n    }\n    gracefullyClosing = true;\n    options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);\n    await options.attemptToGracefullyClose().catch(() => killProcess());\n    await waitForCleanup;  // Ensure the process is dead and we have cleaned up.\n    options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);\n  }\n\n  // This method has to be sync to be used in the 'exit' event handler.\n  function killProcess() {\n    gracefullyCloseSet.delete(gracefullyClose);\n    killSet.delete(killProcessAndCleanup);\n    removeProcessHandlersIfNeeded();\n    options.log(`[pid=${spawnedProcess.pid}] <kill>`);\n    if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {\n      options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);\n      // Force kill the browser.\n      try {\n        if (process.platform === 'win32') {\n          const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, { shell: true });\n          const [stdout, stderr] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];\n          if (stdout)\n            options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout}`);\n          if (stderr)\n            options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr}`);\n        } else {\n          process.kill(-spawnedProcess.pid, 'SIGKILL');\n        }\n      } catch (e) {\n        options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);\n        // the process might have already stopped\n      }\n    } else {\n      options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);\n    }\n  }\n\n  function killProcessAndCleanup() {\n    killProcess();\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);\n    for (const dir of options.tempDirectories) {\n      try {\n        fs.rmSync(dir, { force: true, recursive: true, maxRetries: 5 });\n      } catch (e) {\n        options.log(`[pid=${spawnedProcess.pid || 'N/A'}] exception while removing ${dir}: ${e}`);\n      }\n    }\n    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);\n  }\n\n  function killAndWait() {\n    killProcess();\n    return waitForCleanup;\n  }\n\n  return { launchedProcess: spawnedProcess, gracefullyClose, kill: killAndWait };\n}\n\nexport function envArrayToObject(env: { name: string, value: string }[]): Env {\n  const result: Env = {};\n  for (const { name, value } of env)\n    result[name] = value;\n  return result;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,mBAA8B;AAC9B,gBAAe;AACf,eAA0B;AAE1B,uBAA8B;AAC9B,mBAA4B;AA8BrB,MAAM,qBAAqB,oBAAI,IAAyB;AAC/D,MAAM,UAAU,oBAAI,IAAgB;AAEpC,eAAsB,qBAAqB;AACzC,QAAM,QAAQ,IAAI,MAAM,KAAK,kBAAkB,EAAE,IAAI,qBAAmB,gBAAgB,EAAE,MAAM,OAAK;AAAA,EAAC,CAAC,CAAC,CAAC;AAC3G;AAEO,SAAS,+BAA+B,MAAc;AAG3D,aAAW,MAAM,QAAQ,KAAK,IAAI,GAAG,GAAK;AAE1C,qBAAmB,EAAE,KAAK,MAAM;AAE9B,YAAQ,KAAK,IAAI;AAAA,EACnB,CAAC;AACH;AAEA,SAAS,cAAc;AACrB,aAAW,QAAQ;AACjB,SAAK;AACT;AAEA,IAAI,sBAAsB;AAC1B,SAAS,gBAAgB;AACvB,QAAM,kBAAkB,MAAM;AAE5B,YAAI,0BAAY,GAAG;AAEjB,iBAAW,MAAM,QAAQ,KAAK,GAAG,GAAG,GAAI;AAAA,IAC1C,OAAO;AAEL,cAAQ,KAAK,GAAG;AAAA,IAClB;AAAA,EACF;AAEA,MAAI,qBAAqB;AAEvB,YAAQ,IAAI,UAAU,aAAa;AAInC,eAAW,QAAQ;AACjB,WAAK;AACP,oBAAgB;AAAA,EAClB,OAAO;AACL,0BAAsB;AACtB,uBAAmB,EAAE,KAAK,MAAM,gBAAgB,CAAC;AAAA,EACnD;AACF;AAEA,SAAS,iBAAiB;AACxB,qBAAmB;AACrB;AAEA,SAAS,gBAAgB;AACvB,qBAAmB;AACrB;AAEA,MAAM,oBAAoB,oBAAI,IAA8C;AAC5E,MAAM,kBAAkB;AAAA,EACtB,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AACV;AACA,SAAS,0BAA0B,MAAgD;AACjF,MAAI,CAAC,kBAAkB,IAAI,IAAI,GAAG;AAChC,sBAAkB,IAAI,IAAI;AAC1B,YAAQ,GAAG,MAAM,gBAAgB,IAAI,CAAC;AAAA,EACxC;AACF;AACA,SAAS,gCAAgC;AACvC,MAAI,QAAQ;AACV;AACF,aAAW,WAAW;AACpB,YAAQ,IAAI,SAAS,gBAAgB,OAAO,CAAC;AAC/C,oBAAkB,MAAM;AAC1B;AAEA,eAAsB,cAAc,SAAsD;AACxF,QAAM,QAA+B,QAAQ,UAAU,SAAS,CAAC,UAAU,QAAQ,QAAQ,QAAQ,MAAM,IAAI,CAAC,QAAQ,QAAQ,MAAM;AACpI,UAAQ,IAAI,eAAe,QAAQ,OAAO,IAAI,QAAQ,OAAO,QAAQ,KAAK,KAAK,GAAG,IAAI,EAAE,EAAE;AAC1F,QAAM,eAA0C;AAAA;AAAA;AAAA;AAAA,IAI9C,UAAU,QAAQ,aAAa;AAAA,IAC/B,KAAM,QAAQ;AAAA,IACd,KAAK,QAAQ;AAAA,IACb,OAAO,QAAQ;AAAA,IACf;AAAA,EACF;AACA,QAAM,iBAAiB,aAAa,MAAM,QAAQ,SAAS,QAAQ,QAAQ,CAAC,GAAG,YAAY;AAE3F,QAAM,UAAU,YAAY;AAC1B,YAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,0CAA0C;AACzF,UAAM,SAAS,UAAM,gCAAc,QAAQ,eAAe;AAC1D,aAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,QAAQ,EAAE,GAAG;AACvD,UAAI,OAAO,CAAC;AACV,gBAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,8BAA8B,QAAQ,gBAAgB,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,EAAE;AAAA,IAC3H;AACA,YAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,0CAA0C;AAAA,EAC3F;AAGA,iBAAe,GAAG,SAAS,MAAM;AAAA,EAAC,CAAC;AAEnC,MAAI,CAAC,eAAe,KAAK;AACvB,QAAI;AACJ,UAAM,gBAAgB,IAAI,QAAe,CAAC,GAAG,MAAM,SAAS,CAAC;AAC7D,mBAAe,KAAK,SAAS,WAAS;AACpC,aAAO,IAAI,MAAM,uBAAuB,KAAK,CAAC;AAAA,IAChD,CAAC;AACD,WAAO,cAAc,KAAK,OAAM,UAAS;AACvC,YAAM,QAAQ;AACd,YAAM;AAAA,IACR,CAAC;AAAA,EACH;AACA,UAAQ,IAAI,kBAAkB,eAAe,GAAG,EAAE;AAElD,QAAM,SAAS,SAAS,gBAAgB,EAAE,OAAO,eAAe,OAAQ,CAAC;AACzE,SAAO,GAAG,QAAQ,CAAC,SAAiB;AAClC,YAAQ,IAAI,QAAQ,eAAe,GAAG,YAAY,IAAI;AAAA,EACxD,CAAC;AAED,QAAM,SAAS,SAAS,gBAAgB,EAAE,OAAO,eAAe,OAAQ,CAAC;AACzE,SAAO,GAAG,QAAQ,CAAC,SAAiB;AAClC,YAAQ,IAAI,QAAQ,eAAe,GAAG,YAAY,IAAI;AAAA,EACxD,CAAC;AAED,MAAI,gBAAgB;AACpB,MAAI,iBAAiB,MAAM;AAAA,EAAC;AAC5B,QAAM,iBAAiB,IAAI,QAAc,OAAK,iBAAiB,CAAC;AAChE,iBAAe,KAAK,SAAS,CAAC,UAAU,WAAW;AACjD,YAAQ,IAAI,QAAQ,eAAe,GAAG,iCAAiC,QAAQ,YAAY,MAAM,GAAG;AACpG,oBAAgB;AAChB,uBAAmB,OAAO,eAAe;AACzC,YAAQ,OAAO,qBAAqB;AACpC,kCAA8B;AAC9B,YAAQ,OAAO,UAAU,MAAM;AAE/B,YAAQ,EAAE,KAAK,cAAc;AAAA,EAC/B,CAAC;AAED,4BAA0B,MAAM;AAChC,MAAI,QAAQ;AACV,8BAA0B,QAAQ;AACpC,MAAI,QAAQ;AACV,8BAA0B,SAAS;AACrC,MAAI,QAAQ;AACV,8BAA0B,QAAQ;AACpC,qBAAmB,IAAI,eAAe;AACtC,UAAQ,IAAI,qBAAqB;AAEjC,MAAI,oBAAoB;AACxB,iBAAe,kBAAiC;AAK9C,QAAI,mBAAmB;AACrB,cAAQ,IAAI,QAAQ,eAAe,GAAG,sBAAsB;AAC5D,kBAAY;AACZ,YAAM;AACN;AAAA,IACF;AACA,wBAAoB;AACpB,YAAQ,IAAI,QAAQ,eAAe,GAAG,4BAA4B;AAClE,UAAM,QAAQ,yBAAyB,EAAE,MAAM,MAAM,YAAY,CAAC;AAClE,UAAM;AACN,YAAQ,IAAI,QAAQ,eAAe,GAAG,0BAA0B;AAAA,EAClE;AAGA,WAAS,cAAc;AACrB,uBAAmB,OAAO,eAAe;AACzC,YAAQ,OAAO,qBAAqB;AACpC,kCAA8B;AAC9B,YAAQ,IAAI,QAAQ,eAAe,GAAG,UAAU;AAChD,QAAI,eAAe,OAAO,CAAC,eAAe,UAAU,CAAC,eAAe;AAClE,cAAQ,IAAI,QAAQ,eAAe,GAAG,qBAAqB;AAE3D,UAAI;AACF,YAAI,QAAQ,aAAa,SAAS;AAChC,gBAAM,kBAAkB,aAAa,UAAU,iBAAiB,eAAe,GAAG,UAAU,EAAE,OAAO,KAAK,CAAC;AAC3G,gBAAM,CAACA,SAAQC,OAAM,IAAI,CAAC,gBAAgB,OAAO,SAAS,GAAG,gBAAgB,OAAO,SAAS,CAAC;AAC9F,cAAID;AACF,oBAAQ,IAAI,QAAQ,eAAe,GAAG,sBAAsBA,OAAM,EAAE;AACtE,cAAIC;AACF,oBAAQ,IAAI,QAAQ,eAAe,GAAG,sBAAsBA,OAAM,EAAE;AAAA,QACxE,OAAO;AACL,kBAAQ,KAAK,CAAC,eAAe,KAAK,SAAS;AAAA,QAC7C;AAAA,MACF,SAAS,GAAG;AACV,gBAAQ,IAAI,QAAQ,eAAe,GAAG,6CAA6C,CAAC,EAAE;AAAA,MAExF;AAAA,IACF,OAAO;AACL,cAAQ,IAAI,QAAQ,eAAe,GAAG,+CAA+C,eAAe,MAAM,kBAAkB,aAAa,GAAG;AAAA,IAC9I;AAAA,EACF;AAEA,WAAS,wBAAwB;AAC/B,gBAAY;AACZ,YAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,0CAA0C;AACzF,eAAW,OAAO,QAAQ,iBAAiB;AACzC,UAAI;AACF,kBAAAC,QAAG,OAAO,KAAK,EAAE,OAAO,MAAM,WAAW,MAAM,YAAY,EAAE,CAAC;AAAA,MAChE,SAAS,GAAG;AACV,gBAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,8BAA8B,GAAG,KAAK,CAAC,EAAE;AAAA,MAC1F;AAAA,IACF;AACA,YAAQ,IAAI,QAAQ,eAAe,OAAO,KAAK,0CAA0C;AAAA,EAC3F;AAEA,WAAS,cAAc;AACrB,gBAAY;AACZ,WAAO;AAAA,EACT;AAEA,SAAO,EAAE,iBAAiB,gBAAgB,iBAAiB,MAAM,YAAY;AAC/E;AAEO,SAAS,iBAAiB,KAA6C;AAC5E,QAAM,SAAc,CAAC;AACrB,aAAW,EAAE,MAAM,MAAM,KAAK;AAC5B,WAAO,IAAI,IAAI;AACjB,SAAO;AACT;",
  "names": ["stdout", "stderr", "fs"]
}

{
  "version": 3,
  "sources": ["../../../src/server/utils/fileUtils.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { ManualPromise } from '../../utils/isomorphic/manualPromise';\nimport { yazl } from '../../zipBundle';\n\nimport type { EventEmitter } from 'events';\n\nexport const existsAsync = (path: string): Promise<boolean> => new Promise(resolve => fs.stat(path, err => resolve(!err)));\n\nexport async function mkdirIfNeeded(filePath: string) {\n  // This will harmlessly throw on windows if the dirname is the root directory.\n  await fs.promises.mkdir(path.dirname(filePath), { recursive: true }).catch(() => {});\n}\n\nexport async function removeFolders(dirs: string[]): Promise<(Error| undefined)[]> {\n  return await Promise.all(dirs.map((dir: string) =>\n    fs.promises.rm(dir, { recursive: true, force: true, maxRetries: 10 }).catch(e => e)\n  ));\n}\n\nexport function canAccessFile(file: string) {\n  if (!file)\n    return false;\n\n  try {\n    fs.accessSync(file);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport async function copyFileAndMakeWritable(from: string, to: string) {\n  await fs.promises.copyFile(from, to);\n  await fs.promises.chmod(to, 0o664);\n}\n\nexport function sanitizeForFilePath(s: string) {\n  return s.replace(/[\\x00-\\x2C\\x2E-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7B-\\x7F]+/g, '-');\n}\n\nexport function toPosixPath(aPath: string): string {\n  return aPath.split(path.sep).join(path.posix.sep);\n}\n\ntype NameValue = { name: string, value: string };\ntype SerializedFSOperation = {\n  op: 'mkdir', dir: string,\n} | {\n  op: 'writeFile', file: string, content: string | Buffer, skipIfExists?: boolean,\n} | {\n  op: 'appendFile', file: string, content: string,\n} | {\n  op: 'copyFile', from: string, to: string,\n} | {\n  op: 'zip', entries: NameValue[], zipFileName: string,\n};\n\nexport class SerializedFS {\n  private _buffers = new Map<string, string[]>(); // Should never be accessed from within appendOperation.\n  private _error: Error | undefined;\n  private _operations: SerializedFSOperation[] = [];\n  private _operationsDone: ManualPromise<void>;\n\n  constructor() {\n    this._operationsDone = new ManualPromise();\n    this._operationsDone.resolve();  // No operations scheduled yet.\n  }\n\n  mkdir(dir: string) {\n    this._appendOperation({ op: 'mkdir', dir });\n  }\n\n  writeFile(file: string, content: string | Buffer, skipIfExists?: boolean) {\n    this._buffers.delete(file); // No need to flush the buffer since we'll overwrite anyway.\n    this._appendOperation({ op: 'writeFile', file, content, skipIfExists });\n  }\n\n  appendFile(file: string, text: string, flush?: boolean) {\n    if (!this._buffers.has(file))\n      this._buffers.set(file, []);\n    this._buffers.get(file)!.push(text);\n    if (flush)\n      this._flushFile(file);\n  }\n\n  private _flushFile(file: string) {\n    const buffer = this._buffers.get(file);\n    if (buffer === undefined)\n      return;\n    const content = buffer.join('');\n    this._buffers.delete(file);\n    this._appendOperation({ op: 'appendFile', file, content });\n  }\n\n  copyFile(from: string, to: string) {\n    this._flushFile(from);\n    this._buffers.delete(to); // No need to flush the buffer since we'll overwrite anyway.\n    this._appendOperation({ op: 'copyFile', from, to });\n  }\n\n  async syncAndGetError() {\n    for (const file of this._buffers.keys())\n      this._flushFile(file);\n    await this._operationsDone;\n    return this._error;\n  }\n\n  zip(entries: NameValue[], zipFileName: string) {\n    for (const file of this._buffers.keys())\n      this._flushFile(file);\n\n    // Chain the export operation against write operations,\n    // so that files do not change during the export.\n    this._appendOperation({ op: 'zip', entries, zipFileName });\n  }\n\n  // This method serializes all writes to the trace.\n  private _appendOperation(op: SerializedFSOperation): void {\n    const last = this._operations[this._operations.length - 1];\n    if (last?.op === 'appendFile' && op.op === 'appendFile' && last.file === op.file) {\n      // Merge pending appendFile operations for performance.\n      last.content += op.content;\n      return;\n    }\n\n    this._operations.push(op);\n    if (this._operationsDone.isDone())\n      this._performOperations();\n  }\n\n  private async _performOperations() {\n    this._operationsDone = new ManualPromise();\n    while (this._operations.length) {\n      const op = this._operations.shift()!;\n      // Ignore all operations after the first error.\n      if (this._error)\n        continue;\n      try {\n        await this._performOperation(op);\n      } catch (e) {\n        this._error = e;\n      }\n    }\n    this._operationsDone.resolve();\n  }\n\n  private async _performOperation(op: SerializedFSOperation) {\n    switch (op.op) {\n      case 'mkdir': {\n        await fs.promises.mkdir(op.dir, { recursive: true });\n        return;\n      }\n      case 'writeFile': {\n        // Note: 'wx' flag only writes when the file does not exist.\n        // See https://nodejs.org/api/fs.html#file-system-flags.\n        // This way tracing never have to write the same resource twice.\n        if (op.skipIfExists)\n          await fs.promises.writeFile(op.file, op.content, { flag: 'wx' }).catch(() => {});\n        else\n          await fs.promises.writeFile(op.file, op.content);\n        return;\n      }\n      case 'copyFile': {\n        await fs.promises.copyFile(op.from, op.to);\n        return;\n      }\n      case 'appendFile': {\n        await fs.promises.appendFile(op.file, op.content);\n        return;\n      }\n      case 'zip': {\n        const zipFile = new yazl.ZipFile();\n        const result = new ManualPromise<void>();\n        (zipFile as any as EventEmitter).on('error', error => result.reject(error));\n        for (const entry of op.entries)\n          zipFile.addFile(entry.value, entry.name);\n        zipFile.end();\n        zipFile.outputStream\n            .pipe(fs.createWriteStream(op.zipFileName))\n            .on('close', () => result.resolve())\n            .on('error', error => result.reject(error));\n        await result;\n        return;\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "fs"]
}

{
  "version": 3,
  "sources": ["../../../src/server/utils/wsServer.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createHttpServer } from './network';\nimport { wsServer } from '../../utilsBundle';\nimport { debugLogger } from './debugLogger';\n\nimport type { WebSocket, WebSocketServer } from '../../utilsBundle';\nimport type http from 'http';\nimport type stream from 'stream';\n\n\nlet lastConnectionId = 0;\nconst kConnectionSymbol = Symbol('kConnection');\n\nexport const perMessageDeflate = {\n  serverNoContextTakeover: true,\n  zlibDeflateOptions: {\n    level: 3,\n  },\n  zlibInflateOptions: {\n    chunkSize: 10 * 1024\n  },\n  threshold: 10 * 1024,\n};\n\nexport type WSConnection = {\n  close: () => Promise<void>;\n};\n\nexport type WSServerDelegate = {\n  onRequest: (request: http.IncomingMessage, response: http.ServerResponse) => void;\n  onHeaders: (headers: string[]) => void;\n  onUpgrade: (request: http.IncomingMessage, socket: stream.Duplex) => { error: string } | undefined;\n  onConnection: (request: http.IncomingMessage, url: URL, ws: WebSocket, id: string) => WSConnection;\n};\n\nexport class WSServer {\n  private _wsServer: WebSocketServer | undefined;\n  server: http.Server | undefined;\n  private _delegate: WSServerDelegate;\n\n  constructor(delegate: WSServerDelegate) {\n    this._delegate = delegate;\n  }\n\n  async listen(port: number = 0, hostname: string | undefined, path: string): Promise<string> {\n    debugLogger.log('server', `Server started at ${new Date()}`);\n\n    const server = createHttpServer(this._delegate.onRequest);\n    server.on('error', error => debugLogger.log('server', String(error)));\n    this.server = server;\n\n    const wsEndpoint = await new Promise<string>((resolve, reject) => {\n      server.listen(port, hostname, () => {\n        const address = server.address();\n        if (!address) {\n          reject(new Error('Could not bind server socket'));\n          return;\n        }\n        const wsEndpoint = typeof address === 'string' ? `${address}${path}` : `ws://${hostname || 'localhost'}:${address.port}${path}`;\n        resolve(wsEndpoint);\n      }).on('error', reject);\n    });\n\n    debugLogger.log('server', 'Listening at ' + wsEndpoint);\n\n    this._wsServer = new wsServer({\n      noServer: true,\n      perMessageDeflate,\n    });\n\n    this._wsServer.on('headers', headers => this._delegate.onHeaders(headers));\n\n    server.on('upgrade', (request, socket, head) => {\n      const pathname = new URL('http://localhost' + request.url!).pathname;\n      if (pathname !== path) {\n        socket.write(`HTTP/${request.httpVersion} 400 Bad Request\\r\\n\\r\\n`);\n        socket.destroy();\n        return;\n      }\n      const upgradeResult = this._delegate.onUpgrade(request, socket);\n      if (upgradeResult) {\n        socket.write(upgradeResult.error);\n        socket.destroy();\n        return;\n      }\n      this._wsServer!.handleUpgrade(request, socket, head, ws => this._wsServer!.emit('connection', ws, request));\n    });\n\n    this._wsServer.on('connection', (ws, request) => {\n      debugLogger.log('server', 'Connected client ws.extension=' + ws.extensions);\n      const url = new URL('http://localhost' + (request.url || ''));\n      const id = String(++lastConnectionId);\n      debugLogger.log('server', `[${id}] serving connection: ${request.url}`);\n      try {\n        const connection = this._delegate.onConnection(request, url, ws, id);\n        (ws as any)[kConnectionSymbol] = connection;\n      } catch (error) {\n        debugLogger.log('server', `[${id}] connection error: ${error}`);\n        ws.close(1011, String(error));\n      }\n    });\n\n    return wsEndpoint;\n  }\n\n  async close() {\n    const server = this._wsServer;\n    if (!server)\n      return;\n    debugLogger.log('server', 'closing websocket server');\n    const waitForClose = new Promise(f => server.close(f));\n    // First disconnect all remaining clients.\n    await Promise.all(Array.from(server.clients).map(async ws => {\n      const connection = (ws as any)[kConnectionSymbol] as WSConnection | undefined;\n      if (connection)\n        await connection.close();\n      try {\n        ws.terminate();\n      } catch (e) {\n      }\n    }));\n    await waitForClose;\n    debugLogger.log('server', 'closing http server');\n    if (this.server)\n      await new Promise(f => this.server!.close(f));\n    this._wsServer = undefined;\n    this.server = undefined;\n    debugLogger.log('server', 'closed server');\n  }\n}\n"],
  "mappings": "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",
  "names": ["wsEndpoint"]
}

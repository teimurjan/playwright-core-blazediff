{
  "version": 3,
  "sources": ["../../../src/server/utils/httpServer.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { mime, wsServer } from '../../utilsBundle';\nimport { createGuid } from './crypto';\nimport { assert } from '../../utils/isomorphic/assert';\nimport { ManualPromise } from '../../utils/isomorphic/manualPromise';\nimport { createHttpServer } from './network';\n\nimport type http from 'http';\n\nexport type ServerRouteHandler = (request: http.IncomingMessage, response: http.ServerResponse) => boolean;\n\nexport type Transport = {\n  sendEvent?: (method: string, params: any) => void;\n  close?: () => void;\n  onconnect: () => void;\n  dispatch: (method: string, params: any) => Promise<any>;\n  onclose: () => void;\n};\n\nexport class HttpServer {\n  private _server: http.Server;\n  private _urlPrefixPrecise: string = '';\n  private _urlPrefixHumanReadable: string = '';\n  private _port: number = 0;\n  private _started = false;\n  private _routes: { prefix?: string, exact?: string, handler: ServerRouteHandler }[] = [];\n  private _wsGuid: string | undefined;\n\n  constructor() {\n    this._server = createHttpServer(this._onRequest.bind(this));\n  }\n\n  server() {\n    return this._server;\n  }\n\n  routePrefix(prefix: string, handler: ServerRouteHandler) {\n    this._routes.push({ prefix, handler });\n  }\n\n  routePath(path: string, handler: ServerRouteHandler) {\n    this._routes.push({ exact: path, handler });\n  }\n\n  port(): number {\n    return this._port;\n  }\n\n  private async _tryStart(port: number | undefined, host: string) {\n    const errorPromise = new ManualPromise();\n    const errorListener = (error: Error) => errorPromise.reject(error);\n    this._server.on('error', errorListener);\n\n    try {\n      this._server.listen(port, host);\n      await Promise.race([\n        new Promise(cb => this._server!.once('listening', cb)),\n        errorPromise,\n      ]);\n    } finally {\n      this._server.removeListener('error', errorListener);\n    }\n  }\n\n  createWebSocket(transport: Transport, guid?: string) {\n    assert(!this._wsGuid, 'can only create one main websocket transport per server');\n    this._wsGuid = guid || createGuid();\n    const wss = new wsServer({ server: this._server, path: '/' + this._wsGuid });\n    wss.on('connection', ws => {\n      transport.onconnect();\n      transport.sendEvent = (method, params)  => ws.send(JSON.stringify({ method, params }));\n      transport.close = () => ws.close();\n      ws.on('message', async message => {\n        const { id, method, params } = JSON.parse(String(message));\n        try {\n          const result = await transport.dispatch(method, params);\n          ws.send(JSON.stringify({ id, result }));\n        } catch (e) {\n          ws.send(JSON.stringify({ id, error: String(e) }));\n        }\n      });\n      ws.on('close', () => transport.onclose());\n      ws.on('error', () => transport.onclose());\n    });\n  }\n\n  wsGuid(): string | undefined {\n    return this._wsGuid;\n  }\n\n  async start(options: { port?: number, preferredPort?: number, host?: string } = {}): Promise<void> {\n    assert(!this._started, 'server already started');\n    this._started = true;\n\n    const host = options.host || 'localhost';\n    if (options.preferredPort) {\n      try {\n        await this._tryStart(options.preferredPort, host);\n      } catch (e) {\n        if (!e || !e.message || !e.message.includes('EADDRINUSE'))\n          throw e;\n        await this._tryStart(undefined, host);\n      }\n    } else {\n      await this._tryStart(options.port, host);\n    }\n\n    const address = this._server.address();\n    assert(address, 'Could not bind server socket');\n    if (typeof address === 'string') {\n      this._urlPrefixPrecise = address;\n      this._urlPrefixHumanReadable = address;\n    } else {\n      this._port = address.port;\n      const resolvedHost = address.family === 'IPv4' ? address.address : `[${address.address}]`;\n      this._urlPrefixPrecise = `http://${resolvedHost}:${address.port}`;\n      this._urlPrefixHumanReadable = `http://${host}:${address.port}`;\n    }\n  }\n\n  async stop() {\n    await new Promise(cb => this._server!.close(cb));\n  }\n\n  urlPrefix(purpose: 'human-readable' | 'precise'): string {\n    return purpose === 'human-readable' ? this._urlPrefixHumanReadable : this._urlPrefixPrecise;\n  }\n\n  serveFile(request: http.IncomingMessage, response: http.ServerResponse, absoluteFilePath: string, headers?: { [name: string]: string }): boolean {\n    try {\n      for (const [name, value] of Object.entries(headers || {}))\n        response.setHeader(name, value);\n      if (request.headers.range)\n        this._serveRangeFile(request, response, absoluteFilePath);\n      else\n        this._serveFile(response, absoluteFilePath);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _serveFile(response: http.ServerResponse, absoluteFilePath: string) {\n    const content = fs.readFileSync(absoluteFilePath);\n    response.statusCode = 200;\n    const contentType = mime.getType(path.extname(absoluteFilePath)) || 'application/octet-stream';\n    response.setHeader('Content-Type', contentType);\n    response.setHeader('Content-Length', content.byteLength);\n    response.end(content);\n  }\n\n  _serveRangeFile(request: http.IncomingMessage, response: http.ServerResponse, absoluteFilePath: string) {\n    const range = request.headers.range;\n    if (!range || !range.startsWith('bytes=') || range.includes(', ') || [...range].filter(char => char === '-').length !== 1) {\n      response.statusCode = 400;\n      return response.end('Bad request');\n    }\n\n    // Parse the range header: https://datatracker.ietf.org/doc/html/rfc7233#section-2.1\n    const [startStr, endStr] = range.replace(/bytes=/, '').split('-');\n\n    // Both start and end (when passing to fs.createReadStream) and the range header are inclusive and start counting at 0.\n    let start: number;\n    let end: number;\n    const size = fs.statSync(absoluteFilePath).size;\n    if (startStr !== '' && endStr === '') {\n      // No end specified: use the whole file\n      start = +startStr;\n      end = size - 1;\n    } else if (startStr === '' && endStr !== '') {\n      // No start specified: calculate start manually\n      start = size - +endStr;\n      end = size - 1;\n    } else {\n      start = +startStr;\n      end = +endStr;\n    }\n\n    // Handle unavailable range request\n    if (Number.isNaN(start) || Number.isNaN(end) || start >= size || end >= size || start > end) {\n      // Return the 416 Range Not Satisfiable: https://datatracker.ietf.org/doc/html/rfc7233#section-4.4\n      response.writeHead(416, {\n        'Content-Range': `bytes */${size}`\n      });\n      return response.end();\n    }\n\n    // Sending Partial Content: https://datatracker.ietf.org/doc/html/rfc7233#section-4.1\n    response.writeHead(206, {\n      'Content-Range': `bytes ${start}-${end}/${size}`,\n      'Accept-Ranges': 'bytes',\n      'Content-Length': end - start + 1,\n      'Content-Type': mime.getType(path.extname(absoluteFilePath))!,\n    });\n\n    const readable = fs.createReadStream(absoluteFilePath, { start, end });\n    readable.pipe(response);\n  }\n\n  private _onRequest(request: http.IncomingMessage, response: http.ServerResponse) {\n    if (request.method === 'OPTIONS') {\n      response.writeHead(200);\n      response.end();\n      return;\n    }\n\n    request.on('error', () => response.end());\n    try {\n      if (!request.url) {\n        response.end();\n        return;\n      }\n      const url = new URL('http://localhost' + request.url);\n      for (const route of this._routes) {\n        if (route.exact && url.pathname === route.exact && route.handler(request, response))\n          return;\n        if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))\n          return;\n      }\n      response.statusCode = 404;\n      response.end();\n    } catch (e) {\n      response.end();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "fs"]
}

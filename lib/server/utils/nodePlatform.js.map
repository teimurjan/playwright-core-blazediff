{
  "version": 3,
  "sources": ["../../../src/server/utils/nodePlatform.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport crypto from 'crypto';\nimport fs from 'fs';\nimport path from 'path';\nimport * as util from 'util';\nimport { Readable, Writable, pipeline } from 'stream';\nimport { EventEmitter } from 'events';\n\nimport { colors } from '../../utilsBundle';\nimport { debugLogger } from './debugLogger';\nimport { currentZone, emptyZone } from './zones';\nimport { debugMode, isUnderTest } from './debug';\n\nimport type { Platform, Zone } from '../../client/platform';\nimport type { Zone as ZoneImpl } from './zones';\nimport type * as channels from '@protocol/channels';\n\nconst pipelineAsync = util.promisify(pipeline);\n\nclass NodeZone implements Zone {\n  private _zone: ZoneImpl;\n\n  constructor(zone: ZoneImpl) {\n    this._zone = zone;\n  }\n\n  push<T>(data: T) {\n    return new NodeZone(this._zone.with('apiZone', data));\n  }\n\n  pop() {\n    return new NodeZone(this._zone.without('apiZone'));\n  }\n\n  run<R>(func: () => R): R {\n    return this._zone.run(func);\n  }\n\n  data<T>(): T | undefined {\n    return this._zone.data('apiZone');\n  }\n}\n\nlet boxedStackPrefixes: string[] = [];\nexport function setBoxedStackPrefixes(prefixes: string[]) {\n  boxedStackPrefixes = prefixes;\n}\n\nconst coreDir = path.dirname(require.resolve('../../../package.json'));\n\nexport const nodePlatform: Platform = {\n  name: 'node',\n\n  boxedStackPrefixes: () => {\n    if (process.env.PWDEBUGIMPL)\n      return [];\n    return [coreDir, ...boxedStackPrefixes];\n  },\n\n  calculateSha1: (text: string) => {\n    const sha1 = crypto.createHash('sha1');\n    sha1.update(text);\n    return Promise.resolve(sha1.digest('hex'));\n  },\n\n  colors,\n\n  coreDir,\n\n  createGuid: () => crypto.randomBytes(16).toString('hex'),\n\n  defaultMaxListeners: () => EventEmitter.defaultMaxListeners,\n  fs: () => fs,\n\n  env: process.env,\n\n  inspectCustom: util.inspect.custom,\n\n  isDebugMode: () => debugMode() === 'inspector',\n\n  isJSDebuggerAttached: () => !!require('inspector').url(),\n\n  isLogEnabled(name: 'api' | 'channel') {\n    return debugLogger.isEnabled(name);\n  },\n\n  isUnderTest: () => isUnderTest(),\n\n  log(name: 'api' | 'channel', message: string | Error | object) {\n    debugLogger.log(name, message);\n  },\n\n  path: () => path,\n\n  pathSeparator: path.sep,\n\n  showInternalStackFrames: () => !!process.env.PWDEBUGIMPL,\n\n  async streamFile(path: string, stream: Writable): Promise<void> {\n    await pipelineAsync(fs.createReadStream(path), stream);\n  },\n\n  streamReadable: (channel: channels.StreamChannel) => {\n    return new ReadableStreamImpl(channel);\n  },\n\n  streamWritable: (channel: channels.WritableStreamChannel) => {\n    return new WritableStreamImpl(channel);\n  },\n\n  zones: {\n    current: () => new NodeZone(currentZone()),\n    empty: new NodeZone(emptyZone),\n  }\n};\n\nclass ReadableStreamImpl extends Readable {\n  private _channel: channels.StreamChannel;\n\n  constructor(channel: channels.StreamChannel) {\n    super();\n    this._channel = channel;\n  }\n\n  override async _read() {\n    const result = await this._channel.read({ size: 1024 * 1024 });\n    if (result.binary.byteLength)\n      this.push(result.binary);\n    else\n      this.push(null);\n  }\n\n  override _destroy(error: Error | null, callback: (error: Error | null | undefined) => void): void {\n    // Stream might be destroyed after the connection was closed.\n    this._channel.close().catch(e => null);\n    super._destroy(error, callback);\n  }\n}\n\nclass WritableStreamImpl extends Writable {\n  private _channel: channels.WritableStreamChannel;\n\n  constructor(channel: channels.WritableStreamChannel) {\n    super();\n    this._channel = channel;\n  }\n\n  override async _write(chunk: Buffer | string, encoding: BufferEncoding, callback: (error?: Error | null) => void) {\n    const error = await this._channel.write({ binary: typeof chunk === 'string' ? Buffer.from(chunk) : chunk }).catch(e => e);\n    callback(error || null);\n  }\n\n  override async _final(callback: (error?: Error | null) => void) {\n    // Stream might be destroyed after the connection was closed.\n    const error = await this._channel.close().catch(e => e);\n    callback(error || null);\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "crypto", "fs"]
}

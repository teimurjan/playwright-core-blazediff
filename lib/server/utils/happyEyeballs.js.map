{
  "version": 3,
  "sources": ["../../../src/server/utils/happyEyeballs.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport dns from 'dns';\nimport http from 'http';\nimport https from 'https';\nimport net from 'net';\nimport tls from 'tls';\n\nimport { assert } from '../../utils/isomorphic/assert';\nimport { ManualPromise } from '../../utils/isomorphic/manualPromise';\nimport { monotonicTime } from '../../utils/isomorphic/time';\n\n// Implementation(partial) of Happy Eyeballs 2 algorithm described in\n// https://www.rfc-editor.org/rfc/rfc8305\n\n// Same as in Chromium (https://source.chromium.org/chromium/chromium/src/+/5666ff4f5077a7e2f72902f3a95f5d553ea0d88d:net/socket/transport_connect_job.cc;l=102)\nconst connectionAttemptDelayMs = 300;\n\nconst kDNSLookupAt = Symbol('kDNSLookupAt');\nconst kTCPConnectionAt = Symbol('kTCPConnectionAt');\n\nclass HttpHappyEyeballsAgent extends http.Agent {\n  createConnection(options: http.ClientRequestArgs, oncreate?: (err: Error | null, socket?: net.Socket) => void): net.Socket | undefined {\n    // There is no ambiguity in case of IP address.\n    if (net.isIP(clientRequestArgsToHostName(options)))\n      return net.createConnection(options as net.NetConnectOpts);\n    createConnectionAsync(options, oncreate, /* useTLS */ false).catch(err => oncreate?.(err));\n  }\n}\n\nclass HttpsHappyEyeballsAgent extends https.Agent {\n  createConnection(options: http.ClientRequestArgs, oncreate?: (err: Error | null, socket?: net.Socket) => void): net.Socket | undefined {\n    // There is no ambiguity in case of IP address.\n    if (net.isIP(clientRequestArgsToHostName(options)))\n      return tls.connect(options as tls.ConnectionOptions);\n    createConnectionAsync(options, oncreate, /* useTLS */ true).catch(err => oncreate?.(err));\n  }\n}\n\n// These options are aligned with the default Node.js globalAgent options.\nexport const httpsHappyEyeballsAgent = new HttpsHappyEyeballsAgent({ keepAlive: true });\nexport const httpHappyEyeballsAgent = new HttpHappyEyeballsAgent({ keepAlive: true });\n\nexport async function createSocket(host: string, port: number): Promise<net.Socket> {\n  return new Promise((resolve, reject) => {\n    if (net.isIP(host)) {\n      const socket = net.createConnection({ host, port });\n      socket.on('connect', () => resolve(socket));\n      socket.on('error', error => reject(error));\n    } else {\n      createConnectionAsync({ host, port }, (err, socket) => {\n        if (err)\n          reject(err);\n        if (socket)\n          resolve(socket);\n      }, /* useTLS */ false).catch(err => reject(err));\n    }\n  });\n}\n\nexport async function createTLSSocket(options: tls.ConnectionOptions): Promise<tls.TLSSocket> {\n  return new Promise((resolve, reject) => {\n    assert(options.host, 'host is required');\n    if (net.isIP(options.host)) {\n      const socket = tls.connect(options);\n      socket.on('secureConnect', () => resolve(socket));\n      socket.on('error', error => reject(error));\n    } else {\n      createConnectionAsync(options, (err, socket) => {\n        if (err)\n          reject(err);\n        if (socket) {\n          socket.on('secureConnect', () => resolve(socket));\n          socket.on('error', error => reject(error));\n        }\n      }, true).catch(err => reject(err));\n    }\n  });\n}\n\nexport async function createConnectionAsync(\n  options: http.ClientRequestArgs,\n  oncreate: ((err: Error | null, socket?: tls.TLSSocket) => void) | undefined,\n  useTLS: true\n): Promise<void>;\n\nexport async function createConnectionAsync(\n  options: http.ClientRequestArgs,\n  oncreate: ((err: Error | null, socket?: net.Socket) => void) | undefined,\n  useTLS: false\n): Promise<void>;\n\nexport async function createConnectionAsync(\n  options: http.ClientRequestArgs,\n  oncreate: ((err: Error | null, socket?: any) => void) | undefined,\n  useTLS: boolean\n): Promise<void> {\n  const lookup = (options as any).__testHookLookup || lookupAddresses;\n  const hostname = clientRequestArgsToHostName(options);\n  const addresses = await lookup(hostname);\n  const dnsLookupAt = monotonicTime();\n  const sockets = new Set<net.Socket>();\n  let firstError;\n  let errorCount = 0;\n  const handleError = (socket: net.Socket, err: Error) => {\n    if (!sockets.delete(socket))\n      return;\n    ++errorCount;\n    firstError ??= err;\n    if (errorCount === addresses.length)\n      oncreate?.(firstError);\n  };\n\n  const connected = new ManualPromise();\n  for (const { address } of addresses) {\n    const socket = useTLS ?\n      tls.connect({\n        ...(options as tls.ConnectionOptions),\n        port: options.port as number,\n        host: address,\n        servername: hostname }) :\n      net.createConnection({\n        ...options,\n        port: options.port as number,\n        host: address });\n\n    (socket as any)[kDNSLookupAt] = dnsLookupAt;\n\n    // Each socket may fire only one of 'connect', 'timeout' or 'error' events.\n    // None of these events are fired after socket.destroy() is called.\n    socket.on('connect', () => {\n      (socket as any)[kTCPConnectionAt] = monotonicTime();\n\n      connected.resolve();\n      oncreate?.(null, socket);\n      // TODO: Cache the result?\n      // Close other outstanding sockets.\n      sockets.delete(socket);\n      for (const s of sockets)\n        s.destroy();\n      sockets.clear();\n    });\n    socket.on('timeout', () => {\n      // Timeout is not an error, so we have to manually close the socket.\n      socket.destroy();\n      handleError(socket, new Error('Connection timeout'));\n    });\n    socket.on('error', e => handleError(socket, e));\n    sockets.add(socket);\n    await Promise.race([\n      connected,\n      new Promise(f => setTimeout(f, connectionAttemptDelayMs))\n    ]);\n    if (connected.isDone())\n      break;\n  }\n}\n\nasync function lookupAddresses(hostname: string): Promise<dns.LookupAddress[]> {\n  const addresses = await dns.promises.lookup(hostname, { all: true, family: 0, verbatim: true });\n  let firstFamily = addresses.filter(({ family }) => family === 6);\n  let secondFamily = addresses.filter(({ family }) => family === 4);\n  // Make sure first address in the list is the same as in the original order.\n  if (firstFamily.length && firstFamily[0] !== addresses[0]) {\n    const tmp = firstFamily;\n    firstFamily = secondFamily;\n    secondFamily = tmp;\n  }\n  const result = [];\n  // Alternate ipv6 and ipv4 addresses.\n  for (let i = 0; i < Math.max(firstFamily.length, secondFamily.length); i++) {\n    if (firstFamily[i])\n      result.push(firstFamily[i]);\n    if (secondFamily[i])\n      result.push(secondFamily[i]);\n  }\n  return result;\n}\n\nfunction clientRequestArgsToHostName(options: http.ClientRequestArgs): string {\n  if (options.hostname)\n    return options.hostname;\n  if (options.host)\n    return options.host;\n  throw new Error('Either options.hostname or options.host must be provided');\n}\n\nexport function timingForSocket(socket: net.Socket | tls.TLSSocket) {\n  return {\n    dnsLookupAt: (socket as any)[kDNSLookupAt] as number | undefined,\n    tcpConnectionAt: (socket as any)[kTCPConnectionAt] as number | undefined,\n  };\n}\n"],
  "mappings": "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",
  "names": ["http", "net", "https", "tls", "dns"]
}

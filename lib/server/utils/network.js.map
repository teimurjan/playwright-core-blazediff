{
  "version": 3,
  "sources": ["../../../src/server/utils/network.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport http from 'http';\nimport http2 from 'http2';\nimport https from 'https';\nimport url from 'url';\n\nimport { HttpsProxyAgent, SocksProxyAgent, getProxyForUrl } from '../../utilsBundle';\nimport { httpHappyEyeballsAgent, httpsHappyEyeballsAgent } from './happyEyeballs';\nimport { ManualPromise } from '../../utils/isomorphic/manualPromise';\n\nimport type net from 'net';\nimport type { ProxySettings } from '../types';\nimport type { Progress } from '../progress';\n\nexport type HTTPRequestParams = {\n  url: string,\n  method?: string,\n  headers?: http.OutgoingHttpHeaders,\n  data?: string | Buffer,\n  rejectUnauthorized?: boolean,\n  socketTimeout?: number,\n};\n\nexport const NET_DEFAULT_TIMEOUT = 30_000;\n\nexport function httpRequest(params: HTTPRequestParams, onResponse: (r: http.IncomingMessage) => void, onError: (error: Error) => void): { cancel(error: Error | undefined): void } {\n  const parsedUrl = url.parse(params.url);\n  let options: https.RequestOptions = {\n    ...parsedUrl,\n    agent: parsedUrl.protocol === 'https:' ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent,\n    method: params.method || 'GET',\n    headers: params.headers,\n  };\n  if (params.rejectUnauthorized !== undefined)\n    options.rejectUnauthorized = params.rejectUnauthorized;\n\n  const proxyURL = getProxyForUrl(params.url);\n  if (proxyURL) {\n    const parsedProxyURL = url.parse(proxyURL);\n    if (params.url.startsWith('http:')) {\n      options = {\n        path: parsedUrl.href,\n        host: parsedProxyURL.hostname,\n        port: parsedProxyURL.port,\n        headers: options.headers,\n        method: options.method\n      };\n    } else {\n      (parsedProxyURL as any).secureProxy = parsedProxyURL.protocol === 'https:';\n\n      options.agent = new HttpsProxyAgent(parsedProxyURL);\n      options.rejectUnauthorized = false;\n    }\n  }\n\n  let cancelRequest: (e: Error | undefined) => void;\n  const requestCallback = (res: http.IncomingMessage) => {\n    const statusCode = res.statusCode || 0;\n    if (statusCode >= 300 && statusCode < 400 && res.headers.location) {\n      // Close the original socket before following the redirect. Otherwise\n      // it may stay idle and cause a timeout error.\n      request.destroy();\n      cancelRequest = httpRequest({ ...params, url: new URL(res.headers.location, params.url).toString() }, onResponse, onError).cancel;\n    } else {\n      onResponse(res);\n    }\n  };\n  const request = options.protocol === 'https:' ?\n    https.request(options, requestCallback) :\n    http.request(options, requestCallback);\n  request.on('error', onError);\n  if (params.socketTimeout !== undefined) {\n    request.setTimeout(params.socketTimeout, () =>  {\n      onError(new Error(`Request to ${params.url} timed out after ${params.socketTimeout}ms`));\n      request.abort();\n    });\n  }\n  cancelRequest = e => {\n    try {\n      request.destroy(e);\n    } catch {\n    }\n  };\n  request.end(params.data);\n  return { cancel: e => cancelRequest(e) };\n}\n\nexport async function fetchData(progress: Progress | undefined, params: HTTPRequestParams, onError?: (params: HTTPRequestParams, response: http.IncomingMessage) => Promise<Error>): Promise<string> {\n  const promise = new ManualPromise<string>();\n  const { cancel } = httpRequest(params, async response => {\n    if (response.statusCode !== 200) {\n      const error = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);\n      promise.reject(error);\n      return;\n    }\n    let body = '';\n    response.on('data', (chunk: string) => body += chunk);\n    response.on('error', (error: any) => promise.reject(error));\n    response.on('end', () => promise.resolve(body));\n  }, error => promise.reject(error));\n  if (!progress)\n    return promise;\n  try {\n    return await progress.race(promise);\n  } catch (error) {\n    cancel(error);\n    throw error;\n  }\n}\n\nfunction shouldBypassProxy(url: URL, bypass?: string): boolean {\n  if (!bypass)\n    return false;\n  const domains = bypass.split(',').map(s => {\n    s = s.trim();\n    if (!s.startsWith('.'))\n      s = '.' + s;\n    return s;\n  });\n  const domain = '.' + url.hostname;\n  return domains.some(d => domain.endsWith(d));\n}\n\nexport function createProxyAgent(proxy?: ProxySettings, forUrl?: URL) {\n  if (!proxy)\n    return;\n  if (forUrl && proxy.bypass && shouldBypassProxy(forUrl, proxy.bypass))\n    return;\n\n  // Browsers allow to specify proxy without a protocol, defaulting to http.\n  let proxyServer = proxy.server.trim();\n  if (!/^\\w+:\\/\\//.test(proxyServer))\n    proxyServer = 'http://' + proxyServer;\n\n  const proxyOpts = url.parse(proxyServer);\n  if (proxyOpts.protocol?.startsWith('socks')) {\n    return new SocksProxyAgent({\n      host: proxyOpts.hostname,\n      port: proxyOpts.port || undefined,\n    });\n  }\n  if (proxy.username)\n    proxyOpts.auth = `${proxy.username}:${proxy.password || ''}`;\n\n  if (forUrl && ['ws:', 'wss:'].includes(forUrl.protocol)) {\n    // Force CONNECT method for WebSockets.\n    return new HttpsProxyAgent(proxyOpts);\n  }\n\n  // TODO: We should use HttpProxyAgent conditional on proxyOpts.protocol instead of always using CONNECT method.\n  return new HttpsProxyAgent(proxyOpts);\n}\n\nexport function createHttpServer(requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): http.Server;\nexport function createHttpServer(options: http.ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): http.Server;\nexport function createHttpServer(...args: any[]): http.Server {\n  const server = http.createServer(...args);\n  decorateServer(server);\n  return server;\n}\n\nexport function createHttpsServer(requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): https.Server;\nexport function createHttpsServer(options: https.ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): https.Server;\nexport function createHttpsServer(...args: any[]): https.Server {\n  const server = https.createServer(...args);\n  decorateServer(server);\n  return server;\n}\n\nexport function createHttp2Server(onRequestHandler?: (request: http2.Http2ServerRequest, response: http2.Http2ServerResponse) => void,): http2.Http2SecureServer;\nexport function createHttp2Server(options: http2.SecureServerOptions, onRequestHandler?: (request: http2.Http2ServerRequest, response: http2.Http2ServerResponse) => void,): http2.Http2SecureServer;\nexport function createHttp2Server(...args: any[]): http2.Http2SecureServer {\n  const server = http2.createSecureServer(...args);\n  decorateServer(server);\n  return server;\n}\n\nexport async function isURLAvailable(url: URL, ignoreHTTPSErrors: boolean, onLog?: (data: string) => void, onStdErr?: (data: string) => void) {\n  let statusCode = await httpStatusCode(url, ignoreHTTPSErrors, onLog, onStdErr);\n  if (statusCode === 404 && url.pathname === '/') {\n    const indexUrl = new URL(url);\n    indexUrl.pathname = '/index.html';\n    statusCode = await httpStatusCode(indexUrl, ignoreHTTPSErrors, onLog, onStdErr);\n  }\n  return statusCode >= 200 && statusCode < 404;\n}\n\nasync function httpStatusCode(url: URL, ignoreHTTPSErrors: boolean, onLog?: (data: string) => void, onStdErr?: (data: string) => void): Promise<number> {\n  return new Promise(resolve => {\n    onLog?.(`HTTP GET: ${url}`);\n    httpRequest({\n      url: url.toString(),\n      headers: { Accept: '*/*' },\n      rejectUnauthorized: !ignoreHTTPSErrors\n    }, res => {\n      res.resume();\n      const statusCode = res.statusCode ?? 0;\n      onLog?.(`HTTP Status: ${statusCode}`);\n      resolve(statusCode);\n    }, error => {\n      if ((error as NodeJS.ErrnoException).code === 'DEPTH_ZERO_SELF_SIGNED_CERT')\n        onStdErr?.(`[WebServer] Self-signed certificate detected. Try adding ignoreHTTPSErrors: true to config.webServer.`);\n      onLog?.(`Error while checking if ${url} is available: ${error.message}`);\n      resolve(0);\n    });\n  });\n}\n\nfunction decorateServer(server: net.Server) {\n  const sockets = new Set<net.Socket>();\n  server.on('connection', socket => {\n    sockets.add(socket);\n    socket.once('close', () => sockets.delete(socket));\n  });\n\n  const close = server.close;\n  server.close = (callback?: (err?: Error) => void) => {\n    for (const socket of sockets)\n      socket.destroy();\n    sockets.clear();\n    return close.call(server, callback);\n  };\n}\n"],
  "mappings": "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",
  "names": ["url", "https", "http", "http2"]
}

{
  "version": 3,
  "sources": ["../../../src/server/utils/socksProxy.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport EventEmitter from 'events';\nimport net from 'net';\n\nimport { assert } from '../../utils/isomorphic/assert';\nimport { createGuid } from './crypto';\nimport { debugLogger } from './debugLogger';\nimport { createSocket } from './happyEyeballs';\n\nimport type { AddressInfo } from 'net';\n\n// https://tools.ietf.org/html/rfc1928\n\nenum SocksAuth {\n  NO_AUTHENTICATION_REQUIRED = 0x00,\n  GSSAPI = 0x01,\n  USERNAME_PASSWORD = 0x02,\n  NO_ACCEPTABLE_METHODS = 0xFF\n}\n\nenum SocksAddressType {\n  IPv4 = 0x01,\n  FqName = 0x03,\n  IPv6 = 0x04\n}\n\nenum SocksCommand {\n  CONNECT = 0x01,\n  BIND = 0x02,\n  UDP_ASSOCIATE = 0x03\n}\n\nenum SocksReply {\n  Succeeded = 0x00,\n  GeneralServerFailure = 0x01,\n  NotAllowedByRuleSet = 0x02,\n  NetworkUnreachable = 0x03,\n  HostUnreachable = 0x04,\n  ConnectionRefused = 0x05,\n  TtlExpired = 0x06,\n  CommandNotSupported = 0x07,\n  AddressTypeNotSupported = 0x08\n}\n\nexport type SocksSocketRequestedPayload = { uid: string, host: string, port: number };\nexport type SocksSocketConnectedPayload = { uid: string, host: string, port: number };\nexport type SocksSocketDataPayload = { uid: string, data: Buffer };\nexport type SocksSocketErrorPayload = { uid: string, error: string };\nexport type SocksSocketFailedPayload = { uid: string, errorCode: string };\nexport type SocksSocketClosedPayload = { uid: string };\nexport type SocksSocketEndPayload = { uid: string };\n\ninterface SocksConnectionClient {\n  onSocketRequested(payload: SocksSocketRequestedPayload): void;\n  onSocketData(payload: SocksSocketDataPayload): void;\n  onSocketClosed(payload: SocksSocketClosedPayload): void;\n}\n\nclass SocksConnection {\n  private _buffer = Buffer.from([]);\n  private _offset = 0;\n  private _fence = 0;\n  private _fenceCallback: (() => void) | undefined;\n  private _socket: net.Socket;\n  private _boundOnData: (buffer: Buffer) => void;\n  private _uid: string;\n  private _client: SocksConnectionClient;\n\n  constructor(uid: string, socket: net.Socket, client: SocksConnectionClient) {\n    this._uid = uid;\n    this._socket = socket;\n    this._client = client;\n    this._boundOnData = this._onData.bind(this);\n    socket.on('data', this._boundOnData);\n    socket.on('close', () => this._onClose());\n    socket.on('end', () => this._onClose());\n    socket.on('error', () => this._onClose());\n    this._run().catch(() => this._socket.end());\n  }\n\n  async _run() {\n    assert(await this._authenticate());\n    const { command, host, port } = await this._parseRequest();\n    if (command !== SocksCommand.CONNECT) {\n      this._writeBytes(Buffer.from([\n        0x05,\n        SocksReply.CommandNotSupported,\n        0x00, // RSV\n        0x01, // IPv4\n        0x00, 0x00, 0x00, 0x00, // Address\n        0x00, 0x00 // Port\n      ]));\n      return;\n    }\n\n    this._socket.off('data', this._boundOnData);\n    this._client.onSocketRequested({ uid: this._uid, host, port });\n  }\n\n  async _authenticate(): Promise<boolean> {\n    // Request:\n    // +----+----------+----------+\n    // |VER | NMETHODS | METHODS  |\n    // +----+----------+----------+\n    // | 1  |    1     | 1 to 255 |\n    // +----+----------+----------+\n\n    // Response:\n    // +----+--------+\n    // |VER | METHOD |\n    // +----+--------+\n    // | 1  |   1    |\n    // +----+--------+\n\n    const version = await this._readByte();\n    assert(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);\n\n    const nMethods = await this._readByte();\n    assert(nMethods, 'No authentication methods specified');\n\n    const methods = await this._readBytes(nMethods);\n    for (const method of methods) {\n      if (method === 0) {\n        this._writeBytes(Buffer.from([version, method]));\n        return true;\n      }\n    }\n    this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));\n    return false;\n  }\n\n  async _parseRequest(): Promise<{ host: string, port: number, command: SocksCommand }> {\n    // Request.\n    // +----+-----+-------+------+----------+----------+\n    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n    // +----+-----+-------+------+----------+----------+\n    // | 1  |  1  | X'00' |  1   | Variable |    2     |\n    // +----+-----+-------+------+----------+----------+\n\n    // Response.\n    // +----+-----+-------+------+----------+----------+\n    // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n    // +----+-----+-------+------+----------+----------+\n    // | 1  |  1  | X'00' |  1   | Variable |    2     |\n    // +----+-----+-------+------+----------+----------+\n\n    const version = await this._readByte();\n    assert(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);\n\n    const command = await this._readByte();\n    await this._readByte();  // skip reserved.\n    const addressType = await this._readByte();\n    let host = '';\n    switch (addressType) {\n      case SocksAddressType.IPv4:\n        host = (await this._readBytes(4)).join('.');\n        break;\n      case SocksAddressType.FqName:\n        const length = await this._readByte();\n        host = (await this._readBytes(length)).toString();\n        break;\n      case SocksAddressType.IPv6:\n        const bytes = await this._readBytes(16);\n        const tokens: string[] = [];\n        for (let i = 0; i < 8; ++i)\n          tokens.push(bytes.readUInt16BE(i * 2).toString(16));\n        host = tokens.join(':');\n        break;\n    }\n    const port = (await this._readBytes(2)).readUInt16BE(0);\n\n    this._buffer = Buffer.from([]);\n    this._offset = 0;\n    this._fence = 0;\n\n    return {\n      command,\n      host,\n      port\n    };\n  }\n\n  private async _readByte(): Promise<number> {\n    const buffer = await this._readBytes(1);\n    return buffer[0];\n  }\n\n  private async _readBytes(length: number): Promise<Buffer> {\n    this._fence = this._offset + length;\n    if (!this._buffer || this._buffer.length < this._fence)\n      await new Promise<void>(f => this._fenceCallback = f);\n    this._offset += length;\n    return this._buffer.slice(this._offset - length, this._offset);\n  }\n\n  private _writeBytes(buffer: Buffer) {\n    if (this._socket.writable)\n      this._socket.write(buffer);\n  }\n\n  private _onClose() {\n    this._client.onSocketClosed({ uid: this._uid });\n  }\n\n  private _onData(buffer: Buffer) {\n    this._buffer = Buffer.concat([this._buffer, buffer]);\n    if (this._fenceCallback && this._buffer.length >= this._fence) {\n      const callback = this._fenceCallback;\n      this._fenceCallback = undefined;\n      callback();\n    }\n  }\n\n  socketConnected(host: string, port: number) {\n    this._writeBytes(Buffer.from([\n      0x05,\n      SocksReply.Succeeded,\n      0x00, // RSV\n      ...ipToSocksAddress(host), // ATYP, Address\n      port >> 8, port & 0xFF // Port\n    ]));\n    this._socket.on('data', data => this._client.onSocketData({ uid: this._uid, data }));\n  }\n\n  socketFailed(errorCode: string) {\n    const buffer = Buffer.from([\n      0x05,\n      0,\n      0x00, // RSV\n      ...ipToSocksAddress('0.0.0.0'), // ATYP, Address\n      0, 0 // Port\n    ]);\n    switch (errorCode) {\n      case 'ENOENT':\n      case 'ENOTFOUND':\n      case 'ETIMEDOUT':\n      case 'EHOSTUNREACH':\n        buffer[1] = SocksReply.HostUnreachable;\n        break;\n      case 'ENETUNREACH':\n        buffer[1] = SocksReply.NetworkUnreachable;\n        break;\n      case 'ECONNREFUSED':\n        buffer[1] = SocksReply.ConnectionRefused;\n        break;\n      case 'ERULESET':\n        buffer[1] = SocksReply.NotAllowedByRuleSet;\n        break;\n    }\n    this._writeBytes(buffer);\n    this._socket.end();\n  }\n\n  sendData(data: Buffer) {\n    this._socket.write(data);\n  }\n\n  end() {\n    this._socket.end();\n  }\n\n  error(error: string) {\n    this._socket.destroy(new Error(error));\n  }\n}\n\nfunction hexToNumber(hex: string): number {\n  // Note: parseInt has a few issues including ignoring trailing characters and allowing leading 0x.\n  return [...hex].reduce((value, digit) => {\n    const code = digit.charCodeAt(0);\n    if (code >= 48 && code <= 57) // 0..9\n      return value + code;\n    if (code >= 97 && code <= 102) // a..f\n      return value + (code - 97) + 10;\n    if (code >= 65 && code <= 70) // A..F\n      return value + (code - 65) + 10;\n    throw new Error('Invalid IPv6 token ' + hex);\n  }, 0);\n}\n\nfunction ipToSocksAddress(address: string): number[] {\n  if (net.isIPv4(address)) {\n    return [\n      0x01, // IPv4\n      ...address.split('.', 4).map(t => (+t) & 0xFF), // Address\n    ];\n  }\n  if (net.isIPv6(address)) {\n    const result = [0x04]; // IPv6\n    const tokens = address.split(':', 8);\n    while (tokens.length < 8)\n      tokens.unshift('');\n    for (const token of tokens) {\n      const value = hexToNumber(token);\n      result.push((value >> 8) & 0xFF, value & 0xFF);  // Big-endian\n    }\n    return result;\n  }\n  throw new Error('Only IPv4 and IPv6 addresses are supported');\n}\n\ntype PatternMatcher = (host: string, port: number) => boolean;\n\nfunction starMatchToRegex(pattern: string) {\n  const source = pattern.split('*').map(s => {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }).join('.*');\n  return new RegExp('^' + source + '$');\n}\n\n// This follows \"Proxy bypass rules\" syntax without implicit and negative rules.\n// https://source.chromium.org/chromium/chromium/src/+/main:net/docs/proxy.md;l=331\nexport function parsePattern(pattern: string | undefined): PatternMatcher {\n  if (!pattern)\n    return () => false;\n\n  const matchers: PatternMatcher[] = pattern.split(',').map(token => {\n    const match = token.match(/^(.*?)(?::(\\d+))?$/);\n    if (!match)\n      throw new Error(`Unsupported token \"${token}\" in pattern \"${pattern}\"`);\n    const tokenPort = match[2] ? +match[2] : undefined;\n    const portMatches = (port: number) => tokenPort === undefined || tokenPort === port;\n    let tokenHost = match[1];\n\n    if (tokenHost === '<loopback>') {\n      return (host, port) => {\n        if (!portMatches(port))\n          return false;\n        return host === 'localhost'\n            || host.endsWith('.localhost')\n            || host === '127.0.0.1'\n            || host === '[::1]';\n      };\n    }\n\n    if (tokenHost === '*')\n      return (host, port) => portMatches(port);\n\n    if (net.isIPv4(tokenHost) || net.isIPv6(tokenHost))\n      return (host, port) => host === tokenHost && portMatches(port);\n\n    if (tokenHost[0] === '.')\n      tokenHost = '*' + tokenHost;\n    const tokenRegex = starMatchToRegex(tokenHost);\n    return (host, port) => {\n      if (!portMatches(port))\n        return false;\n      if (net.isIPv4(host) || net.isIPv6(host))\n        return false;\n      return !!host.match(tokenRegex);\n    };\n  });\n  return (host, port) => matchers.some(matcher => matcher(host, port));\n}\n\nexport class SocksProxy extends EventEmitter implements SocksConnectionClient {\n  static Events = {\n    SocksRequested: 'socksRequested',\n    SocksData: 'socksData',\n    SocksClosed: 'socksClosed',\n  };\n\n  private _server: net.Server;\n  private _connections = new Map<string, SocksConnection>();\n  private _sockets = new Set<net.Socket>();\n  private _closed = false;\n  private _port: number | undefined;\n  private _patternMatcher: PatternMatcher = () => false;\n  private _directSockets = new Map<string, net.Socket>();\n\n  constructor() {\n    super();\n    this._server = new net.Server((socket: net.Socket) => {\n      const uid = createGuid();\n      const connection = new SocksConnection(uid, socket, this);\n      this._connections.set(uid, connection);\n    });\n    this._server.on('connection', socket => {\n      if (this._closed) {\n        socket.destroy();\n        return;\n      }\n      this._sockets.add(socket);\n      socket.once('close', () => this._sockets.delete(socket));\n    });\n  }\n\n  setPattern(pattern: string | undefined) {\n    try {\n      this._patternMatcher = parsePattern(pattern);\n    } catch (e) {\n      this._patternMatcher = () => false;\n    }\n  }\n\n  private async _handleDirect(request: SocksSocketRequestedPayload) {\n    try {\n      const socket = await createSocket(request.host, request.port);\n      socket.on('data', data => this._connections.get(request.uid)?.sendData(data));\n      socket.on('error', error => {\n        this._connections.get(request.uid)?.error(error.message);\n        this._directSockets.delete(request.uid);\n      });\n      socket.on('end', () => {\n        this._connections.get(request.uid)?.end();\n        this._directSockets.delete(request.uid);\n      });\n      const localAddress = socket.localAddress;\n      const localPort = socket.localPort;\n      this._directSockets.set(request.uid, socket);\n      this._connections.get(request.uid)?.socketConnected(localAddress!, localPort!);\n    } catch (error) {\n      this._connections.get(request.uid)?.socketFailed(error.code);\n    }\n  }\n\n  port() {\n    return this._port;\n  }\n\n  async listen(port: number, hostname?: string): Promise<number> {\n    return new Promise(f => {\n      this._server.listen(port, hostname, () => {\n        const port = (this._server.address() as AddressInfo).port;\n        this._port = port;\n        f(port);\n      });\n    });\n  }\n\n  async close() {\n    if (this._closed)\n      return;\n    this._closed = true;\n    for (const socket of this._sockets)\n      socket.destroy();\n    this._sockets.clear();\n    await new Promise(f => this._server.close(f));\n  }\n\n  onSocketRequested(payload: SocksSocketRequestedPayload) {\n    if (!this._patternMatcher(payload.host, payload.port)) {\n      this._handleDirect(payload);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksRequested, payload);\n  }\n\n  onSocketData(payload: SocksSocketDataPayload): void {\n    const direct = this._directSockets.get(payload.uid);\n    if (direct) {\n      direct.write(payload.data);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksData, payload);\n  }\n\n  onSocketClosed(payload: SocksSocketClosedPayload): void {\n    const direct = this._directSockets.get(payload.uid);\n    if (direct) {\n      direct.destroy();\n      this._directSockets.delete(payload.uid);\n      return;\n    }\n    this.emit(SocksProxy.Events.SocksClosed, payload);\n  }\n\n  socketConnected({ uid, host, port }: SocksSocketConnectedPayload) {\n    this._connections.get(uid)?.socketConnected(host, port);\n  }\n\n  socketFailed({ uid, errorCode }: SocksSocketFailedPayload) {\n    this._connections.get(uid)?.socketFailed(errorCode);\n  }\n\n  sendSocketData({ uid, data }: SocksSocketDataPayload) {\n    this._connections.get(uid)?.sendData(data);\n  }\n\n  sendSocketEnd({ uid }: SocksSocketEndPayload) {\n    this._connections.get(uid)?.end();\n  }\n\n  sendSocketError({ uid, error }: SocksSocketErrorPayload) {\n    this._connections.get(uid)?.error(error);\n  }\n}\n\nexport class SocksProxyHandler extends EventEmitter {\n  static Events = {\n    SocksConnected: 'socksConnected',\n    SocksData: 'socksData',\n    SocksError: 'socksError',\n    SocksFailed: 'socksFailed',\n    SocksEnd: 'socksEnd',\n  };\n\n  private _sockets = new Map<string, net.Socket>();\n  private _patternMatcher: PatternMatcher = () => false;\n  private _redirectPortForTest: number | undefined;\n\n  constructor(pattern: string | undefined, redirectPortForTest?: number) {\n    super();\n    this._patternMatcher = parsePattern(pattern);\n    this._redirectPortForTest = redirectPortForTest;\n  }\n\n  cleanup() {\n    for (const uid of this._sockets.keys())\n      this.socketClosed({ uid });\n  }\n\n  async socketRequested({ uid, host, port }: SocksSocketRequestedPayload): Promise<void> {\n    debugLogger.log('socks', `[${uid}] => request ${host}:${port}`);\n    if (!this._patternMatcher(host, port)) {\n      const payload: SocksSocketFailedPayload = { uid, errorCode: 'ERULESET' };\n      debugLogger.log('socks', `[${uid}] <= pattern error ${payload.errorCode}`);\n      this.emit(SocksProxyHandler.Events.SocksFailed, payload);\n      return;\n    }\n\n    if (host === 'local.playwright')\n      host = 'localhost';\n    try {\n      if (this._redirectPortForTest)\n        port = this._redirectPortForTest;\n      const socket = await createSocket(host, port);\n      socket.on('data', data => {\n        const payload: SocksSocketDataPayload = { uid, data };\n        this.emit(SocksProxyHandler.Events.SocksData, payload);\n      });\n      socket.on('error', error => {\n        const payload: SocksSocketErrorPayload = { uid, error: error.message };\n        debugLogger.log('socks', `[${uid}] <= network socket error ${payload.error}`);\n        this.emit(SocksProxyHandler.Events.SocksError, payload);\n        this._sockets.delete(uid);\n      });\n      socket.on('end', () => {\n        const payload: SocksSocketEndPayload = { uid };\n        debugLogger.log('socks', `[${uid}] <= network socket closed`);\n        this.emit(SocksProxyHandler.Events.SocksEnd, payload);\n        this._sockets.delete(uid);\n      });\n      const localAddress = socket.localAddress;\n      const localPort = socket.localPort;\n      this._sockets.set(uid, socket);\n      const payload: SocksSocketConnectedPayload = { uid, host: localAddress!, port: localPort! };\n      debugLogger.log('socks', `[${uid}] <= connected to network ${payload.host}:${payload.port}`);\n      this.emit(SocksProxyHandler.Events.SocksConnected, payload);\n    } catch (error) {\n      const payload: SocksSocketFailedPayload = { uid, errorCode: error.code };\n      debugLogger.log('socks', `[${uid}] <= connect error ${payload.errorCode}`);\n      this.emit(SocksProxyHandler.Events.SocksFailed, payload);\n    }\n  }\n\n  sendSocketData({ uid, data }: SocksSocketDataPayload): void {\n    this._sockets.get(uid)?.write(data);\n  }\n\n  socketClosed({ uid }: SocksSocketClosedPayload): void {\n    debugLogger.log('socks', `[${uid}] <= browser socket closed`);\n    this._sockets.get(uid)?.destroy();\n    this._sockets.delete(uid);\n  }\n}\n"],
  "mappings": "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",
  "names": ["SocksAuth", "SocksAddressType", "SocksCommand", "SocksReply", "net", "EventEmitter", "port", "payload"]
}

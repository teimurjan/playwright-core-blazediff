{
  "version": 3,
  "sources": ["../../../src/server/android/backendAdb.ts"],
  "sourcesContent": ["/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from 'events';\nimport net from 'net';\n\nimport { assert } from '../../utils/isomorphic/assert';\nimport { debug } from '../../utilsBundle';\n\nimport type { Backend, DeviceBackend, SocketBackend } from './android';\nimport type * as channels from '@protocol/channels';\n\n\nexport class AdbBackend implements Backend {\n  async devices(options: channels.AndroidDevicesOptions = {}): Promise<DeviceBackend[]> {\n    const result = await runCommand('host:devices', options.host, options.port);\n    const lines = result.toString().trim().split('\\n');\n    return lines.map(line => {\n      const [serial, status] = line.trim().split('\\t');\n      return new AdbDevice(serial, status, options.host, options.port);\n    });\n  }\n}\n\nclass AdbDevice implements DeviceBackend {\n  serial: string;\n  status: string;\n  host: string | undefined;\n  port: number | undefined;\n  private _closed = false;\n\n  constructor(serial: string, status: string, host?: string, port?: number) {\n    this.serial = serial;\n    this.status = status;\n    this.host = host;\n    this.port = port;\n  }\n\n  async init() {\n  }\n\n  async close() {\n    this._closed = true;\n  }\n\n  runCommand(command: string): Promise<Buffer> {\n    if (this._closed)\n      throw new Error('Device is closed');\n    return runCommand(command, this.host, this.port, this.serial);\n  }\n\n  async open(command: string): Promise<SocketBackend> {\n    if (this._closed)\n      throw new Error('Device is closed');\n    const result = await open(command, this.host, this.port, this.serial);\n    result.becomeSocket();\n    return result;\n  }\n}\n\nasync function runCommand(command: string, host: string = '127.0.0.1', port: number = 5037, serial?: string): Promise<Buffer> {\n  debug('pw:adb:runCommand')(command, serial);\n  const socket = new BufferedSocketWrapper(command, net.createConnection({ host, port }));\n  try {\n    if (serial) {\n      await socket.write(encodeMessage(`host:transport:${serial}`));\n      const status = await socket.read(4);\n      assert(status.toString() === 'OKAY', status.toString());\n    }\n    await socket.write(encodeMessage(command));\n    const status = await socket.read(4);\n    assert(status.toString() === 'OKAY', status.toString());\n    let commandOutput: Buffer;\n    if (!command.startsWith('shell:')) {\n      const remainingLength = parseInt((await socket.read(4)).toString(), 16);\n      commandOutput = await socket.read(remainingLength);\n    } else {\n      commandOutput = await socket.readAll();\n    }\n    return commandOutput;\n  } finally {\n    socket.close();\n  }\n}\n\nasync function open(command: string, host: string = '127.0.0.1', port: number = 5037, serial?: string): Promise<BufferedSocketWrapper> {\n  const socket = new BufferedSocketWrapper(command, net.createConnection({ host, port }));\n  if (serial) {\n    await socket.write(encodeMessage(`host:transport:${serial}`));\n    const status = await socket.read(4);\n    assert(status.toString() === 'OKAY', status.toString());\n  }\n  await socket.write(encodeMessage(command));\n  const status = await socket.read(4);\n  assert(status.toString() === 'OKAY', status.toString());\n  return socket;\n}\n\nfunction encodeMessage(message: string): Buffer {\n  let lenHex = (message.length).toString(16);\n  lenHex = '0'.repeat(4 - lenHex.length) + lenHex;\n  return Buffer.from(lenHex + message);\n}\n\nclass BufferedSocketWrapper extends EventEmitter implements SocketBackend {\n  private _socket: net.Socket;\n  private _buffer = Buffer.from([]);\n  private _isSocket = false;\n  private _notifyReader: (() => void) | undefined;\n  private _connectPromise: Promise<void>;\n  private _isClosed = false;\n  private _command: string;\n\n  constructor(command: string, socket: net.Socket) {\n    super();\n    this._command = command;\n    this._socket = socket;\n    this._connectPromise = new Promise(f => this._socket.on('connect', f));\n    this._socket.on('data', data => {\n      debug('pw:adb:data')(data.toString());\n      if (this._isSocket) {\n        this.emit('data', data);\n        return;\n      }\n      this._buffer = Buffer.concat([this._buffer, data]);\n      if (this._notifyReader)\n        this._notifyReader();\n    });\n    this._socket.on('close', () => {\n      this._isClosed = true;\n      if (this._notifyReader)\n        this._notifyReader();\n      this.close();\n      this.emit('close');\n    });\n    this._socket.on('error', error => this.emit('error', error));\n  }\n\n  async write(data: Buffer) {\n    debug('pw:adb:send')(data.toString().substring(0, 100) + '...');\n    await this._connectPromise;\n    await new Promise(f => this._socket.write(data, f));\n  }\n\n  close() {\n    if (this._isClosed)\n      return;\n    debug('pw:adb')('Close ' + this._command);\n    this._socket.destroy();\n  }\n\n  async read(length: number): Promise<Buffer> {\n    await this._connectPromise;\n    assert(!this._isSocket, 'Can not read by length in socket mode');\n    while (this._buffer.length < length)\n      await new Promise<void>(f => this._notifyReader = f);\n    const result = this._buffer.slice(0, length);\n    this._buffer = this._buffer.slice(length);\n    debug('pw:adb:recv')(result.toString().substring(0, 100) + '...');\n    return result;\n  }\n\n  async readAll(): Promise<Buffer> {\n    while (!this._isClosed)\n      await new Promise<void>(f => this._notifyReader = f);\n    return this._buffer;\n  }\n\n  becomeSocket() {\n    assert(!this._buffer.length);\n    this._isSocket = true;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,oBAA6B;AAC7B,iBAAgB;AAEhB,oBAAuB;AACvB,yBAAsB;AAMf,MAAM,WAA8B;AAAA,EACzC,MAAM,QAAQ,UAA0C,CAAC,GAA6B;AACpF,UAAM,SAAS,MAAM,WAAW,gBAAgB,QAAQ,MAAM,QAAQ,IAAI;AAC1E,UAAM,QAAQ,OAAO,SAAS,EAAE,KAAK,EAAE,MAAM,IAAI;AACjD,WAAO,MAAM,IAAI,UAAQ;AACvB,YAAM,CAAC,QAAQ,MAAM,IAAI,KAAK,KAAK,EAAE,MAAM,GAAI;AAC/C,aAAO,IAAI,UAAU,QAAQ,QAAQ,QAAQ,MAAM,QAAQ,IAAI;AAAA,IACjE,CAAC;AAAA,EACH;AACF;AAEA,MAAM,UAAmC;AAAA,EAOvC,YAAY,QAAgB,QAAgB,MAAe,MAAe;AAF1E,SAAQ,UAAU;AAGhB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAM,OAAO;AAAA,EACb;AAAA,EAEA,MAAM,QAAQ;AACZ,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,WAAW,SAAkC;AAC3C,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,kBAAkB;AACpC,WAAO,WAAW,SAAS,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM;AAAA,EAC9D;AAAA,EAEA,MAAM,KAAK,SAAyC;AAClD,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,kBAAkB;AACpC,UAAM,SAAS,MAAM,KAAK,SAAS,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM;AACpE,WAAO,aAAa;AACpB,WAAO;AAAA,EACT;AACF;AAEA,eAAe,WAAW,SAAiB,OAAe,aAAa,OAAe,MAAM,QAAkC;AAC5H,gCAAM,mBAAmB,EAAE,SAAS,MAAM;AAC1C,QAAM,SAAS,IAAI,sBAAsB,SAAS,WAAAA,QAAI,iBAAiB,EAAE,MAAM,KAAK,CAAC,CAAC;AACtF,MAAI;AACF,QAAI,QAAQ;AACV,YAAM,OAAO,MAAM,cAAc,kBAAkB,MAAM,EAAE,CAAC;AAC5D,YAAMC,UAAS,MAAM,OAAO,KAAK,CAAC;AAClC,gCAAOA,QAAO,SAAS,MAAM,QAAQA,QAAO,SAAS,CAAC;AAAA,IACxD;AACA,UAAM,OAAO,MAAM,cAAc,OAAO,CAAC;AACzC,UAAM,SAAS,MAAM,OAAO,KAAK,CAAC;AAClC,8BAAO,OAAO,SAAS,MAAM,QAAQ,OAAO,SAAS,CAAC;AACtD,QAAI;AACJ,QAAI,CAAC,QAAQ,WAAW,QAAQ,GAAG;AACjC,YAAM,kBAAkB,UAAU,MAAM,OAAO,KAAK,CAAC,GAAG,SAAS,GAAG,EAAE;AACtE,sBAAgB,MAAM,OAAO,KAAK,eAAe;AAAA,IACnD,OAAO;AACL,sBAAgB,MAAM,OAAO,QAAQ;AAAA,IACvC;AACA,WAAO;AAAA,EACT,UAAE;AACA,WAAO,MAAM;AAAA,EACf;AACF;AAEA,eAAe,KAAK,SAAiB,OAAe,aAAa,OAAe,MAAM,QAAiD;AACrI,QAAM,SAAS,IAAI,sBAAsB,SAAS,WAAAD,QAAI,iBAAiB,EAAE,MAAM,KAAK,CAAC,CAAC;AACtF,MAAI,QAAQ;AACV,UAAM,OAAO,MAAM,cAAc,kBAAkB,MAAM,EAAE,CAAC;AAC5D,UAAMC,UAAS,MAAM,OAAO,KAAK,CAAC;AAClC,8BAAOA,QAAO,SAAS,MAAM,QAAQA,QAAO,SAAS,CAAC;AAAA,EACxD;AACA,QAAM,OAAO,MAAM,cAAc,OAAO,CAAC;AACzC,QAAM,SAAS,MAAM,OAAO,KAAK,CAAC;AAClC,4BAAO,OAAO,SAAS,MAAM,QAAQ,OAAO,SAAS,CAAC;AACtD,SAAO;AACT;AAEA,SAAS,cAAc,SAAyB;AAC9C,MAAI,SAAU,QAAQ,OAAQ,SAAS,EAAE;AACzC,WAAS,IAAI,OAAO,IAAI,OAAO,MAAM,IAAI;AACzC,SAAO,OAAO,KAAK,SAAS,OAAO;AACrC;AAEA,MAAM,8BAA8B,2BAAsC;AAAA,EASxE,YAAY,SAAiB,QAAoB;AAC/C,UAAM;AARR,SAAQ,UAAU,OAAO,KAAK,CAAC,CAAC;AAChC,SAAQ,YAAY;AAGpB,SAAQ,YAAY;AAKlB,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,kBAAkB,IAAI,QAAQ,OAAK,KAAK,QAAQ,GAAG,WAAW,CAAC,CAAC;AACrE,SAAK,QAAQ,GAAG,QAAQ,UAAQ;AAC9B,oCAAM,aAAa,EAAE,KAAK,SAAS,CAAC;AACpC,UAAI,KAAK,WAAW;AAClB,aAAK,KAAK,QAAQ,IAAI;AACtB;AAAA,MACF;AACA,WAAK,UAAU,OAAO,OAAO,CAAC,KAAK,SAAS,IAAI,CAAC;AACjD,UAAI,KAAK;AACP,aAAK,cAAc;AAAA,IACvB,CAAC;AACD,SAAK,QAAQ,GAAG,SAAS,MAAM;AAC7B,WAAK,YAAY;AACjB,UAAI,KAAK;AACP,aAAK,cAAc;AACrB,WAAK,MAAM;AACX,WAAK,KAAK,OAAO;AAAA,IACnB,CAAC;AACD,SAAK,QAAQ,GAAG,SAAS,WAAS,KAAK,KAAK,SAAS,KAAK,CAAC;AAAA,EAC7D;AAAA,EAEA,MAAM,MAAM,MAAc;AACxB,kCAAM,aAAa,EAAE,KAAK,SAAS,EAAE,UAAU,GAAG,GAAG,IAAI,KAAK;AAC9D,UAAM,KAAK;AACX,UAAM,IAAI,QAAQ,OAAK,KAAK,QAAQ,MAAM,MAAM,CAAC,CAAC;AAAA,EACpD;AAAA,EAEA,QAAQ;AACN,QAAI,KAAK;AACP;AACF,kCAAM,QAAQ,EAAE,WAAW,KAAK,QAAQ;AACxC,SAAK,QAAQ,QAAQ;AAAA,EACvB;AAAA,EAEA,MAAM,KAAK,QAAiC;AAC1C,UAAM,KAAK;AACX,8BAAO,CAAC,KAAK,WAAW,uCAAuC;AAC/D,WAAO,KAAK,QAAQ,SAAS;AAC3B,YAAM,IAAI,QAAc,OAAK,KAAK,gBAAgB,CAAC;AACrD,UAAM,SAAS,KAAK,QAAQ,MAAM,GAAG,MAAM;AAC3C,SAAK,UAAU,KAAK,QAAQ,MAAM,MAAM;AACxC,kCAAM,aAAa,EAAE,OAAO,SAAS,EAAE,UAAU,GAAG,GAAG,IAAI,KAAK;AAChE,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,UAA2B;AAC/B,WAAO,CAAC,KAAK;AACX,YAAM,IAAI,QAAc,OAAK,KAAK,gBAAgB,CAAC;AACrD,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,eAAe;AACb,8BAAO,CAAC,KAAK,QAAQ,MAAM;AAC3B,SAAK,YAAY;AAAA,EACnB;AACF;",
  "names": ["net", "status"]
}

{
  "version": 3,
  "sources": ["../../src/server/localUtils.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport { calculateSha1 } from './utils/crypto';\nimport { HarBackend } from './harBackend';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\nimport { ZipFile } from './utils/zipFile';\nimport { yauzl, yazl } from '../zipBundle';\nimport { serializeClientSideCallMetadata } from '../utils/isomorphic/traceUtils';\nimport { assert } from '../utils/isomorphic/assert';\nimport { removeFolders } from './utils/fileUtils';\n\nimport type * as channels from '@protocol/channels';\nimport type * as har from '@trace/har';\nimport type EventEmitter from 'events';\nimport type { Progress } from '@protocol/progress';\n\n\nexport type StackSession = {\n  file: string;\n  writer: Promise<void>;\n  tmpDir: string | undefined;\n  callStacks: channels.ClientSideCallMetadata[];\n};\n\nexport async function zip(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsZipParams): Promise<void> {\n  const promise = new ManualPromise<void>();\n  const zipFile = new yazl.ZipFile();\n  (zipFile as any as EventEmitter).on('error', error => promise.reject(error));\n\n  const addFile = (file: string, name: string) => {\n    try {\n      if (fs.statSync(file).isFile())\n        zipFile.addFile(file, name);\n    } catch (e) {\n    }\n  };\n\n  for (const entry of params.entries)\n    addFile(entry.value, entry.name);\n\n  // Add stacks and the sources.\n  const stackSession = params.stacksId ? stackSessions.get(params.stacksId) : undefined;\n  if (stackSession?.callStacks.length) {\n    await progress.race(stackSession.writer);\n    if (process.env.PW_LIVE_TRACE_STACKS) {\n      zipFile.addFile(stackSession.file, 'trace.stacks');\n    } else {\n      const buffer = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(stackSession.callStacks)));\n      zipFile.addBuffer(buffer, 'trace.stacks');\n    }\n  }\n\n  // Collect sources from stacks.\n  if (params.includeSources) {\n    const sourceFiles = new Set<string>();\n    for (const { stack } of stackSession?.callStacks || []) {\n      if (!stack)\n        continue;\n      for (const { file } of stack)\n        sourceFiles.add(file);\n    }\n    for (const sourceFile of sourceFiles)\n      addFile(sourceFile, 'resources/src@' + await calculateSha1(sourceFile) + '.txt');\n  }\n\n  if (params.mode === 'write') {\n    // New file, just compress the entries.\n    await progress.race(fs.promises.mkdir(path.dirname(params.zipFile), { recursive: true }));\n    zipFile.end(undefined, () => {\n      zipFile.outputStream.pipe(fs.createWriteStream(params.zipFile))\n          .on('close', () => promise.resolve())\n          .on('error', error => promise.reject(error));\n    });\n    await progress.race(promise);\n    await deleteStackSession(progress, stackSessions, params.stacksId);\n    return;\n  }\n\n  // File already exists. Repack and add new entries.\n  const tempFile = params.zipFile + '.tmp';\n  await progress.race(fs.promises.rename(params.zipFile, tempFile));\n\n  yauzl.open(tempFile, (err, inZipFile) => {\n    if (err) {\n      promise.reject(err);\n      return;\n    }\n    assert(inZipFile);\n    let pendingEntries = inZipFile.entryCount;\n    inZipFile.on('entry', entry => {\n      inZipFile.openReadStream(entry, (err, readStream) => {\n        if (err) {\n          promise.reject(err);\n          return;\n        }\n        zipFile.addReadStream(readStream!, entry.fileName);\n        if (--pendingEntries === 0) {\n          zipFile.end(undefined, () => {\n            zipFile.outputStream.pipe(fs.createWriteStream(params.zipFile)).on('close', () => {\n              fs.promises.unlink(tempFile).then(() => {\n                promise.resolve();\n              }).catch(error => promise.reject(error));\n            });\n          });\n        }\n      });\n    });\n  });\n  await progress.race(promise);\n  await deleteStackSession(progress, stackSessions, params.stacksId);\n}\n\nasync function deleteStackSession(progress: Progress, stackSessions: Map<string, StackSession>, stacksId?: string) {\n  const session = stacksId ? stackSessions.get(stacksId) : undefined;\n  if (!session)\n    return;\n  stackSessions.delete(stacksId!);\n  if (session.tmpDir)\n    await progress.race(removeFolders([session.tmpDir]));\n}\n\nexport async function harOpen(progress: Progress, harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarOpenParams): Promise<channels.LocalUtilsHarOpenResult> {\n  let harBackend: HarBackend;\n  if (params.file.endsWith('.zip')) {\n    const zipFile = new ZipFile(params.file);\n    try {\n      const entryNames = await progress.race(zipFile.entries());\n      const harEntryName = entryNames.find(e => e.endsWith('.har'));\n      if (!harEntryName)\n        return { error: 'Specified archive does not have a .har file' };\n      const har = await progress.race(zipFile.read(harEntryName));\n      const harFile = JSON.parse(har.toString()) as har.HARFile;\n      harBackend = new HarBackend(harFile, null, zipFile);\n    } catch (error) {\n      zipFile.close();\n      throw error;\n    }\n  } else {\n    const harFile = JSON.parse(await progress.race(fs.promises.readFile(params.file, 'utf-8'))) as har.HARFile;\n    harBackend = new HarBackend(harFile, path.dirname(params.file), null);\n  }\n  harBackends.set(harBackend.id, harBackend);\n  return { harId: harBackend.id };\n}\n\nexport async function harLookup(progress: Progress, harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarLookupParams): Promise<channels.LocalUtilsHarLookupResult> {\n  const harBackend = harBackends.get(params.harId);\n  if (!harBackend)\n    return { action: 'error', message: `Internal error: har was not opened` };\n  return await progress.race(harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest));\n}\n\nexport function harClose(harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarCloseParams) {\n  const harBackend = harBackends.get(params.harId);\n  if (harBackend) {\n    harBackends.delete(harBackend.id);\n    harBackend.dispose();\n  }\n}\n\nexport async function harUnzip(progress: Progress, params: channels.LocalUtilsHarUnzipParams): Promise<void> {\n  const dir = path.dirname(params.zipFile);\n  const zipFile = new ZipFile(params.zipFile);\n  try {\n    for (const entry of await progress.race(zipFile.entries())) {\n      const buffer = await progress.race(zipFile.read(entry));\n      if (entry === 'har.har')\n        await progress.race(fs.promises.writeFile(params.harFile, buffer));\n      else\n        await progress.race(fs.promises.writeFile(path.join(dir, entry), buffer));\n    }\n    await progress.race(fs.promises.unlink(params.zipFile));\n  } finally {\n    zipFile.close();\n  }\n}\n\nexport async function tracingStarted(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsTracingStartedParams): Promise<channels.LocalUtilsTracingStartedResult> {\n  let tmpDir = undefined;\n  if (!params.tracesDir)\n    tmpDir = await progress.race(fs.promises.mkdtemp(path.join(os.tmpdir(), 'playwright-tracing-')));\n  const traceStacksFile = path.join(params.tracesDir || tmpDir!, params.traceName + '.stacks');\n  stackSessions.set(traceStacksFile, { callStacks: [], file: traceStacksFile, writer: Promise.resolve(), tmpDir });\n  return { stacksId: traceStacksFile };\n}\n\nexport async function traceDiscarded(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsTraceDiscardedParams): Promise<void> {\n  await deleteStackSession(progress, stackSessions, params.stacksId);\n}\n\nexport function addStackToTracingNoReply(stackSessions: Map<string, StackSession>, params: channels.LocalUtilsAddStackToTracingNoReplyParams) {\n  for (const session of stackSessions.values()) {\n    session.callStacks.push(params.callData);\n    if (process.env.PW_LIVE_TRACE_STACKS) {\n      session.writer = session.writer.then(() => {\n        const buffer = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(session.callStacks)));\n        return fs.promises.writeFile(session.file, buffer);\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["fs", "path", "err", "os"]
}

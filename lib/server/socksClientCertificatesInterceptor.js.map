{
  "version": 3,
  "sources": ["../../src/server/socksClientCertificatesInterceptor.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from 'events';\nimport http2 from 'http2';\nimport net from 'net';\nimport stream from 'stream';\nimport tls from 'tls';\n\nimport { SocksProxy } from './utils/socksProxy';\nimport { escapeHTML, generateSelfSignedCertificate, rewriteErrorMessage } from '../utils';\nimport { verifyClientCertificates } from './browserContext';\nimport { createProxyAgent } from './utils/network';\nimport { debugLogger } from './utils/debugLogger';\nimport { createSocket } from './utils/happyEyeballs';\nimport { getProxyForUrl } from '../utilsBundle';\n\nimport type * as types from './types';\nimport type { SocksSocketClosedPayload, SocksSocketDataPayload, SocksSocketRequestedPayload } from './utils/socksProxy';\nimport type https from 'https';\nimport type { Progress } from '@protocol/progress';\n\nlet dummyServerTlsOptions: tls.TlsOptions | undefined = undefined;\nfunction loadDummyServerCertsIfNeeded() {\n  if (dummyServerTlsOptions)\n    return;\n  const { cert, key } = generateSelfSignedCertificate();\n  dummyServerTlsOptions = { key, cert };\n}\n\n// Client Certificates in Playwright are implemented as a SOCKS5 proxy that injects client certificates into the TLS handshake.\n// We do that to avoid patching the browsers TLS stack and expose the certificates there.\n// The following shows two flow diagrams, one for http:// and one for https://.\n// Key Decision Point: First byte check (0x16 = TLS handshake)\n\n// HTTP FLOW (Plain text):\n//     BROWSER                    PROXY                     SERVER\n//        \u2502                        \u2502                         \u2502\n//        \u2502   SOCKS5 Connect       \u2502                         \u2502\n//        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502                         \u2502\n//        \u2502                        \u2502    TCP Connect          \u2502\n//        \u2502                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502   HTTP Request         \u2502                         \u2502\n//        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502                         \u2502\n//        \u2502                        \u2502 Check: not 0x16         \u2502\n//        \u2502                        \u2502 \u2192 Direct pipe           \u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502                        \u2502   HTTP Request          \u2502\n//        \u2502                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502\u25C4\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25BA\u2502\n//        \u2502      Plain HTTP        \u2502      Plain HTTP         \u2502\n\n// HTTPS FLOW (TLS with client certificates):\n//     BROWSER                    PROXY                     SERVER\n//        \u2502                        \u2502                         \u2502\n//        \u2502   SOCKS5 Connect       \u2502                         \u2502\n//        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502                         \u2502\n//        \u2502                        \u2502    TCP Connect          \u2502\n//        \u2502                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502   TLS ClientHello      \u2502                         \u2502\n//        \u2502   (with ALPN)          \u2502                         \u2502\n//        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502                         \u2502\n//        \u2502                        \u2502 Check: 0x16 = TLS       \u2502\n//        \u2502                        \u2502 Parse ALPN protocols    \u2502\n//        \u2502                        \u2502 Create dual TLS conns   \u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502                        \u2502   TLS ClientHello       \u2502\n//        \u2502                        \u2502   (with client cert)    \u2502\n//        \u2502                        \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25BA\u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502                        \u2502\u25C4\u2500\u2500\u2500\u2500\u2500 TLS Handshake \u2500\u2500\u2500\u2500\u2502\n//        \u2502\u25C4\u2500\u2500\u2500\u2500 TLS Handshake \u2500\u2500\u2500\u2500\u2502                         \u2502\n//        \u2502                        \u2502                         \u2502\n//        \u2502\u25C4\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2502\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25BA\u2502\n//        \u2502      Encrypted Data    \u2502    Encrypted Data       \u2502\n//        \u2502      (HTTP/1.1 or H2)  \u2502    (with client auth)   \u2502\n\nclass SocksProxyConnection {\n  private readonly socksProxy: ClientCertificatesProxy;\n  private readonly uid: string;\n  private readonly host: string;\n  private readonly port: number;\n  private _firstPackageReceived = false;\n  private _serverEncrypted!: net.Socket;\n  private _browserEncrypted: stream.Duplex;\n  private _brorwserDecrypted: Promise<tls.TLSSocket> | undefined;\n  private _serverCloseEventListener: () => void;\n  private _closed = false;\n\n  constructor(socksProxy: ClientCertificatesProxy, uid: string, host: string, port: number) {\n    this.socksProxy = socksProxy;\n    this.uid = uid;\n    this.host = host;\n    this.port = port;\n    this._serverCloseEventListener = () => {\n      this._browserEncrypted.destroy();\n    };\n    this._browserEncrypted = new stream.Duplex({\n      read: () => { },\n      write: (data, encoding, callback) => {\n        this.socksProxy._socksProxy.sendSocketData({ uid: this.uid, data });\n        callback();\n      },\n      destroy: (error, callback) => {\n        if (error)\n          socksProxy._socksProxy.sendSocketError({ uid: this.uid, error: error.message });\n        else\n          socksProxy._socksProxy.sendSocketEnd({ uid: this.uid });\n        callback();\n      },\n    });\n  }\n\n  async connect() {\n    const proxyAgent = this.socksProxy.getProxyAgent(this.host, this.port);\n    if (proxyAgent)\n      this._serverEncrypted = await proxyAgent.callback(new EventEmitter() as any, { host: rewriteToLocalhostIfNeeded(this.host), port: this.port, secureEndpoint: false });\n    else\n      this._serverEncrypted = await createSocket(rewriteToLocalhostIfNeeded(this.host), this.port);\n\n    this._serverEncrypted.once('close', this._serverCloseEventListener);\n    this._serverEncrypted.once('error', error => this._browserEncrypted.destroy(error));\n    if (this._closed) {\n      this._serverEncrypted.destroy();\n      return;\n    }\n    this.socksProxy._socksProxy.socketConnected({\n      uid: this.uid,\n      host: this._serverEncrypted.localAddress!,\n      port: this._serverEncrypted.localPort!,\n    });\n  }\n\n  public onClose() {\n    // Close the other end and cleanup TLS resources.\n    this._serverEncrypted.destroy();\n    this._browserEncrypted.destroy();\n    this._closed = true;\n  }\n\n  public onData(data: Buffer) {\n    // HTTP / TLS are client-hello based protocols. This allows us to detect\n    // the protocol on the first package and attach appropriate listeners.\n    if (!this._firstPackageReceived) {\n      this._firstPackageReceived = true;\n      // 0x16 is SSLv3/TLS \"handshake\" content type: https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_record\n      if (data[0] === 0x16)\n        this._establishTlsTunnel(this._browserEncrypted, data);\n      else\n        this._establishPlaintextTunnel(this._browserEncrypted);\n    }\n\n    this._browserEncrypted.push(data);\n  }\n\n\n  private _establishPlaintextTunnel(browserEncrypted: stream.Duplex) {\n    browserEncrypted.pipe(this._serverEncrypted);\n    this._serverEncrypted.pipe(browserEncrypted);\n  }\n\n  private _establishTlsTunnel(browserEncrypted: stream.Duplex, clientHello: Buffer) {\n    const browserALPNProtocols = parseALPNFromClientHello(clientHello) || ['http/1.1'];\n    debugLogger.log('client-certificates', `Browser->Proxy ${this.host}:${this.port} offers ALPN ${browserALPNProtocols}`);\n\n    const serverDecrypted = tls.connect({\n      socket: this._serverEncrypted,\n      host: this.host,\n      port: this.port,\n      rejectUnauthorized: !this.socksProxy.ignoreHTTPSErrors,\n      ALPNProtocols: browserALPNProtocols,\n      servername: !net.isIP(this.host) ? this.host : undefined,\n      secureContext: this.socksProxy.secureContextMap.get(new URL(`https://${this.host}:${this.port}`).origin),\n    }, async () => {\n      const browserDecrypted = await this._upgradeToTLSIfNeeded(browserEncrypted, serverDecrypted.alpnProtocol);\n      debugLogger.log('client-certificates', `Proxy->Server ${this.host}:${this.port} chooses ALPN ${browserDecrypted.alpnProtocol}`);\n      browserDecrypted.pipe(serverDecrypted);\n      serverDecrypted.pipe(browserDecrypted);\n\n      const cleanup = (error: Error | undefined) => this._serverEncrypted.destroy(error);\n\n      browserDecrypted.once('error', cleanup);\n      serverDecrypted.once('error', cleanup);\n      browserDecrypted.once('close', cleanup);\n      serverDecrypted.once('close', cleanup);\n\n      if (this._closed)\n        serverDecrypted.destroy();\n    });\n    serverDecrypted.once('error', async (error: Error) => {\n      debugLogger.log('client-certificates', `error when connecting to server: ${error.message.replaceAll('\\n', ' ')}`);\n\n      // Once we receive an error, we manually close the server connection.\n      // In case of an 'error' event on the server connection, we still need to perform the http2 handshake on the browser side.\n      // This is an async operation, so we need to remove the listener to prevent the socket from being closed too early.\n      // This means we call this._serverCloseEventListener manually.\n      this._serverEncrypted.removeListener('close', this._serverCloseEventListener);\n      this._serverEncrypted.destroy();\n\n      const browserDecrypted = await this._upgradeToTLSIfNeeded(this._browserEncrypted, serverDecrypted.alpnProtocol);\n      const responseBody = escapeHTML('Playwright client-certificate error: ' + error.message)\n          .replaceAll('\\n', ' <br>');\n      if (browserDecrypted.alpnProtocol === 'h2') {\n        // This method is available only in Node.js 20+\n        if ('performServerHandshake' in http2) {\n          // @ts-expect-error\n          const session: http2.ServerHttp2Session = http2.performServerHandshake(browserDecrypted);\n          session.on('error', error => {\n            this._browserEncrypted.destroy(error);\n          });\n          session.once('stream', (stream: http2.ServerHttp2Stream) => {\n            const cleanup = (error?: Error) => {\n              session.close();\n              this._browserEncrypted.destroy(error);\n            };\n            stream.once('end', cleanup);\n            stream.once('error', cleanup);\n            stream.respond({\n              [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'text/html',\n              [http2.constants.HTTP2_HEADER_STATUS]: 503,\n            });\n            stream.end(responseBody);\n          });\n        } else {\n          this._browserEncrypted.destroy(error);\n        }\n      } else {\n        browserDecrypted.end([\n          'HTTP/1.1 503 Internal Server Error',\n          'Content-Type: text/html; charset=utf-8',\n          'Content-Length: ' + Buffer.byteLength(responseBody),\n          '',\n          responseBody,\n        ].join('\\r\\n'));\n      }\n    });\n  }\n\n  private async _upgradeToTLSIfNeeded(socket: stream.Duplex, alpnProtocol: string | false | null): Promise<tls.TLSSocket> {\n    // TLS errors can happen after secureConnect event from the server. In this case the socket is already upgraded to TLS.\n    this._brorwserDecrypted ??= new Promise<tls.TLSSocket>((resolve, reject) => {\n      const dummyServer = tls.createServer({\n        ...dummyServerTlsOptions,\n        ALPNProtocols: [alpnProtocol || 'http/1.1'],\n      });\n      dummyServer.emit('connection', socket);\n      dummyServer.once('secureConnection', tlsSocket => {\n        dummyServer.close();\n        resolve(tlsSocket);\n      });\n      dummyServer.once('error', error => {\n        dummyServer.close();\n        reject(error);\n      });\n    });\n    return this._brorwserDecrypted;\n  }\n}\n\nexport class ClientCertificatesProxy {\n  _socksProxy: SocksProxy;\n  private _connections: Map<string, SocksProxyConnection> = new Map();\n  ignoreHTTPSErrors: boolean | undefined;\n  secureContextMap: Map<string, tls.SecureContext> = new Map();\n  private _proxy: types.ProxySettings | undefined;\n\n  private constructor(\n    contextOptions: Pick<types.BrowserContextOptions, 'clientCertificates' | 'ignoreHTTPSErrors' | 'proxy'>\n  ) {\n    verifyClientCertificates(contextOptions.clientCertificates);\n    this.ignoreHTTPSErrors = contextOptions.ignoreHTTPSErrors;\n    this._proxy = contextOptions.proxy;\n    this._initSecureContexts(contextOptions.clientCertificates);\n    this._socksProxy = new SocksProxy();\n    this._socksProxy.setPattern('*');\n    this._socksProxy.addListener(SocksProxy.Events.SocksRequested, async (payload: SocksSocketRequestedPayload) => {\n      try {\n        const connection = new SocksProxyConnection(this, payload.uid, payload.host, payload.port);\n        await connection.connect();\n        this._connections.set(payload.uid, connection);\n      } catch (error) {\n        debugLogger.log('client-certificates', `Failed to connect to ${payload.host}:${payload.port}: ${error.message}`);\n        this._socksProxy.socketFailed({ uid: payload.uid, errorCode: error.code });\n      }\n    });\n    this._socksProxy.addListener(SocksProxy.Events.SocksData, (payload: SocksSocketDataPayload) => {\n      this._connections.get(payload.uid)?.onData(payload.data);\n    });\n    this._socksProxy.addListener(SocksProxy.Events.SocksClosed, (payload: SocksSocketClosedPayload) => {\n      this._connections.get(payload.uid)?.onClose();\n      this._connections.delete(payload.uid);\n    });\n    loadDummyServerCertsIfNeeded();\n  }\n\n  getProxyAgent(host: string, port: number) {\n    const proxyFromOptions = createProxyAgent(this._proxy);\n    if (proxyFromOptions)\n      return proxyFromOptions;\n    const proxyFromEnv = getProxyForUrl(`https://${host}:${port}`);\n    if (proxyFromEnv)\n      return createProxyAgent({ server: proxyFromEnv });\n  }\n\n  _initSecureContexts(clientCertificates: types.BrowserContextOptions['clientCertificates']) {\n    // Step 1. Group certificates by origin.\n    const origin2certs = new Map<string, types.BrowserContextOptions['clientCertificates']>();\n    for (const cert of clientCertificates || []) {\n      const origin = normalizeOrigin(cert.origin);\n      const certs = origin2certs.get(origin) || [];\n      certs.push(cert);\n      origin2certs.set(origin, certs);\n    }\n\n    // Step 2. Create secure contexts for each origin.\n    for (const [origin, certs] of origin2certs) {\n      try {\n        this.secureContextMap.set(origin, tls.createSecureContext(convertClientCertificatesToTLSOptions(certs)));\n      } catch (error) {\n        error = rewriteOpenSSLErrorIfNeeded(error);\n        throw rewriteErrorMessage(error, `Failed to load client certificate: ${error.message}`);\n      }\n    }\n  }\n\n  public static async create(progress: Progress, contextOptions: Pick<types.BrowserContextOptions, 'clientCertificates' | 'ignoreHTTPSErrors' | 'proxy'>) {\n    const proxy = new ClientCertificatesProxy(contextOptions);\n    try {\n      await progress.race(proxy._socksProxy.listen(0, '127.0.0.1'));\n      return proxy;\n    } catch (error) {\n      await proxy.close();\n      throw error;\n    }\n  }\n\n  public proxySettings(): types.ProxySettings {\n    return { server: `socks5://127.0.0.1:${this._socksProxy.port()}` };\n  }\n\n  public async close() {\n    await this._socksProxy.close();\n  }\n}\n\nfunction normalizeOrigin(origin: string): string {\n  try {\n    return new URL(origin).origin;\n  } catch (error) {\n    return origin;\n  }\n}\n\nfunction convertClientCertificatesToTLSOptions(\n  clientCertificates: types.BrowserContextOptions['clientCertificates']\n): Pick<https.RequestOptions, 'pfx' | 'key' | 'cert'> | undefined {\n  if (!clientCertificates || !clientCertificates.length)\n    return;\n  const tlsOptions = {\n    pfx: [] as { buf: Buffer, passphrase?: string }[],\n    key: [] as { pem: Buffer, passphrase?: string }[],\n    cert: [] as Buffer[],\n  };\n  for (const cert of clientCertificates) {\n    if (cert.cert)\n      tlsOptions.cert.push(cert.cert);\n    if (cert.key)\n      tlsOptions.key.push({ pem: cert.key, passphrase: cert.passphrase });\n    if (cert.pfx)\n      tlsOptions.pfx.push({ buf: cert.pfx, passphrase: cert.passphrase });\n  }\n  return tlsOptions;\n}\n\nexport function getMatchingTLSOptionsForOrigin(\n  clientCertificates: types.BrowserContextOptions['clientCertificates'],\n  origin: string\n): Pick<https.RequestOptions, 'pfx' | 'key' | 'cert'> | undefined {\n  const matchingCerts = clientCertificates?.filter(c =>\n    normalizeOrigin(c.origin) === origin\n  );\n  return convertClientCertificatesToTLSOptions(matchingCerts);\n}\n\nfunction rewriteToLocalhostIfNeeded(host: string): string {\n  return host === 'local.playwright' ? 'localhost' : host;\n}\n\nexport function rewriteOpenSSLErrorIfNeeded(error: Error): Error {\n  if (error.message !== 'unsupported' && (error as NodeJS.ErrnoException).code !== 'ERR_CRYPTO_UNSUPPORTED_OPERATION')\n    return error;\n  return rewriteErrorMessage(error, [\n    'Unsupported TLS certificate.',\n    'Most likely, the security algorithm of the given certificate was deprecated by OpenSSL.',\n    'For more details, see https://github.com/openssl/openssl/blob/master/README-PROVIDERS.md#the-legacy-provider',\n    'You could probably modernize the certificate by following the steps at https://github.com/nodejs/node/issues/40672#issuecomment-1243648223',\n  ].join('\\n'));\n}\n\n\n/**\n * Parses the ALPN (Application-Layer Protocol Negotiation) extension from a TLS ClientHello.\n * Based on RFC 8446 (TLS 1.3): https://datatracker.ietf.org/doc/html/rfc8446\n */\nfunction parseALPNFromClientHello(buffer: Buffer): string[] | null {\n  if (buffer.length < 6)\n    return null;\n\n  // --- TLS Record Header (RFC 8446 \u00A75.1) ---\n  // https://datatracker.ietf.org/doc/html/rfc8446#section-5.1\n  // TLSPlaintext.type (1 byte): 0x16 = TLS handshake\n  if (buffer[0] !== 0x16)\n    return null;\n\n  let offset = 5; // TLS record header is 5 bytes\n\n  // --- Handshake Header (RFC 8446 \u00A74.1) ---\n  // HandshakeType (1 byte): 0x01 = ClientHello\n  // https://datatracker.ietf.org/doc/html/rfc8446#section-4\n  if (buffer[offset] !== 0x01)\n    return null;\n\n  offset += 4; // Handshake header: type (1) + length (3)\n\n  // --- ClientHello (RFC 8446 \u00A74.1.2) ---\n  // https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.2\n\n  // legacy_version (2 bytes) \u2014 always 0x0303 (TLS 1.2 for compatibility)\n  offset += 2;\n  // random (32 bytes)\n  offset += 32;\n\n  // legacy_session_id<0..32> (preceded by 1-byte length)\n  if (offset >= buffer.length)\n    return null;\n  const sessionIdLength = buffer[offset];\n  offset += 1 + sessionIdLength;\n\n  // cipher_suites<2..2^16-2> (preceded by 2-byte length)\n  if (offset + 2 > buffer.length)\n    return null;\n  const cipherSuitesLength = buffer.readUInt16BE(offset);\n  offset += 2 + cipherSuitesLength;\n\n  // legacy_compression_methods<1..2^8-1> (preceded by 1-byte length)\n  if (offset >= buffer.length)\n    return null;\n  const compressionMethodsLength = buffer[offset];\n  offset += 1 + compressionMethodsLength;\n\n  // extensions<8..2^16-1> (preceded by 2-byte length)\n  if (offset + 2 > buffer.length)\n    return null;\n  const extensionsLength = buffer.readUInt16BE(offset);\n  offset += 2;\n\n  const extensionsEnd = offset + extensionsLength;\n  if (extensionsEnd > buffer.length)\n    return null;\n\n  // --- Extensions (RFC 8446 \u00A74.2) ---\n  // https://datatracker.ietf.org/doc/html/rfc8446#section-4.2\n  // Each extension is structured as:\n  // - extension_type (2 bytes)\n  // - extension_data length (2 bytes)\n  // - extension_data (variable)\n  while (offset + 4 <= extensionsEnd) {\n    const extensionType = buffer.readUInt16BE(offset);\n    offset += 2;\n    const extensionLength = buffer.readUInt16BE(offset);\n    offset += 2;\n\n    if (offset + extensionLength > extensionsEnd)\n      return null;\n\n    // ALPN extension (RFC 8446 \u00A74.2.11): extension_type = 16\n    // https://datatracker.ietf.org/doc/html/rfc8446#section-4.2\n    if (extensionType === 16)\n      return parseALPNExtension(buffer.subarray(offset, offset + extensionLength));\n\n    offset += extensionLength;\n  }\n\n  return null; // No ALPN extension found\n}\n\n/**\n * Parses the ALPN extension data from a ClientHello extension block.\n *\n * The ALPN structure is defined in:\n * - RFC 7301 \u00A73.1: https://datatracker.ietf.org/doc/html/rfc7301#section-3.1\n */\nfunction parseALPNExtension(buffer: Buffer): string[] | null {\n  if (buffer.length < 2)\n    return null;\n\n  // protocol_name_list<2..2^16-1> (preceded by 2-byte length)\n  const listLength = buffer.readUInt16BE(0);\n  if (listLength !== buffer.length - 2)\n    return null;\n\n  const protocols: string[] = [];\n  let offset = 2;\n\n  while (offset < buffer.length) {\n    // ProtocolName<1..2^8-1> (preceded by 1-byte length)\n    const protocolLength = buffer[offset];\n    offset += 1;\n\n    if (offset + protocolLength > buffer.length)\n      break;\n\n    const protocol = buffer.subarray(offset, offset + protocolLength).toString('utf8');\n    protocols.push(protocol);\n    offset += protocolLength;\n  }\n\n  return protocols.length > 0 ? protocols : null;\n}\n"],
  "mappings": "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",
  "names": ["stream", "tls", "net", "http2", "error"]
}

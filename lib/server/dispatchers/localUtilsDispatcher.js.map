{
  "version": 3,
  "sources": ["../../../src/server/dispatchers/localUtilsDispatcher.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Dispatcher } from './dispatcher';\nimport { SdkObject } from '../../server/instrumentation';\nimport * as localUtils from '../localUtils';\nimport { getUserAgent } from '../utils/userAgent';\nimport { deviceDescriptors as descriptors }  from '../deviceDescriptors';\nimport { JsonPipeDispatcher } from '../dispatchers/jsonPipeDispatcher';\nimport { Progress } from '../progress';\nimport { SocksInterceptor } from '../socksInterceptor';\nimport { WebSocketTransport } from '../transport';\nimport { fetchData } from '../utils/network';\nimport { resolveGlobToRegexPattern } from '../../utils/isomorphic/urlMatch';\n\nimport type { HarBackend } from '../harBackend';\nimport type { Playwright } from '../playwright';\nimport type { RootDispatcher } from './dispatcher';\nimport type * as channels from '@protocol/channels';\nimport type * as http from 'http';\nimport type { HTTPRequestParams } from '../utils/network';\n\nexport class LocalUtilsDispatcher extends Dispatcher<SdkObject, channels.LocalUtilsChannel, RootDispatcher> implements channels.LocalUtilsChannel {\n  _type_LocalUtils: boolean;\n  private _harBackends = new Map<string, HarBackend>();\n  private _stackSessions = new Map<string, localUtils.StackSession>();\n\n  constructor(scope: RootDispatcher, playwright: Playwright) {\n    const localUtils = new SdkObject(playwright, 'localUtils', 'localUtils');\n    localUtils.logName = 'browser';\n    const deviceDescriptors = Object.entries(descriptors)\n        .map(([name, descriptor]) => ({ name, descriptor }));\n    super(scope, localUtils, 'LocalUtils', {\n      deviceDescriptors,\n    });\n    this._type_LocalUtils = true;\n  }\n\n  async zip(params: channels.LocalUtilsZipParams, progress: Progress): Promise<void> {\n    return await localUtils.zip(progress, this._stackSessions, params);\n  }\n\n  async harOpen(params: channels.LocalUtilsHarOpenParams, progress: Progress): Promise<channels.LocalUtilsHarOpenResult> {\n    return await localUtils.harOpen(progress, this._harBackends, params);\n  }\n\n  async harLookup(params: channels.LocalUtilsHarLookupParams, progress: Progress): Promise<channels.LocalUtilsHarLookupResult> {\n    return await localUtils.harLookup(progress, this._harBackends, params);\n  }\n\n  async harClose(params: channels.LocalUtilsHarCloseParams, progress: Progress): Promise<void> {\n    localUtils.harClose(this._harBackends, params);\n  }\n\n  async harUnzip(params: channels.LocalUtilsHarUnzipParams, progress: Progress): Promise<void> {\n    return await localUtils.harUnzip(progress, params);\n  }\n\n  async tracingStarted(params: channels.LocalUtilsTracingStartedParams, progress: Progress): Promise<channels.LocalUtilsTracingStartedResult> {\n    return await localUtils.tracingStarted(progress, this._stackSessions, params);\n  }\n\n  async traceDiscarded(params: channels.LocalUtilsTraceDiscardedParams, progress: Progress): Promise<void> {\n    return await localUtils.traceDiscarded(progress, this._stackSessions, params);\n  }\n\n  async addStackToTracingNoReply(params: channels.LocalUtilsAddStackToTracingNoReplyParams, progress: Progress): Promise<void> {\n    localUtils.addStackToTracingNoReply(this._stackSessions, params);\n  }\n\n  async connect(params: channels.LocalUtilsConnectParams, progress: Progress): Promise<channels.LocalUtilsConnectResult> {\n    const wsHeaders = {\n      'User-Agent': getUserAgent(),\n      'x-playwright-proxy': params.exposeNetwork ?? '',\n      ...params.headers,\n    };\n    const wsEndpoint = await urlToWSEndpoint(progress, params.wsEndpoint);\n\n    const transport = await WebSocketTransport.connect(progress, wsEndpoint, { headers: wsHeaders, followRedirects: true, debugLogHeader: 'x-playwright-debug-log' });\n    const socksInterceptor = new SocksInterceptor(transport, params.exposeNetwork, params.socksProxyRedirectPortForTest);\n    const pipe = new JsonPipeDispatcher(this);\n    transport.onmessage = json => {\n      if (socksInterceptor.interceptMessage(json))\n        return;\n      const cb = () => {\n        try {\n          pipe.dispatch(json);\n        } catch (e) {\n          transport.close();\n        }\n      };\n      if (params.slowMo)\n        setTimeout(cb, params.slowMo);\n      else\n        cb();\n    };\n    pipe.on('message', message => {\n      transport.send(message);\n    });\n    transport.onclose = (reason?: string) => {\n      socksInterceptor?.cleanup();\n      pipe.wasClosed(reason);\n    };\n    pipe.on('close', () => transport.close());\n    return { pipe, headers: transport.headers };\n  }\n\n  async globToRegex(params: channels.LocalUtilsGlobToRegexParams, progress: Progress): Promise<channels.LocalUtilsGlobToRegexResult> {\n    const regex = resolveGlobToRegexPattern(params.baseURL, params.glob, params.webSocketUrl);\n    return { regex };\n  }\n}\n\nasync function urlToWSEndpoint(progress: Progress, endpointURL: string): Promise<string> {\n  if (endpointURL.startsWith('ws'))\n    return endpointURL;\n\n  progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);\n  const fetchUrl = new URL(endpointURL);\n  if (!fetchUrl.pathname.endsWith('/'))\n    fetchUrl.pathname += '/';\n  fetchUrl.pathname += 'json';\n  const json = await fetchData(progress, {\n    url: fetchUrl.toString(),\n    method: 'GET',\n    headers: { 'User-Agent': getUserAgent() },\n  }, async (params: HTTPRequestParams, response: http.IncomingMessage) => {\n    return new Error(`Unexpected status ${response.statusCode} when connecting to ${fetchUrl.toString()}.\\n` +\n        `This does not look like a Playwright server, try connecting via ws://.`);\n  });\n\n  const wsUrl = new URL(endpointURL);\n  let wsEndpointPath = JSON.parse(json).wsEndpointPath;\n  if (wsEndpointPath.startsWith('/'))\n    wsEndpointPath = wsEndpointPath.substring(1);\n  if (!wsUrl.pathname.endsWith('/'))\n    wsUrl.pathname += '/';\n  wsUrl.pathname += wsEndpointPath;\n  wsUrl.protocol = wsUrl.protocol === 'https:' ? 'wss:' : 'ws:';\n  return wsUrl.toString();\n}\n"],
  "mappings": "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",
  "names": ["localUtils", "descriptors"]
}

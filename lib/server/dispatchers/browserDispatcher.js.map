{
  "version": 3,
  "sources": ["../../../src/server/dispatchers/browserDispatcher.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Browser } from '../browser';\nimport { BrowserContextDispatcher } from './browserContextDispatcher';\nimport { CDPSessionDispatcher } from './cdpSessionDispatcher';\nimport { Dispatcher } from './dispatcher';\nimport { BrowserContext } from '../browserContext';\nimport { ArtifactDispatcher } from './artifactDispatcher';\n\nimport type { BrowserTypeDispatcher } from './browserTypeDispatcher';\nimport type { PageDispatcher } from './pageDispatcher';\nimport type { CRBrowser } from '../chromium/crBrowser';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\n\ntype BrowserDispatcherOptions = {\n  // Do not allow to close this browser.\n  ignoreStopAndKill?: boolean,\n  // Only expose browser contexts created by this dispatcher. By default, all contexts are exposed.\n  isolateContexts?: boolean,\n};\n\nexport class BrowserDispatcher extends Dispatcher<Browser, channels.BrowserChannel, BrowserTypeDispatcher> implements channels.BrowserChannel {\n  _type_Browser = true;\n  private _options: BrowserDispatcherOptions;\n  private _isolatedContexts = new Set<BrowserContext>();\n\n  constructor(scope: BrowserTypeDispatcher, browser: Browser, options: BrowserDispatcherOptions = {}) {\n    super(scope, browser, 'Browser', { version: browser.version(), name: browser.options.name });\n    this._options = options;\n\n    if (!options.isolateContexts) {\n      this.addObjectListener(Browser.Events.Context, (context: BrowserContext) => this._dispatchEvent('context', { context: BrowserContextDispatcher.from(this, context) }));\n      this.addObjectListener(Browser.Events.Disconnected, () => this._didClose());\n      if (browser._defaultContext)\n        this._dispatchEvent('context', { context: BrowserContextDispatcher.from(this, browser._defaultContext) });\n      for (const context of browser.contexts())\n        this._dispatchEvent('context', { context: BrowserContextDispatcher.from(this, context) });\n    }\n  }\n\n  _didClose() {\n    this._dispatchEvent('close');\n    this._dispose();\n  }\n\n  async newContext(params: channels.BrowserNewContextParams, progress: Progress): Promise<channels.BrowserNewContextResult> {\n    if (params.recordVideo && this._object.attribution.playwright.options.isServer)\n      params.recordVideo.dir = this._object.options.artifactsDir;\n\n    if (!this._options.isolateContexts) {\n      const context = await this._object.newContext(progress, params);\n      const contextDispatcher = BrowserContextDispatcher.from(this, context);\n      return { context: contextDispatcher };\n    }\n\n    const context = await this._object.newContext(progress, params);\n    this._isolatedContexts.add(context);\n    context.on(BrowserContext.Events.Close, () => this._isolatedContexts.delete(context));\n    const contextDispatcher = BrowserContextDispatcher.from(this, context);\n    this._dispatchEvent('context', { context: contextDispatcher });\n    return { context: contextDispatcher };\n  }\n\n  async newContextForReuse(params: channels.BrowserNewContextForReuseParams, progress: Progress): Promise<channels.BrowserNewContextForReuseResult> {\n    const context = await this._object.newContextForReuse(progress, params);\n    const contextDispatcher = BrowserContextDispatcher.from(this, context);\n    this._dispatchEvent('context', { context: contextDispatcher });\n    return { context: contextDispatcher };\n  }\n\n  async disconnectFromReusedContext(params: channels.BrowserDisconnectFromReusedContextParams, progress: Progress): Promise<void> {\n    const context = this._object.contextForReuse();\n    const contextDispatcher = context ? this.connection.existingDispatcher<BrowserContextDispatcher>(context) : undefined;\n    if (contextDispatcher) {\n      await contextDispatcher.stopPendingOperations(new Error(params.reason));\n      contextDispatcher._dispose();\n    }\n  }\n\n  async close(params: channels.BrowserCloseParams, progress: Progress): Promise<void> {\n    if (this._options.ignoreStopAndKill)\n      return;\n    progress.metadata.potentiallyClosesScope = true;\n    await this._object.close(params);\n  }\n\n  async killForTests(params: channels.BrowserKillForTestsParams, progress: Progress): Promise<void> {\n    if (this._options.ignoreStopAndKill)\n      return;\n    progress.metadata.potentiallyClosesScope = true;\n    await this._object.killForTests();\n  }\n\n  async defaultUserAgentForTest(): Promise<channels.BrowserDefaultUserAgentForTestResult> {\n    return { userAgent: this._object.userAgent() };\n  }\n\n  async newBrowserCDPSession(params: channels.BrowserNewBrowserCDPSessionParams, progress: Progress): Promise<channels.BrowserNewBrowserCDPSessionResult> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    if (!this._object.options.isChromium)\n      throw new Error(`CDP session is only available in Chromium`);\n    const crBrowser = this._object as CRBrowser;\n    return { session: new CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession()) };\n  }\n\n  async startTracing(params: channels.BrowserStartTracingParams, progress: Progress): Promise<void> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    if (!this._object.options.isChromium)\n      throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object as CRBrowser;\n    await crBrowser.startTracing(params.page ? (params.page as PageDispatcher)._object : undefined, params);\n  }\n\n  async stopTracing(params: channels.BrowserStopTracingParams, progress: Progress): Promise<channels.BrowserStopTracingResult> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    if (!this._object.options.isChromium)\n      throw new Error(`Tracing is only available in Chromium`);\n    const crBrowser = this._object as CRBrowser;\n    return { artifact: ArtifactDispatcher.from(this, await crBrowser.stopTracing()) };\n  }\n\n  async cleanupContexts() {\n    await Promise.all(Array.from(this._isolatedContexts).map(context => context.close({ reason: 'Global context cleanup (connection terminated)' })));\n  }\n}\n"],
  "mappings": "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",
  "names": ["context", "contextDispatcher"]
}

{
  "version": 3,
  "sources": ["../../../src/server/dispatchers/networkDispatchers.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WebSocket } from '../network';\nimport { Dispatcher } from './dispatcher';\nimport { FrameDispatcher } from './frameDispatcher';\nimport { WorkerDispatcher } from './pageDispatcher';\nimport { TracingDispatcher } from './tracingDispatcher';\n\nimport type { APIRequestContext } from '../fetch';\nimport type { Request, Response, Route } from '../network';\nimport type { BrowserContextDispatcher } from './browserContextDispatcher';\nimport type { RootDispatcher } from './dispatcher';\nimport type { PageDispatcher } from './pageDispatcher';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\n\n\nexport class RequestDispatcher extends Dispatcher<Request, channels.RequestChannel, BrowserContextDispatcher | PageDispatcher | FrameDispatcher> implements channels.RequestChannel {\n  _type_Request: boolean;\n  private _browserContextDispatcher: BrowserContextDispatcher;\n\n  static from(scope: BrowserContextDispatcher, request: Request): RequestDispatcher {\n    const result = scope.connection.existingDispatcher<RequestDispatcher>(request);\n    return result || new RequestDispatcher(scope, request);\n  }\n\n  static fromNullable(scope: BrowserContextDispatcher, request: Request | null): RequestDispatcher | undefined {\n    return request ? RequestDispatcher.from(scope, request) : undefined;\n  }\n\n  private constructor(scope: BrowserContextDispatcher, request: Request) {\n    const postData = request.postDataBuffer();\n    // Always try to attach request to the page, if not, frame.\n    const frame = request.frame();\n    const page = request.frame()?._page;\n    const pageDispatcher = page ? scope.connection.existingDispatcher<PageDispatcher>(page) : null;\n    const frameDispatcher = frame ? FrameDispatcher.from(scope, frame) : null;\n    super(pageDispatcher || frameDispatcher || scope, request, 'Request', {\n      frame: FrameDispatcher.fromNullable(scope, request.frame()),\n      serviceWorker: WorkerDispatcher.fromNullable(scope, request.serviceWorker()),\n      url: request.url(),\n      resourceType: request.resourceType(),\n      method: request.method(),\n      postData: postData === null ? undefined : postData,\n      headers: request.headers(),\n      isNavigationRequest: request.isNavigationRequest(),\n      redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom()),\n    });\n    this._type_Request = true;\n    this._browserContextDispatcher = scope;\n  }\n\n  async rawRequestHeaders(params: channels.RequestRawRequestHeadersParams, progress: Progress): Promise<channels.RequestRawRequestHeadersResult> {\n    return { headers: await progress.race(this._object.rawRequestHeaders()) };\n  }\n\n  async response(params: channels.RequestResponseParams, progress: Progress): Promise<channels.RequestResponseResult> {\n    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await progress.race(this._object.response())) };\n  }\n}\n\nexport class ResponseDispatcher extends Dispatcher<Response, channels.ResponseChannel, RequestDispatcher> implements channels.ResponseChannel {\n  _type_Response = true;\n\n  static from(scope: BrowserContextDispatcher, response: Response): ResponseDispatcher {\n    const result = scope.connection.existingDispatcher<ResponseDispatcher>(response);\n    const requestDispatcher = RequestDispatcher.from(scope, response.request());\n    return result || new ResponseDispatcher(requestDispatcher, response);\n  }\n\n  static fromNullable(scope: BrowserContextDispatcher, response: Response | null): ResponseDispatcher | undefined {\n    return response ? ResponseDispatcher.from(scope, response) : undefined;\n  }\n\n  private constructor(scope: RequestDispatcher, response: Response) {\n    super(scope, response, 'Response', {\n      // TODO: responses in popups can point to non-reported requests.\n      request: scope,\n      url: response.url(),\n      status: response.status(),\n      statusText: response.statusText(),\n      headers: response.headers(),\n      timing: response.timing(),\n      fromServiceWorker: response.fromServiceWorker(),\n    });\n  }\n\n  async body(params: channels.ResponseBodyParams, progress: Progress): Promise<channels.ResponseBodyResult> {\n    return { binary: await progress.race(this._object.body()) };\n  }\n\n  async securityDetails(params: channels.ResponseSecurityDetailsParams, progress: Progress): Promise<channels.ResponseSecurityDetailsResult> {\n    return { value: await progress.race(this._object.securityDetails()) || undefined };\n  }\n\n  async serverAddr(params: channels.ResponseServerAddrParams, progress: Progress): Promise<channels.ResponseServerAddrResult> {\n    return { value: await progress.race(this._object.serverAddr()) || undefined };\n  }\n\n  async rawResponseHeaders(params: channels.ResponseRawResponseHeadersParams, progress: Progress): Promise<channels.ResponseRawResponseHeadersResult> {\n    return { headers: await progress.race(this._object.rawResponseHeaders()) };\n  }\n\n  async sizes(params: channels.ResponseSizesParams, progress: Progress): Promise<channels.ResponseSizesResult> {\n    return { sizes: await progress.race(this._object.sizes()) };\n  }\n}\n\nexport class RouteDispatcher extends Dispatcher<Route, channels.RouteChannel, RequestDispatcher> implements channels.RouteChannel {\n  _type_Route = true;\n\n  private _handled = false;\n\n  constructor(scope: RequestDispatcher, route: Route) {\n    super(scope, route, 'Route', {\n      // Context route can point to a non-reported request, so we send the request in the initializer.\n      request: scope\n    });\n  }\n\n  private _checkNotHandled() {\n    if (this._handled)\n      throw new Error('Route is already handled!');\n    this._handled = true;\n  }\n\n  async continue(params: channels.RouteContinueParams, progress: Progress): Promise<channels.RouteContinueResult> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    this._checkNotHandled();\n    await this._object.continue({\n      url: params.url,\n      method: params.method,\n      headers: params.headers,\n      postData: params.postData,\n      isFallback: params.isFallback,\n    });\n  }\n\n  async fulfill(params: channels.RouteFulfillParams, progress: Progress): Promise<void> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    this._checkNotHandled();\n    await this._object.fulfill(params);\n  }\n\n  async abort(params: channels.RouteAbortParams, progress: Progress): Promise<void> {\n    // Note: progress is ignored because this operation is not cancellable and should not block in the browser anyway.\n    this._checkNotHandled();\n    await this._object.abort(params.errorCode || 'failed');\n  }\n\n  async redirectNavigationRequest(params: channels.RouteRedirectNavigationRequestParams, progress: Progress): Promise<void> {\n    this._checkNotHandled();\n    this._object.redirectNavigationRequest(params.url);\n  }\n}\n\nexport class WebSocketDispatcher extends Dispatcher<WebSocket, channels.WebSocketChannel, PageDispatcher> implements channels.WebSocketChannel {\n  _type_EventTarget = true;\n  _type_WebSocket = true;\n\n  constructor(scope: PageDispatcher, webSocket: WebSocket) {\n    super(scope, webSocket, 'WebSocket', {\n      url: webSocket.url(),\n    });\n    this.addObjectListener(WebSocket.Events.FrameSent, (event: { opcode: number, data: string }) => this._dispatchEvent('frameSent', event));\n    this.addObjectListener(WebSocket.Events.FrameReceived, (event: { opcode: number, data: string }) => this._dispatchEvent('frameReceived', event));\n    this.addObjectListener(WebSocket.Events.SocketError, (error: string) => this._dispatchEvent('socketError', { error }));\n    this.addObjectListener(WebSocket.Events.Close, () => this._dispatchEvent('close', {}));\n  }\n}\n\nexport class APIRequestContextDispatcher extends Dispatcher<APIRequestContext, channels.APIRequestContextChannel, RootDispatcher | BrowserContextDispatcher> implements channels.APIRequestContextChannel {\n  _type_APIRequestContext = true;\n\n  static from(scope: RootDispatcher | BrowserContextDispatcher, request: APIRequestContext): APIRequestContextDispatcher {\n    const result = scope.connection.existingDispatcher<APIRequestContextDispatcher>(request);\n    return result || new APIRequestContextDispatcher(scope, request);\n  }\n\n  static fromNullable(scope: RootDispatcher | BrowserContextDispatcher, request: APIRequestContext | null): APIRequestContextDispatcher | undefined {\n    return request ? APIRequestContextDispatcher.from(scope, request) : undefined;\n  }\n\n  private constructor(parentScope: RootDispatcher | BrowserContextDispatcher, request: APIRequestContext) {\n    // We will reparent these to the context below.\n    const tracing = TracingDispatcher.from(parentScope as any as APIRequestContextDispatcher, request.tracing());\n\n    super(parentScope, request, 'APIRequestContext', {\n      tracing,\n    });\n\n    this.adopt(tracing);\n  }\n\n  async storageState(params: channels.APIRequestContextStorageStateParams, progress: Progress): Promise<channels.APIRequestContextStorageStateResult> {\n    return await this._object.storageState(progress, params.indexedDB);\n  }\n\n  async dispose(params: channels.APIRequestContextDisposeParams, progress: Progress): Promise<void> {\n    progress.metadata.potentiallyClosesScope = true;\n    await this._object.dispose(params);\n    this._dispose();\n  }\n\n  async fetch(params: channels.APIRequestContextFetchParams, progress: Progress): Promise<channels.APIRequestContextFetchResult> {\n    const fetchResponse = await this._object.fetch(progress, params);\n    return {\n      response: {\n        url: fetchResponse.url,\n        status: fetchResponse.status,\n        statusText: fetchResponse.statusText,\n        headers: fetchResponse.headers,\n        fetchUid: fetchResponse.fetchUid\n      }\n    };\n  }\n\n  async fetchResponseBody(params: channels.APIRequestContextFetchResponseBodyParams, progress: Progress): Promise<channels.APIRequestContextFetchResponseBodyResult> {\n    return { binary: this._object.fetchResponses.get(params.fetchUid) };\n  }\n\n  async fetchLog(params: channels.APIRequestContextFetchLogParams, progress: Progress): Promise<channels.APIRequestContextFetchLogResult> {\n    const log = this._object.fetchLog.get(params.fetchUid) || [];\n    return { log };\n  }\n\n  async disposeAPIResponse(params: channels.APIRequestContextDisposeAPIResponseParams, progress: Progress): Promise<void> {\n    this._object.disposeResponse(params.fetchUid);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,qBAA0B;AAC1B,wBAA2B;AAC3B,6BAAgC;AAChC,4BAAiC;AACjC,+BAAkC;AAW3B,MAAM,0BAA0B,6BAA6I;AAAA,EAIlL,OAAO,KAAK,OAAiC,SAAqC;AAChF,UAAM,SAAS,MAAM,WAAW,mBAAsC,OAAO;AAC7E,WAAO,UAAU,IAAI,kBAAkB,OAAO,OAAO;AAAA,EACvD;AAAA,EAEA,OAAO,aAAa,OAAiC,SAAwD;AAC3G,WAAO,UAAU,kBAAkB,KAAK,OAAO,OAAO,IAAI;AAAA,EAC5D;AAAA,EAEQ,YAAY,OAAiC,SAAkB;AACrE,UAAM,WAAW,QAAQ,eAAe;AAExC,UAAM,QAAQ,QAAQ,MAAM;AAC5B,UAAM,OAAO,QAAQ,MAAM,GAAG;AAC9B,UAAM,iBAAiB,OAAO,MAAM,WAAW,mBAAmC,IAAI,IAAI;AAC1F,UAAM,kBAAkB,QAAQ,uCAAgB,KAAK,OAAO,KAAK,IAAI;AACrE,UAAM,kBAAkB,mBAAmB,OAAO,SAAS,WAAW;AAAA,MACpE,OAAO,uCAAgB,aAAa,OAAO,QAAQ,MAAM,CAAC;AAAA,MAC1D,eAAe,uCAAiB,aAAa,OAAO,QAAQ,cAAc,CAAC;AAAA,MAC3E,KAAK,QAAQ,IAAI;AAAA,MACjB,cAAc,QAAQ,aAAa;AAAA,MACnC,QAAQ,QAAQ,OAAO;AAAA,MACvB,UAAU,aAAa,OAAO,SAAY;AAAA,MAC1C,SAAS,QAAQ,QAAQ;AAAA,MACzB,qBAAqB,QAAQ,oBAAoB;AAAA,MACjD,gBAAgB,kBAAkB,aAAa,OAAO,QAAQ,eAAe,CAAC;AAAA,IAChF,CAAC;AACD,SAAK,gBAAgB;AACrB,SAAK,4BAA4B;AAAA,EACnC;AAAA,EAEA,MAAM,kBAAkB,QAAiD,UAAsE;AAC7I,WAAO,EAAE,SAAS,MAAM,SAAS,KAAK,KAAK,QAAQ,kBAAkB,CAAC,EAAE;AAAA,EAC1E;AAAA,EAEA,MAAM,SAAS,QAAwC,UAA6D;AAClH,WAAO,EAAE,UAAU,mBAAmB,aAAa,KAAK,2BAA2B,MAAM,SAAS,KAAK,KAAK,QAAQ,SAAS,CAAC,CAAC,EAAE;AAAA,EACnI;AACF;AAEO,MAAM,2BAA2B,6BAAsG;AAAA,EAapI,YAAY,OAA0B,UAAoB;AAChE,UAAM,OAAO,UAAU,YAAY;AAAA;AAAA,MAEjC,SAAS;AAAA,MACT,KAAK,SAAS,IAAI;AAAA,MAClB,QAAQ,SAAS,OAAO;AAAA,MACxB,YAAY,SAAS,WAAW;AAAA,MAChC,SAAS,SAAS,QAAQ;AAAA,MAC1B,QAAQ,SAAS,OAAO;AAAA,MACxB,mBAAmB,SAAS,kBAAkB;AAAA,IAChD,CAAC;AAtBH,0BAAiB;AAAA,EAuBjB;AAAA,EArBA,OAAO,KAAK,OAAiC,UAAwC;AACnF,UAAM,SAAS,MAAM,WAAW,mBAAuC,QAAQ;AAC/E,UAAM,oBAAoB,kBAAkB,KAAK,OAAO,SAAS,QAAQ,CAAC;AAC1E,WAAO,UAAU,IAAI,mBAAmB,mBAAmB,QAAQ;AAAA,EACrE;AAAA,EAEA,OAAO,aAAa,OAAiC,UAA2D;AAC9G,WAAO,WAAW,mBAAmB,KAAK,OAAO,QAAQ,IAAI;AAAA,EAC/D;AAAA,EAeA,MAAM,KAAK,QAAqC,UAA0D;AACxG,WAAO,EAAE,QAAQ,MAAM,SAAS,KAAK,KAAK,QAAQ,KAAK,CAAC,EAAE;AAAA,EAC5D;AAAA,EAEA,MAAM,gBAAgB,QAAgD,UAAqE;AACzI,WAAO,EAAE,OAAO,MAAM,SAAS,KAAK,KAAK,QAAQ,gBAAgB,CAAC,KAAK,OAAU;AAAA,EACnF;AAAA,EAEA,MAAM,WAAW,QAA2C,UAAgE;AAC1H,WAAO,EAAE,OAAO,MAAM,SAAS,KAAK,KAAK,QAAQ,WAAW,CAAC,KAAK,OAAU;AAAA,EAC9E;AAAA,EAEA,MAAM,mBAAmB,QAAmD,UAAwE;AAClJ,WAAO,EAAE,SAAS,MAAM,SAAS,KAAK,KAAK,QAAQ,mBAAmB,CAAC,EAAE;AAAA,EAC3E;AAAA,EAEA,MAAM,MAAM,QAAsC,UAA2D;AAC3G,WAAO,EAAE,OAAO,MAAM,SAAS,KAAK,KAAK,QAAQ,MAAM,CAAC,EAAE;AAAA,EAC5D;AACF;AAEO,MAAM,wBAAwB,6BAA6F;AAAA,EAKhI,YAAY,OAA0B,OAAc;AAClD,UAAM,OAAO,OAAO,SAAS;AAAA;AAAA,MAE3B,SAAS;AAAA,IACX,CAAC;AARH,uBAAc;AAEd,SAAQ,WAAW;AAAA,EAOnB;AAAA,EAEQ,mBAAmB;AACzB,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,2BAA2B;AAC7C,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,SAAS,QAAsC,UAA2D;AAE9G,SAAK,iBAAiB;AACtB,UAAM,KAAK,QAAQ,SAAS;AAAA,MAC1B,KAAK,OAAO;AAAA,MACZ,QAAQ,OAAO;AAAA,MACf,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,YAAY,OAAO;AAAA,IACrB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ,QAAqC,UAAmC;AAEpF,SAAK,iBAAiB;AACtB,UAAM,KAAK,QAAQ,QAAQ,MAAM;AAAA,EACnC;AAAA,EAEA,MAAM,MAAM,QAAmC,UAAmC;AAEhF,SAAK,iBAAiB;AACtB,UAAM,KAAK,QAAQ,MAAM,OAAO,aAAa,QAAQ;AAAA,EACvD;AAAA,EAEA,MAAM,0BAA0B,QAAuD,UAAmC;AACxH,SAAK,iBAAiB;AACtB,SAAK,QAAQ,0BAA0B,OAAO,GAAG;AAAA,EACnD;AACF;AAEO,MAAM,4BAA4B,6BAAsG;AAAA,EAI7I,YAAY,OAAuB,WAAsB;AACvD,UAAM,OAAO,WAAW,aAAa;AAAA,MACnC,KAAK,UAAU,IAAI;AAAA,IACrB,CAAC;AANH,6BAAoB;AACpB,2BAAkB;AAMhB,SAAK,kBAAkB,yBAAU,OAAO,WAAW,CAAC,UAA4C,KAAK,eAAe,aAAa,KAAK,CAAC;AACvI,SAAK,kBAAkB,yBAAU,OAAO,eAAe,CAAC,UAA4C,KAAK,eAAe,iBAAiB,KAAK,CAAC;AAC/I,SAAK,kBAAkB,yBAAU,OAAO,aAAa,CAAC,UAAkB,KAAK,eAAe,eAAe,EAAE,MAAM,CAAC,CAAC;AACrH,SAAK,kBAAkB,yBAAU,OAAO,OAAO,MAAM,KAAK,eAAe,SAAS,CAAC,CAAC,CAAC;AAAA,EACvF;AACF;AAEO,MAAM,oCAAoC,6BAAyJ;AAAA,EAYhM,YAAY,aAAwD,SAA4B;AAEtG,UAAM,UAAU,2CAAkB,KAAK,aAAmD,QAAQ,QAAQ,CAAC;AAE3G,UAAM,aAAa,SAAS,qBAAqB;AAAA,MAC/C;AAAA,IACF,CAAC;AAjBH,mCAA0B;AAmBxB,SAAK,MAAM,OAAO;AAAA,EACpB;AAAA,EAlBA,OAAO,KAAK,OAAkD,SAAyD;AACrH,UAAM,SAAS,MAAM,WAAW,mBAAgD,OAAO;AACvF,WAAO,UAAU,IAAI,4BAA4B,OAAO,OAAO;AAAA,EACjE;AAAA,EAEA,OAAO,aAAa,OAAkD,SAA4E;AAChJ,WAAO,UAAU,4BAA4B,KAAK,OAAO,OAAO,IAAI;AAAA,EACtE;AAAA,EAaA,MAAM,aAAa,QAAsD,UAA2E;AAClJ,WAAO,MAAM,KAAK,QAAQ,aAAa,UAAU,OAAO,SAAS;AAAA,EACnE;AAAA,EAEA,MAAM,QAAQ,QAAiD,UAAmC;AAChG,aAAS,SAAS,yBAAyB;AAC3C,UAAM,KAAK,QAAQ,QAAQ,MAAM;AACjC,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,MAAM,QAA+C,UAAoE;AAC7H,UAAM,gBAAgB,MAAM,KAAK,QAAQ,MAAM,UAAU,MAAM;AAC/D,WAAO;AAAA,MACL,UAAU;AAAA,QACR,KAAK,cAAc;AAAA,QACnB,QAAQ,cAAc;AAAA,QACtB,YAAY,cAAc;AAAA,QAC1B,SAAS,cAAc;AAAA,QACvB,UAAU,cAAc;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,kBAAkB,QAA2D,UAAgF;AACjK,WAAO,EAAE,QAAQ,KAAK,QAAQ,eAAe,IAAI,OAAO,QAAQ,EAAE;AAAA,EACpE;AAAA,EAEA,MAAM,SAAS,QAAkD,UAAuE;AACtI,UAAM,MAAM,KAAK,QAAQ,SAAS,IAAI,OAAO,QAAQ,KAAK,CAAC;AAC3D,WAAO,EAAE,IAAI;AAAA,EACf;AAAA,EAEA,MAAM,mBAAmB,QAA4D,UAAmC;AACtH,SAAK,QAAQ,gBAAgB,OAAO,QAAQ;AAAA,EAC9C;AACF;",
  "names": []
}

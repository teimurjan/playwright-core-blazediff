{
  "version": 3,
  "sources": ["../../../src/server/dispatchers/streamDispatcher.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Dispatcher } from './dispatcher';\nimport { ManualPromise } from '../../utils/isomorphic/manualPromise';\nimport { SdkObject } from '../instrumentation';\n\nimport type { ArtifactDispatcher } from './artifactDispatcher';\nimport type * as channels from '@protocol/channels';\nimport type * as stream from 'stream';\nimport type { Progress } from '@protocol/progress';\n\nclass StreamSdkObject extends SdkObject {\n  readonly stream: stream.Readable;\n\n  constructor(parent: SdkObject, stream: stream.Readable) {\n    super(parent, 'stream');\n    this.stream = stream;\n  }\n}\n\nexport class StreamDispatcher extends Dispatcher<StreamSdkObject, channels.StreamChannel, ArtifactDispatcher> implements channels.StreamChannel {\n  _type_Stream = true;\n  private _ended: boolean = false;\n\n  constructor(scope: ArtifactDispatcher, stream: stream.Readable) {\n    super(scope, new StreamSdkObject(scope._object, stream), 'Stream', {});\n    // In Node v12.9.0+ we can use readableEnded.\n    stream.once('end', () => this._ended =  true);\n    stream.once('error', () => this._ended =  true);\n  }\n\n  async read(params: channels.StreamReadParams, progress: Progress): Promise<channels.StreamReadResult> {\n    const stream = this._object.stream;\n    if (this._ended)\n      return { binary: Buffer.from('') };\n    if (!stream.readableLength) {\n      const readyPromise = new ManualPromise<void>();\n      const done = () => readyPromise.resolve();\n      stream.on('readable', done);\n      stream.on('end', done);\n      stream.on('error', done);\n      await progress.race(readyPromise).finally(() => {\n        stream.off('readable', done);\n        stream.off('end', done);\n        stream.off('error', done);\n      });\n    }\n    const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));\n    return { binary: buffer || Buffer.from('') };\n  }\n\n  async close(params: channels.StreamCloseParams, progress: Progress): Promise<void> {\n    this._object.stream.destroy();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,wBAA2B;AAC3B,2BAA8B;AAC9B,6BAA0B;AAO1B,MAAM,wBAAwB,iCAAU;AAAA,EAGtC,YAAY,QAAmB,QAAyB;AACtD,UAAM,QAAQ,QAAQ;AACtB,SAAK,SAAS;AAAA,EAChB;AACF;AAEO,MAAM,yBAAyB,6BAA0G;AAAA,EAI9I,YAAY,OAA2B,QAAyB;AAC9D,UAAM,OAAO,IAAI,gBAAgB,MAAM,SAAS,MAAM,GAAG,UAAU,CAAC,CAAC;AAJvE,wBAAe;AACf,SAAQ,SAAkB;AAKxB,WAAO,KAAK,OAAO,MAAM,KAAK,SAAU,IAAI;AAC5C,WAAO,KAAK,SAAS,MAAM,KAAK,SAAU,IAAI;AAAA,EAChD;AAAA,EAEA,MAAM,KAAK,QAAmC,UAAwD;AACpG,UAAM,SAAS,KAAK,QAAQ;AAC5B,QAAI,KAAK;AACP,aAAO,EAAE,QAAQ,OAAO,KAAK,EAAE,EAAE;AACnC,QAAI,CAAC,OAAO,gBAAgB;AAC1B,YAAM,eAAe,IAAI,mCAAoB;AAC7C,YAAM,OAAO,MAAM,aAAa,QAAQ;AACxC,aAAO,GAAG,YAAY,IAAI;AAC1B,aAAO,GAAG,OAAO,IAAI;AACrB,aAAO,GAAG,SAAS,IAAI;AACvB,YAAM,SAAS,KAAK,YAAY,EAAE,QAAQ,MAAM;AAC9C,eAAO,IAAI,YAAY,IAAI;AAC3B,eAAO,IAAI,OAAO,IAAI;AACtB,eAAO,IAAI,SAAS,IAAI;AAAA,MAC1B,CAAC;AAAA,IACH;AACA,UAAM,SAAS,OAAO,KAAK,KAAK,IAAI,OAAO,gBAAgB,OAAO,QAAQ,OAAO,cAAc,CAAC;AAChG,WAAO,EAAE,QAAQ,UAAU,OAAO,KAAK,EAAE,EAAE;AAAA,EAC7C;AAAA,EAEA,MAAM,MAAM,QAAoC,UAAmC;AACjF,SAAK,QAAQ,OAAO,QAAQ;AAAA,EAC9B;AACF;",
  "names": []
}

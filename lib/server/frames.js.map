{
  "version": 3,
  "sources": ["../../src/server/frames.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BrowserContext } from './browserContext';\nimport * as dom from './dom';\nimport { TimeoutError } from './errors';\nimport { prepareFilesForUpload } from './fileUploadUtils';\nimport { FrameSelectors } from './frameSelectors';\nimport { helper } from './helper';\nimport { SdkObject } from './instrumentation';\nimport * as js from './javascript';\nimport * as network from './network';\nimport { Page } from './page';\nimport { isAbortError, ProgressController } from './progress';\nimport * as types from './types';\nimport { LongStandingScope, asLocator, assert, constructURLBasedOnBaseURL, makeWaitForNextTask, renderTitleForCall } from '../utils';\nimport { isSessionClosedError } from './protocolError';\nimport { debugLogger } from './utils/debugLogger';\nimport { eventsHelper } from './utils/eventsHelper';\nimport {  isInvalidSelectorError } from '../utils/isomorphic/selectorParser';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\nimport { compressCallLog } from './callLog';\n\nimport type { ConsoleMessage } from './console';\nimport type { ElementStateWithoutStable, FrameExpectParams, InjectedScript } from '@injected/injectedScript';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type { RegisteredListener } from './utils/eventsHelper';\nimport type { ParsedSelector } from '../utils/isomorphic/selectorParser';\nimport type * as channels from '@protocol/channels';\n\ntype ContextData = {\n  contextPromise: ManualPromise<dom.FrameExecutionContext | { destroyedReason: string }>;\n  context: dom.FrameExecutionContext | null;\n};\n\ntype DocumentInfo = {\n  // Unfortunately, we don't have documentId when we find out about\n  // a pending navigation from things like frameScheduledNavigaiton.\n  documentId: string | undefined,\n  request: network.Request | undefined,\n};\n\nexport type GotoResult = {\n  newDocumentId?: string,\n};\n\ntype ConsoleTagHandler = () => void;\n\ntype RegularLifecycleEvent = Exclude<types.LifecycleEvent, 'networkidle'>;\n\nexport type FunctionWithSource = (source: { context: BrowserContext, page: Page, frame: Frame}, ...args: any) => any;\n\nexport type NavigationEvent = {\n  // New frame url after navigation.\n  url: string,\n  // New frame name after navigation.\n  name: string,\n  // Information about the new document for cross-document navigations.\n  // Undefined for same-document navigations.\n  newDocument?: DocumentInfo,\n  // Error for cross-document navigations if any. When error is present,\n  // the navigation did not commit.\n  error?: Error,\n  // Whether this event should be visible to the clients via the public APIs.\n  isPublic?: boolean;\n};\n\ntype ElementCallback<T, R> = (injected: InjectedScript, element: Element, data: T) => R;\n\nexport class NavigationAbortedError extends Error {\n  readonly documentId?: string;\n  constructor(documentId: string | undefined, message: string) {\n    super(message);\n    this.documentId = documentId;\n  }\n}\n\ntype ExpectResult = { matches: boolean, received?: any, log?: string[], timedOut?: boolean };\n\nconst kDummyFrameId = '<dummy>';\n\nexport class FrameManager {\n  private _page: Page;\n  private _frames = new Map<string, Frame>();\n  private _mainFrame: Frame;\n  readonly _consoleMessageTags = new Map<string, ConsoleTagHandler>();\n  readonly _signalBarriers = new Set<SignalBarrier>();\n  private _webSockets = new Map<string, network.WebSocket>();\n\n  constructor(page: Page) {\n    this._page = page;\n    this._mainFrame = undefined as any as Frame;\n  }\n\n  createDummyMainFrameIfNeeded() {\n    if (!this._mainFrame)\n      this.frameAttached(kDummyFrameId, null);\n  }\n\n  dispose() {\n    for (const frame of this._frames.values()) {\n      frame._stopNetworkIdleTimer();\n      frame._invalidateNonStallingEvaluations('Target crashed');\n    }\n  }\n\n  mainFrame(): Frame {\n    return this._mainFrame;\n  }\n\n  frames() {\n    const frames: Frame[] = [];\n    collect(this._mainFrame);\n    return frames;\n\n    function collect(frame: Frame) {\n      frames.push(frame);\n      for (const subframe of frame.childFrames())\n        collect(subframe);\n    }\n  }\n\n  frame(frameId: string): Frame | null {\n    return this._frames.get(frameId) || null;\n  }\n\n  frameAttached(frameId: string, parentFrameId: string | null | undefined): Frame {\n    const parentFrame = parentFrameId ? this._frames.get(parentFrameId)! : null;\n    if (!parentFrame) {\n      if (this._mainFrame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(this._mainFrame._id);\n        this._mainFrame._id = frameId;\n      } else {\n        assert(!this._frames.has(frameId));\n        this._mainFrame = new Frame(this._page, frameId, parentFrame);\n      }\n      this._frames.set(frameId, this._mainFrame);\n      return this._mainFrame;\n    } else {\n      assert(!this._frames.has(frameId));\n      const frame = new Frame(this._page, frameId, parentFrame);\n      this._frames.set(frameId, frame);\n      this._page.emit(Page.Events.FrameAttached, frame);\n      return frame;\n    }\n  }\n\n  async waitForSignalsCreatedBy<T>(progress: Progress, waitAfter: boolean, action: () => Promise<T>): Promise<T> {\n    if (!waitAfter)\n      return action();\n    const barrier = new SignalBarrier(progress);\n    this._signalBarriers.add(barrier);\n    try {\n      const result = await action();\n      await progress.race(this._page.delegate.inputActionEpilogue());\n      await barrier.waitFor();\n      // Resolve in the next task, after all waitForNavigations.\n      await new Promise<void>(makeWaitForNextTask());\n      return result;\n    } finally {\n      this._signalBarriers.delete(barrier);\n    }\n  }\n\n  frameWillPotentiallyRequestNavigation() {\n    for (const barrier of this._signalBarriers)\n      barrier.retain();\n  }\n\n  frameDidPotentiallyRequestNavigation() {\n    for (const barrier of this._signalBarriers)\n      barrier.release();\n  }\n\n  frameRequestedNavigation(frameId: string, documentId?: string) {\n    const frame = this._frames.get(frameId);\n    if (!frame)\n      return;\n    for (const barrier of this._signalBarriers)\n      barrier.addFrameNavigation(frame);\n    if (frame.pendingDocument() && frame.pendingDocument()!.documentId === documentId) {\n      // Do not override request with undefined.\n      return;\n    }\n\n    const request = documentId ? Array.from(frame._inflightRequests).find(request => request._documentId === documentId) : undefined;\n    frame.setPendingDocument({ documentId, request });\n  }\n\n  frameCommittedNewDocumentNavigation(frameId: string, url: string, name: string, documentId: string, initial: boolean) {\n    const frame = this._frames.get(frameId)!;\n    this.removeChildFramesRecursively(frame);\n    this.clearWebSockets(frame);\n    frame._url = url;\n    frame._name = name;\n\n    let keepPending: DocumentInfo | undefined;\n    const pendingDocument = frame.pendingDocument();\n    if (pendingDocument) {\n      if (pendingDocument.documentId === undefined) {\n        // Pending with unknown documentId - assume it is the one being committed.\n        pendingDocument.documentId = documentId;\n      }\n      if (pendingDocument.documentId === documentId) {\n        // Committing a pending document.\n        frame._currentDocument = pendingDocument;\n      } else {\n        // Sometimes, we already have a new pending when the old one commits.\n        // An example would be Chromium error page followed by a new navigation request,\n        // where the error page commit arrives after Network.requestWillBeSent for the\n        // new navigation.\n        // We commit, but keep the pending request since it's not done yet.\n        keepPending = pendingDocument;\n        frame._currentDocument = { documentId, request: undefined };\n      }\n      frame.setPendingDocument(undefined);\n    } else {\n      // No pending - just commit a new document.\n      frame._currentDocument = { documentId, request: undefined };\n    }\n\n    frame._onClearLifecycle();\n    const navigationEvent: NavigationEvent = { url, name, newDocument: frame._currentDocument, isPublic: true };\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n    if (!initial) {\n      debugLogger.log('api', `  navigated to \"${url}\"`);\n      this._page.frameNavigatedToNewDocument(frame);\n    }\n    // Restore pending if any - see comments above about keepPending.\n    frame.setPendingDocument(keepPending);\n  }\n\n  frameCommittedSameDocumentNavigation(frameId: string, url: string) {\n    const frame = this._frames.get(frameId);\n    if (!frame)\n      return;\n    const pending = frame.pendingDocument();\n    if (pending && pending.documentId === undefined && pending.request === undefined) {\n      // WebKit has notified about the same-document navigation being requested, so clear it.\n      frame.setPendingDocument(undefined);\n    }\n    frame._url = url;\n    const navigationEvent: NavigationEvent = { url, name: frame._name, isPublic: true };\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n    debugLogger.log('api', `  navigated to \"${url}\"`);\n  }\n\n  frameAbortedNavigation(frameId: string, errorText: string, documentId?: string) {\n    const frame = this._frames.get(frameId);\n    if (!frame || !frame.pendingDocument())\n      return;\n    if (documentId !== undefined && frame.pendingDocument()!.documentId !== documentId)\n      return;\n    const navigationEvent: NavigationEvent = {\n      url: frame._url,\n      name: frame._name,\n      newDocument: frame.pendingDocument(),\n      error: new NavigationAbortedError(documentId, errorText),\n      isPublic: !(documentId && frame._redirectedNavigations.has(documentId)),\n    };\n    frame.setPendingDocument(undefined);\n    this._fireInternalFrameNavigation(frame, navigationEvent);\n  }\n\n  frameDetached(frameId: string) {\n    const frame = this._frames.get(frameId);\n    if (frame) {\n      this._removeFramesRecursively(frame);\n      this._page.mainFrame()._recalculateNetworkIdle();\n    }\n  }\n\n  frameLifecycleEvent(frameId: string, event: RegularLifecycleEvent) {\n    const frame = this._frames.get(frameId);\n    if (frame)\n      frame._onLifecycleEvent(event);\n  }\n\n  requestStarted(request: network.Request, route?: network.RouteDelegate) {\n    const frame = request.frame()!;\n    this._inflightRequestStarted(request);\n    if (request._documentId)\n      frame.setPendingDocument({ documentId: request._documentId, request });\n    if (request._isFavicon) {\n      // Abort favicon requests to avoid network access in case of interception.\n      route?.abort('aborted').catch(() => {});\n      return;\n    }\n    this._page.emitOnContext(BrowserContext.Events.Request, request);\n    if (route)\n      new network.Route(request, route).handle([...this._page.requestInterceptors, ...this._page.browserContext.requestInterceptors]);\n  }\n\n  requestReceivedResponse(response: network.Response) {\n    if (response.request()._isFavicon)\n      return;\n    this._page.emitOnContext(BrowserContext.Events.Response, response);\n  }\n\n  reportRequestFinished(request: network.Request, response: network.Response | null) {\n    this._inflightRequestFinished(request);\n    if (request._isFavicon)\n      return;\n    this._page.emitOnContext(BrowserContext.Events.RequestFinished, { request, response });\n  }\n\n  requestFailed(request: network.Request, canceled: boolean) {\n    const frame = request.frame()!;\n    this._inflightRequestFinished(request);\n    if (frame.pendingDocument() && frame.pendingDocument()!.request === request) {\n      let errorText = request.failure()!.errorText;\n      if (canceled)\n        errorText += '; maybe frame was detached?';\n      this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument()!.documentId);\n    }\n    if (request._isFavicon)\n      return;\n    this._page.emitOnContext(BrowserContext.Events.RequestFailed, request);\n  }\n\n  removeChildFramesRecursively(frame: Frame) {\n    for (const child of frame.childFrames())\n      this._removeFramesRecursively(child);\n  }\n\n  private _removeFramesRecursively(frame: Frame) {\n    this.removeChildFramesRecursively(frame);\n    frame._onDetached();\n    this._frames.delete(frame._id);\n    if (!this._page.isClosed())\n      this._page.emit(Page.Events.FrameDetached, frame);\n  }\n\n  private _inflightRequestFinished(request: network.Request) {\n    const frame = request.frame()!;\n    if (request._isFavicon)\n      return;\n    if (!frame._inflightRequests.has(request))\n      return;\n    frame._inflightRequests.delete(request);\n    if (frame._inflightRequests.size === 0)\n      frame._startNetworkIdleTimer();\n  }\n\n  private _inflightRequestStarted(request: network.Request) {\n    const frame = request.frame()!;\n    if (request._isFavicon)\n      return;\n    frame._inflightRequests.add(request);\n    if (frame._inflightRequests.size === 1)\n      frame._stopNetworkIdleTimer();\n  }\n\n  interceptConsoleMessage(message: ConsoleMessage): boolean {\n    if (message.type() !== 'debug')\n      return false;\n    const tag = message.text();\n    const handler = this._consoleMessageTags.get(tag);\n    if (!handler)\n      return false;\n    this._consoleMessageTags.delete(tag);\n    handler();\n    return true;\n  }\n\n  clearWebSockets(frame: Frame) {\n    // TODO: attribute sockets to frames.\n    if (frame.parentFrame())\n      return;\n    this._webSockets.clear();\n  }\n\n  onWebSocketCreated(requestId: string, url: string) {\n    const ws = new network.WebSocket(this._page, url);\n    this._webSockets.set(requestId, ws);\n  }\n\n  onWebSocketRequest(requestId: string) {\n    const ws = this._webSockets.get(requestId);\n    if (ws && ws.markAsNotified())\n      this._page.emit(Page.Events.WebSocket, ws);\n  }\n\n  onWebSocketResponse(requestId: string, status: number, statusText: string) {\n    const ws = this._webSockets.get(requestId);\n    if (status < 400)\n      return;\n    if (ws)\n      ws.error(`${statusText}: ${status}`);\n  }\n\n  onWebSocketFrameSent(requestId: string, opcode: number, data: string) {\n    const ws = this._webSockets.get(requestId);\n    if (ws)\n      ws.frameSent(opcode, data);\n  }\n\n  webSocketFrameReceived(requestId: string, opcode: number, data: string) {\n    const ws = this._webSockets.get(requestId);\n    if (ws)\n      ws.frameReceived(opcode, data);\n  }\n\n  webSocketClosed(requestId: string) {\n    const ws = this._webSockets.get(requestId);\n    if (ws)\n      ws.closed();\n    this._webSockets.delete(requestId);\n  }\n\n  webSocketError(requestId: string, errorMessage: string): void {\n    const ws = this._webSockets.get(requestId);\n    if (ws)\n      ws.error(errorMessage);\n  }\n\n  private _fireInternalFrameNavigation(frame: Frame, event: NavigationEvent) {\n    frame.emit(Frame.Events.InternalNavigation, event);\n  }\n}\n\nexport class Frame extends SdkObject {\n  static Events = {\n    InternalNavigation: 'internalnavigation',\n    AddLifecycle: 'addlifecycle',\n    RemoveLifecycle: 'removelifecycle',\n  };\n\n  _id: string;\n  _firedLifecycleEvents = new Set<types.LifecycleEvent>();\n  private _firedNetworkIdleSelf = false;\n  _currentDocument: DocumentInfo;\n  private _pendingDocument: DocumentInfo | undefined;\n  readonly _page: Page;\n  private _parentFrame: Frame | null;\n  _url = '';\n  private _contextData = new Map<types.World, ContextData>();\n  private _childFrames = new Set<Frame>();\n  _name = '';\n  _inflightRequests = new Set<network.Request>();\n  private _networkIdleTimer: NodeJS.Timeout | undefined;\n  private _setContentCounter = 0;\n  readonly _detachedScope = new LongStandingScope();\n  private _raceAgainstEvaluationStallingEventsPromises = new Set<ManualPromise<any>>();\n  readonly _redirectedNavigations = new Map<string, { url: string, gotoPromise: Promise<network.Response | null> }>(); // documentId -> data\n  readonly selectors: FrameSelectors;\n\n  constructor(page: Page, id: string, parentFrame: Frame | null) {\n    super(page, 'frame');\n    this.attribution.frame = this;\n    this._id = id;\n    this._page = page;\n    this._parentFrame = parentFrame;\n    this._currentDocument = { documentId: undefined, request: undefined };\n    this.selectors = new FrameSelectors(this);\n\n    this._contextData.set('main', { contextPromise: new ManualPromise(), context: null });\n    this._contextData.set('utility', { contextPromise: new ManualPromise(), context: null });\n    this._setContext('main', null);\n    this._setContext('utility', null);\n\n    if (this._parentFrame)\n      this._parentFrame._childFrames.add(this);\n\n    this._firedLifecycleEvents.add('commit');\n    if (id !== kDummyFrameId)\n      this._startNetworkIdleTimer();\n  }\n\n  isDetached(): boolean {\n    return this._detachedScope.isClosed();\n  }\n\n  _onLifecycleEvent(event: RegularLifecycleEvent) {\n    if (this._firedLifecycleEvents.has(event))\n      return;\n    this._firedLifecycleEvents.add(event);\n    this.emit(Frame.Events.AddLifecycle, event);\n    if (this === this._page.mainFrame() && this._url !== 'about:blank')\n      debugLogger.log('api', `  \"${event}\" event fired`);\n    this._page.mainFrame()._recalculateNetworkIdle();\n  }\n\n  _onClearLifecycle() {\n    for (const event of this._firedLifecycleEvents)\n      this.emit(Frame.Events.RemoveLifecycle, event);\n    this._firedLifecycleEvents.clear();\n    // Keep the current navigation request if any.\n    this._inflightRequests = new Set(Array.from(this._inflightRequests).filter(request => request === this._currentDocument.request));\n    this._stopNetworkIdleTimer();\n    if (this._inflightRequests.size === 0)\n      this._startNetworkIdleTimer();\n    this._page.mainFrame()._recalculateNetworkIdle(this);\n    this._onLifecycleEvent('commit');\n  }\n\n  setPendingDocument(documentInfo: DocumentInfo | undefined) {\n    this._pendingDocument = documentInfo;\n    if (documentInfo)\n      this._invalidateNonStallingEvaluations('Navigation interrupted the evaluation');\n  }\n\n  pendingDocument(): DocumentInfo | undefined {\n    return this._pendingDocument;\n  }\n\n  _invalidateNonStallingEvaluations(message: string) {\n    if (!this._raceAgainstEvaluationStallingEventsPromises.size)\n      return;\n    const error = new Error(message);\n    for (const promise of this._raceAgainstEvaluationStallingEventsPromises)\n      promise.reject(error);\n  }\n\n  async raceAgainstEvaluationStallingEvents<T>(cb: () => Promise<T>): Promise<T> {\n    if (this._pendingDocument)\n      throw new Error('Frame is currently attempting a navigation');\n    if (this._page.browserContext.dialogManager.hasOpenDialogsForPage(this._page))\n      throw new Error('Open JavaScript dialog prevents evaluation');\n\n    const promise = new ManualPromise<T>();\n    this._raceAgainstEvaluationStallingEventsPromises.add(promise);\n    try {\n      return await Promise.race([\n        cb(),\n        promise\n      ]);\n    } finally {\n      this._raceAgainstEvaluationStallingEventsPromises.delete(promise);\n    }\n  }\n\n  nonStallingRawEvaluateInExistingMainContext(expression: string): Promise<any> {\n    return this.raceAgainstEvaluationStallingEvents(() => {\n      const context = this._existingMainContext();\n      if (!context)\n        throw new Error('Frame does not yet have a main execution context');\n      return context.rawEvaluateJSON(expression);\n    });\n  }\n\n  nonStallingEvaluateInExistingContext(expression: string, world: types.World): Promise<any> {\n    return this.raceAgainstEvaluationStallingEvents(() => {\n      const context = this._contextData.get(world)?.context;\n      if (!context)\n        throw new Error('Frame does not yet have the execution context');\n      return context.evaluateExpression(expression, { isFunction: false });\n    });\n  }\n\n  _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle?: Frame) {\n    let isNetworkIdle = this._firedNetworkIdleSelf;\n    for (const child of this._childFrames) {\n      child._recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle);\n      // We require networkidle event to be fired in the whole frame subtree, and then consider it done.\n      if (!child._firedLifecycleEvents.has('networkidle'))\n        isNetworkIdle = false;\n    }\n    if (isNetworkIdle && !this._firedLifecycleEvents.has('networkidle')) {\n      this._firedLifecycleEvents.add('networkidle');\n      this.emit(Frame.Events.AddLifecycle, 'networkidle');\n      if (this === this._page.mainFrame() && this._url !== 'about:blank')\n        debugLogger.log('api', `  \"networkidle\" event fired`);\n    }\n    if (frameThatAllowsRemovingNetworkIdle !== this && this._firedLifecycleEvents.has('networkidle') && !isNetworkIdle) {\n      // Usually, networkidle is fired once and not removed after that.\n      // However, when we clear them right before a new commit, this is allowed for a particular frame.\n      this._firedLifecycleEvents.delete('networkidle');\n      this.emit(Frame.Events.RemoveLifecycle, 'networkidle');\n    }\n  }\n\n  async raceNavigationAction(progress: Progress, action: () => Promise<network.Response | null>): Promise<network.Response | null> {\n    return LongStandingScope.raceMultiple([\n      this._detachedScope,\n      this._page.openScope,\n    ], action().catch(e => {\n      if (e instanceof NavigationAbortedError && e.documentId) {\n        const data = this._redirectedNavigations.get(e.documentId);\n        if (data) {\n          progress.log(`waiting for redirected navigation to \"${data.url}\"`);\n          return progress.race(data.gotoPromise);\n        }\n      }\n      throw e;\n    }));\n  }\n\n  redirectNavigation(url: string, documentId: string, referer: string | undefined) {\n    const controller = new ProgressController();\n    const data = {\n      url,\n      gotoPromise: controller.run(progress => this.gotoImpl(progress, url, { referer }), 0),\n    };\n    this._redirectedNavigations.set(documentId, data);\n    data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));\n  }\n\n  async goto(progress: Progress, url: string, options: types.GotoOptions = {}): Promise<network.Response | null> {\n    const constructedNavigationURL = constructURLBasedOnBaseURL(this._page.browserContext._options.baseURL, url);\n    return this.raceNavigationAction(progress, async () => this.gotoImpl(progress, constructedNavigationURL, options));\n  }\n\n  async gotoImpl(progress: Progress, url: string, options: types.GotoOptions): Promise<network.Response | null> {\n    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    progress.log(`navigating to \"${url}\", waiting until \"${waitUntil}\"`);\n    const headers = this._page.extraHTTPHeaders() || [];\n    const refererHeader = headers.find(h => h.name.toLowerCase() === 'referer');\n    let referer = refererHeader ? refererHeader.value : undefined;\n    if (options.referer !== undefined) {\n      if (referer !== undefined && referer !== options.referer)\n        throw new Error('\"referer\" is already specified as extra HTTP header');\n      referer = options.referer;\n    }\n    url = helper.completeUserURL(url);\n\n    const navigationEvents: NavigationEvent[] = [];\n    const collectNavigations = (arg: NavigationEvent) => navigationEvents.push(arg);\n    this.on(Frame.Events.InternalNavigation, collectNavigations);\n    const navigateResult = await progress.race(this._page.delegate.navigateFrame(this, url, referer)).finally(\n        () => this.off(Frame.Events.InternalNavigation, collectNavigations));\n\n    let event: NavigationEvent;\n    if (navigateResult.newDocumentId) {\n      const predicate = (event: NavigationEvent) => {\n        // We are interested either in this specific document, or any other document that\n        // did commit and replaced the expected document.\n        return event.newDocument && (event.newDocument.documentId === navigateResult.newDocumentId || !event.error);\n      };\n      const events = navigationEvents.filter(predicate);\n      if (events.length)\n        event = events[0];\n      else\n        event = await helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, predicate).promise;\n      if (event.newDocument!.documentId !== navigateResult.newDocumentId) {\n        // This is just a sanity check. In practice, new navigation should\n        // cancel the previous one and report \"request cancelled\"-like error.\n        throw new NavigationAbortedError(navigateResult.newDocumentId, `Navigation to \"${url}\" is interrupted by another navigation to \"${event.url}\"`);\n      }\n      if (event.error)\n        throw event.error;\n    } else {\n      // Wait for same document navigation.\n      const predicate = (e: NavigationEvent) => !e.newDocument;\n      const events = navigationEvents.filter(predicate);\n      if (events.length)\n        event = events[0];\n      else\n        event = await helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, predicate).promise;\n    }\n\n    if (!this._firedLifecycleEvents.has(waitUntil))\n      await helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e: types.LifecycleEvent) => e === waitUntil).promise;\n\n    const request = event.newDocument ? event.newDocument.request : undefined;\n    const response = request ? progress.race(request._finalRequest().response()) : null;\n    return response;\n  }\n\n  async _waitForNavigation(progress: Progress, requiresNewDocument: boolean, options: types.NavigateOptions): Promise<network.Response | null> {\n    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);\n    progress.log(`waiting for navigation until \"${waitUntil}\"`);\n\n    const navigationEvent: NavigationEvent = await helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, (event: NavigationEvent) => {\n      // Any failed navigation results in a rejection.\n      if (event.error)\n        return true;\n      if (requiresNewDocument && !event.newDocument)\n        return false;\n      progress.log(`  navigated to \"${this._url}\"`);\n      return true;\n    }).promise;\n    if (navigationEvent.error)\n      throw navigationEvent.error;\n\n    if (!this._firedLifecycleEvents.has(waitUntil))\n      await helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e: types.LifecycleEvent) => e === waitUntil).promise;\n\n    const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : undefined;\n    return request ? progress.race(request._finalRequest().response()) : null;\n  }\n\n  async _waitForLoadState(progress: Progress, state: types.LifecycleEvent): Promise<void> {\n    const waitUntil = verifyLifecycle('state', state);\n    if (!this._firedLifecycleEvents.has(waitUntil))\n      await helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e: types.LifecycleEvent) => e === waitUntil).promise;\n  }\n\n  async frameElement(): Promise<dom.ElementHandle> {\n    return this._page.delegate.getFrameElement(this);\n  }\n\n  _context(world: types.World): Promise<dom.FrameExecutionContext> {\n    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {\n      if (contextOrDestroyedReason instanceof js.ExecutionContext)\n        return contextOrDestroyedReason;\n      throw new Error(contextOrDestroyedReason.destroyedReason);\n    });\n  }\n\n  _mainContext(): Promise<dom.FrameExecutionContext> {\n    return this._context('main');\n  }\n\n  private _existingMainContext(): dom.FrameExecutionContext | null {\n    return this._contextData.get('main')?.context || null;\n  }\n\n  _utilityContext(): Promise<dom.FrameExecutionContext> {\n    return this._context('utility');\n  }\n\n  async evaluateExpression(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<any> {\n    const context = await this._context(options.world ?? 'main');\n    const value = await context.evaluateExpression(expression, options, arg);\n    return value;\n  }\n\n  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<js.JSHandle<any>> {\n    const context = await this._context(options.world ?? 'main');\n    const value = await context.evaluateExpressionHandle(expression, options, arg);\n    return value;\n  }\n\n  async querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null> {\n    debugLogger.log('api', `    finding element using the selector \"${selector}\"`);\n    return this.selectors.query(selector, options);\n  }\n\n  async waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {\n    if ((options as any).visibility)\n      throw new Error('options.visibility is not supported, did you mean options.state?');\n    if ((options as any).waitFor && (options as any).waitFor !== 'visible')\n      throw new Error('options.waitFor is not supported, did you mean options.state?');\n    const { state = 'visible' } = options;\n    if (!['attached', 'detached', 'visible', 'hidden'].includes(state))\n      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);\n    if (performActionPreChecksAndLog)\n      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);\n    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n      if (performActionPreChecksAndLog)\n        await this._page.performActionPreChecks(progress);\n\n      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));\n      if (!resolved) {\n        if (state === 'hidden' || state === 'detached')\n          return null;\n        return continuePolling;\n      }\n      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, root }) => {\n        if (root && !root.isConnected)\n          throw injected.createStacklessError('Element is not attached to the DOM');\n        const elements = injected.querySelectorAll(info.parsed, root || document);\n        const element: Element | undefined  = elements[0];\n        const visible = element ? injected.utils.isElementVisible(element) : false;\n        let log = '';\n        if (elements.length > 1) {\n          if (info.strict)\n            throw injected.strictModeViolationError(info.parsed, elements);\n          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;\n        } else if (element) {\n          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;\n        }\n        return { log, element, visible, attached: !!element };\n      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));\n      const { log, visible, attached } = await progress.race(result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached })));\n      if (log)\n        progress.log(log);\n      const success = { attached, detached: !attached, visible, hidden: !visible }[state];\n      if (!success) {\n        result.dispose();\n        return continuePolling;\n      }\n      if (options.omitReturnValue) {\n        result.dispose();\n        return null;\n      }\n      const element = state === 'attached' || state === 'visible' ? await progress.race(result.evaluateHandle(r => r.element)) : null;\n      result.dispose();\n      if (!element)\n        return null;\n      if ((options as any).__testHookBeforeAdoptNode)\n        await progress.race((options as any).__testHookBeforeAdoptNode());\n      try {\n        const mainContext = await progress.race(resolved.frame._mainContext());\n        return await progress.race(element._adoptTo(mainContext));\n      } catch (e) {\n        return continuePolling;\n      }\n    });\n    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;\n  }\n\n  async dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object = {}, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void> {\n    await this._callOnElementOnceMatches(progress, selector, (injectedScript, element, data) => {\n      injectedScript.dispatchEvent(element, data.type, data.eventInit);\n    }, { type, eventInit }, { mainWorld: true, ...options }, scope);\n  }\n\n  async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {\n    const handle = await this.selectors.query(selector, { strict }, scope);\n    if (!handle)\n      throw new Error(`Failed to find element matching selector \"${selector}\"`);\n    const result = await handle.evaluateExpression(expression, { isFunction }, arg);\n    handle.dispose();\n    return result;\n  }\n\n  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {\n    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);\n    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);\n    arrayHandle.dispose();\n    return result;\n  }\n\n  async maskSelectors(selectors: ParsedSelector[], color: string): Promise<void> {\n    const context = await this._utilityContext();\n    const injectedScript = await context.injectedScript();\n    await injectedScript.evaluate((injected, { parsed, color }) => {\n      injected.maskSelectors(parsed, color);\n    }, { parsed: selectors, color: color });\n  }\n\n  async querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]> {\n    return this.selectors.queryAll(selector);\n  }\n\n  async queryCount(selector: string, options: any): Promise<number> {\n    try {\n      return await this.selectors.queryCount(selector, options);\n    } catch (e) {\n      if (this.isNonRetriableError(e))\n        throw e;\n      return 0;\n    }\n  }\n\n  async content(): Promise<string> {\n    try {\n      const context = await this._utilityContext();\n      return await context.evaluate(() => {\n        let retVal = '';\n        if (document.doctype)\n          retVal = new XMLSerializer().serializeToString(document.doctype);\n        if (document.documentElement)\n          retVal += document.documentElement.outerHTML;\n        return retVal;\n      });\n    } catch (e) {\n      if (this.isNonRetriableError(e))\n        throw e;\n      throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);\n    }\n  }\n\n  async setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void> {\n    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;\n    await this.raceNavigationAction(progress, async () => {\n      const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;\n      progress.log(`setting frame content, waiting until \"${waitUntil}\"`);\n      const context = await progress.race(this._utilityContext());\n      const tagPromise = new ManualPromise<void>();\n      this._page.frameManager._consoleMessageTags.set(tag, () => {\n        // Clear lifecycle right after document.open() - see 'tag' below.\n        this._onClearLifecycle();\n        tagPromise.resolve();\n      });\n      const lifecyclePromise = progress.race(tagPromise).then(() => this._waitForLoadState(progress, waitUntil));\n      const contentPromise = progress.race(context.evaluate(({ html, tag }) => {\n        document.open();\n        console.debug(tag);  // eslint-disable-line no-console\n        document.write(html);\n        document.close();\n      }, { html, tag }));\n      await Promise.all([contentPromise, lifecyclePromise]);\n      return null;\n    }).finally(() => {\n      this._page.frameManager._consoleMessageTags.delete(tag);\n    });\n  }\n\n  name(): string {\n    return this._name || '';\n  }\n\n  url(): string {\n    return this._url;\n  }\n\n  origin(): string | undefined {\n    if (!this._url.startsWith('http'))\n      return;\n    return network.parseURL(this._url)?.origin;\n  }\n\n  parentFrame(): Frame | null {\n    return this._parentFrame;\n  }\n\n  childFrames(): Frame[] {\n    return Array.from(this._childFrames);\n  }\n\n  async addScriptTag(params: {\n    url?: string,\n    content?: string,\n    type?: string,\n  }): Promise<dom.ElementHandle> {\n    const {\n      url = null,\n      content = null,\n      type = ''\n    } = params;\n    if (!url && !content)\n      throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    const context = await this._mainContext();\n    return this._raceWithCSPError(async () => {\n      if (url !== null)\n        return (await context.evaluateHandle(addScriptUrl, { url, type })).asElement()!;\n      const result = (await context.evaluateHandle(addScriptContent, { content: content!, type })).asElement()!;\n      // Another round trip to the browser to ensure that we receive CSP error messages\n      // (if any) logged asynchronously in a separate task on the content main thread.\n      if (this._page.delegate.cspErrorsAsynchronousForInlineScripts)\n        await context.evaluate(() => true);\n      return result;\n    });\n\n    async function addScriptUrl(params: { url: string, type: string }): Promise<HTMLElement> {\n      const script = document.createElement('script');\n      script.src = params.url;\n      if (params.type)\n        script.type = params.type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n\n    function addScriptContent(params: { content: string, type: string }): HTMLElement {\n      const script = document.createElement('script');\n      script.type = params.type || 'text/javascript';\n      script.text = params.content;\n      let error = null;\n      script.onerror = e => error = e;\n      document.head.appendChild(script);\n      if (error)\n        throw error;\n      return script;\n    }\n  }\n\n  async addStyleTag(params: { url?: string, content?: string }): Promise<dom.ElementHandle> {\n    const {\n      url = null,\n      content = null\n    } = params;\n    if (!url && !content)\n      throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    const context = await this._mainContext();\n    return this._raceWithCSPError(async () => {\n      if (url !== null)\n        return (await context.evaluateHandle(addStyleUrl, url)).asElement()!;\n      return (await context.evaluateHandle(addStyleContent, content!)).asElement()!;\n    });\n\n    async function addStyleUrl(url: string): Promise<HTMLElement> {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n\n    async function addStyleContent(content: string): Promise<HTMLElement> {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n\n  private async _raceWithCSPError(func: () => Promise<dom.ElementHandle>): Promise<dom.ElementHandle> {\n    const listeners: RegisteredListener[] = [];\n    let result: dom.ElementHandle;\n    let error: Error | undefined;\n    let cspMessage: ConsoleMessage | undefined;\n    const actionPromise = func().then(r => result = r).catch(e => error = e);\n    const errorPromise = new Promise<void>(resolve => {\n      listeners.push(eventsHelper.addEventListener(this._page.browserContext, BrowserContext.Events.Console, (message: ConsoleMessage) => {\n        if (message.page() !== this._page || message.type() !== 'error')\n          return;\n        if (message.text().includes('Content-Security-Policy') || message.text().includes('Content Security Policy')) {\n          cspMessage = message;\n          resolve();\n        }\n      }));\n    });\n    await Promise.race([actionPromise, errorPromise]);\n    eventsHelper.removeEventListeners(listeners);\n    if (cspMessage)\n      throw new Error(cspMessage.text());\n    if (error)\n      throw error;\n    return result!;\n  }\n\n  async retryWithProgressAndTimeouts<R>(progress: Progress, timeouts: number[], action: (continuePolling: symbol) => Promise<R | symbol>): Promise<R> {\n    const continuePolling = Symbol('continuePolling');\n    timeouts = [0, ...timeouts];\n    let timeoutIndex = 0;\n    while (true) {\n      const timeout = timeouts[Math.min(timeoutIndex++, timeouts.length - 1)];\n      if (timeout) {\n        // Make sure we react immediately upon page close or frame detach.\n        // We need this to show expected/received values in time.\n        const actionPromise = new Promise(f => setTimeout(f, timeout));\n        await progress.race(LongStandingScope.raceMultiple([\n          this._page.openScope,\n          this._detachedScope,\n        ], actionPromise));\n      }\n      try {\n        const result = await action(continuePolling);\n        if (result === continuePolling)\n          continue;\n        return result as R;\n      } catch (e) {\n        if (this.isNonRetriableError(e))\n          throw e;\n        continue;\n      }\n    }\n  }\n\n  isNonRetriableError(e: Error) {\n    if (isAbortError(e))\n      return true;\n    // Always fail on JavaScript errors or when the main connection is closed.\n    if (js.isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))\n      return true;\n    // Certain errors opt-out of the retries, throw.\n    if (dom.isNonRecoverableDOMError(e) || isInvalidSelectorError(e))\n      return true;\n    // If the call is made on the detached frame - throw.\n    if (this.isDetached())\n      return true;\n    // Retry upon all other errors.\n    return false;\n  }\n\n  private async _retryWithProgressIfNotConnected<R>(\n    progress: Progress,\n    selector: string,\n    strict: boolean | undefined,\n    performActionPreChecks: boolean,\n    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {\n    progress.log(`waiting for ${this._asLocator(selector)}`);\n    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n      if (performActionPreChecks)\n        await this._page.performActionPreChecks(progress);\n\n      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, { strict }));\n      if (!resolved)\n        return continuePolling;\n      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, callId }) => {\n        const elements = injected.querySelectorAll(info.parsed, document);\n        if (callId)\n          injected.markTargetElements(new Set(elements), callId);\n        const element = elements[0] as Element | undefined;\n        let log = '';\n        if (elements.length > 1) {\n          if (info.strict)\n            throw injected.strictModeViolationError(info.parsed, elements);\n          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;\n        } else if (element) {\n          log = `  locator resolved to ${injected.previewNode(element)}`;\n        }\n        return { log, success: !!element, element };\n      }, { info: resolved.info, callId: progress.metadata.id }));\n      const { log, success } = await progress.race(result.evaluate(r => ({ log: r.log, success: r.success })));\n      if (log)\n        progress.log(log);\n      if (!success) {\n        result.dispose();\n        return continuePolling;\n      }\n      const element = await progress.race(result.evaluateHandle(r => r.element)) as dom.ElementHandle<Element>;\n      result.dispose();\n      try {\n        const result = await action(element);\n        if (result === 'error:notconnected') {\n          progress.log('element was detached from the DOM, retrying');\n          return continuePolling;\n        }\n        return result;\n      } finally {\n        element?.dispose();\n      }\n    });\n  }\n\n  async rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer> {\n    return await this._retryWithProgressIfNotConnected(progress, selector, true /* strict */, true /* performActionPreChecks */, async handle => {\n      await handle._frame.rafrafTimeout(progress, timeout);\n      return await this._page.screenshotter.screenshotElement(progress, handle, options);\n    });\n  }\n\n  async click(progress: Progress, selector: string, options: { noWaitAfter?: boolean } & types.MouseClickOptions & types.PointerActionWaitOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._click(progress, { ...options, waitAfter: !options.noWaitAfter })));\n  }\n\n  async dblclick(progress: Progress, selector: string, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._dblclick(progress, options)));\n  }\n\n  async dragAndDrop(progress: Progress, source: string, target: string, options: types.DragActionOptions & types.PointerActionWaitOptions) {\n    dom.assertDone(await this._retryWithProgressIfNotConnected(progress, source, options.strict, !options.force /* performActionPreChecks */, async handle => {\n      return handle._retryPointerAction(progress, 'move and down', false, async point => {\n        await this._page.mouse.move(progress, point.x, point.y);\n        await this._page.mouse.down(progress);\n      }, {\n        ...options,\n        waitAfter: 'disabled',\n        position: options.sourcePosition,\n      });\n    }));\n    // Note: do not perform locator handlers checkpoint to avoid moving the mouse in the middle of a drag operation.\n    dom.assertDone(await this._retryWithProgressIfNotConnected(progress, target, options.strict, false /* performActionPreChecks */, async handle => {\n      return handle._retryPointerAction(progress, 'move and up', false, async point => {\n        await this._page.mouse.move(progress, point.x, point.y);\n        await this._page.mouse.up(progress);\n      }, {\n        ...options,\n        waitAfter: 'disabled',\n        position: options.targetPosition,\n      });\n    }));\n  }\n\n  async tap(progress: Progress, selector: string, options: types.PointerActionWaitOptions) {\n    if (!this._page.browserContext._options.hasTouch)\n      throw new Error('The page does not support tap. Use hasTouch context option to enable touch support.');\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._tap(progress, options)));\n  }\n\n  async fill(progress: Progress, selector: string, value: string, options: types.StrictOptions & { force?: boolean }) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._fill(progress, value, options)));\n  }\n\n  async focus(progress: Progress, selector: string, options: types.StrictOptions) {\n    dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, true /* performActionPreChecks */, handle => handle._focus(progress)));\n  }\n\n  async blur(progress: Progress, selector: string, options: types.StrictOptions) {\n    dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, true /* performActionPreChecks */, handle => handle._blur(progress)));\n  }\n\n  async resolveSelector(progress: Progress, selector: string, options: { mainWorld?: boolean } = {}): Promise<{ resolvedSelector: string }> {\n    const element = await progress.race(this.selectors.query(selector, options));\n    if (!element)\n      throw new Error(`No element matching ${selector}`);\n\n    const generated = await progress.race(element.evaluateInUtility(async ([injected, node]) => {\n      return injected.generateSelectorSimple(node as unknown as Element);\n    }, {}));\n    if (!generated)\n      throw new Error(`Unable to generate locator for ${selector}`);\n\n    let frame: Frame | null = element._frame;\n    const result = [generated];\n    while (frame?.parentFrame()) {\n      const frameElement = await progress.race(frame.frameElement());\n      if (frameElement) {\n        const generated = await progress.race(frameElement.evaluateInUtility(async ([injected, node]) => {\n          return injected.generateSelectorSimple(node as unknown as Element);\n        }, {}));\n        frameElement.dispose();\n        if (generated === 'error:notconnected' || !generated)\n          throw new Error(`Unable to generate locator for ${selector}`);\n        result.push(generated);\n      }\n      frame = frame.parentFrame();\n    }\n    const resolvedSelector = result.reverse().join(' >> internal:control=enter-frame >> ');\n    return { resolvedSelector };\n  }\n\n  async textContent(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string | null> {\n    return this._callOnElementOnceMatches(progress, selector, (injected, element) => element.textContent, undefined, options, scope);\n  }\n\n  async innerText(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string> {\n    return this._callOnElementOnceMatches(progress, selector, (injectedScript, element) => {\n      if (element.namespaceURI !== 'http://www.w3.org/1999/xhtml')\n        throw injectedScript.createStacklessError('Node is not an HTMLElement');\n      return (element as HTMLElement).innerText;\n    }, undefined, options, scope);\n  }\n\n  async innerHTML(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string> {\n    return this._callOnElementOnceMatches(progress, selector, (injected, element) => element.innerHTML, undefined, options, scope);\n  }\n\n  async getAttribute(progress: Progress, selector: string, name: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string | null> {\n    return this._callOnElementOnceMatches(progress, selector, (injected, element, data) => element.getAttribute(data.name), { name }, options, scope);\n  }\n\n  async inputValue(progress: Progress, selector: string, options: types.StrictOptions, scope?: dom.ElementHandle): Promise<string> {\n    return this._callOnElementOnceMatches(progress, selector, (injectedScript, node) => {\n      const element = injectedScript.retarget(node, 'follow-label');\n      if (!element || (element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA' && element.nodeName !== 'SELECT'))\n        throw injectedScript.createStacklessError('Node is not an <input>, <textarea> or <select> element');\n      return (element as any).value;\n    }, undefined, options, scope);\n  }\n\n  async highlight(progress: Progress, selector: string) {\n    const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector));\n    if (!resolved)\n      return;\n    return await progress.race(resolved.injected.evaluate((injected, { info }) => {\n      return injected.highlight(info.parsed);\n    }, { info: resolved.info }));\n  }\n\n  async hideHighlight() {\n    return this.raceAgainstEvaluationStallingEvents(async () => {\n      const context = await this._utilityContext();\n      const injectedScript = await context.injectedScript();\n      return await injectedScript.evaluate(injected => {\n        return injected.hideHighlight();\n      });\n    });\n  }\n\n  private async _elementState(progress: Progress, selector: string, state: ElementStateWithoutStable, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean> {\n    const result = await this._callOnElementOnceMatches(progress, selector, (injected, element, data) => {\n      return injected.elementState(element, data.state);\n    }, { state }, options, scope);\n    if (result.received === 'error:notconnected')\n      dom.throwElementIsNotAttached();\n    return result.matches;\n  }\n\n  async isVisible(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {\n    progress.log(`  checking visibility of ${this._asLocator(selector)}`);\n    return await this.isVisibleInternal(progress, selector, options, scope);\n  }\n\n  async isVisibleInternal(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {\n    try {\n      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));\n      if (!resolved)\n        return false;\n      return await progress.race(resolved.injected.evaluate((injected, { info, root }) => {\n        const element = injected.querySelector(info.parsed, root || document, info.strict);\n        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };\n        return state.matches;\n      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));\n    } catch (e) {\n      if (this.isNonRetriableError(e))\n        throw e;\n      return false;\n    }\n  }\n\n  async isHidden(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {\n    return !(await this.isVisible(progress, selector, options, scope));\n  }\n\n  async isDisabled(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean> {\n    return this._elementState(progress, selector, 'disabled', options, scope);\n  }\n\n  async isEnabled(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean> {\n    return this._elementState(progress, selector, 'enabled', options, scope);\n  }\n\n  async isEditable(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean> {\n    return this._elementState(progress, selector, 'editable', options, scope);\n  }\n\n  async isChecked(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean> {\n    return this._elementState(progress, selector, 'checked', options, scope);\n  }\n\n  async hover(progress: Progress, selector: string, options: types.PointerActionOptions & types.PointerActionWaitOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._hover(progress, options)));\n  }\n\n  async selectOption(progress: Progress, selector: string, elements: dom.ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[]> {\n    return await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._selectOption(progress, elements, values, options));\n  }\n\n  async setInputFiles(progress: Progress, selector: string, params: Omit<channels.FrameSetInputFilesParams, 'timeout'>): Promise<channels.FrameSetInputFilesResult> {\n    const inputFileItems = await prepareFilesForUpload(this, params);\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, params.strict, true /* performActionPreChecks */, handle => handle._setInputFiles(progress, inputFileItems)));\n  }\n\n  async type(progress: Progress, selector: string, text: string, options: { delay?: number } & types.StrictOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, true /* performActionPreChecks */, handle => handle._type(progress, text, options)));\n  }\n\n  async press(progress: Progress, selector: string, key: string, options: { delay?: number, noWaitAfter?: boolean } & types.StrictOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, true /* performActionPreChecks */, handle => handle._press(progress, key, options)));\n  }\n\n  async check(progress: Progress, selector: string, options: types.PointerActionWaitOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._setChecked(progress, true, options)));\n  }\n\n  async uncheck(progress: Progress, selector: string, options: types.PointerActionWaitOptions) {\n    return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, !options.force /* performActionPreChecks */, handle => handle._setChecked(progress, false, options)));\n  }\n\n  async waitForTimeout(progress: Progress, timeout: number) {\n    return progress.wait(timeout);\n  }\n\n  async ariaSnapshot(progress: Progress, selector: string): Promise<string> {\n    return await this._retryWithProgressIfNotConnected(progress, selector, true /* strict */, true /* performActionPreChecks */, handle => progress.race(handle.ariaSnapshot()));\n  }\n\n  async expect(progress: Progress, selector: string | undefined, options: FrameExpectParams, timeout?: number): Promise<ExpectResult> {\n    progress.log(`${renderTitleForCall(progress.metadata)}${timeout ? ` with timeout ${timeout}ms` : ''}`);\n    const lastIntermediateResult: { received?: any, isSet: boolean } = { isSet: false };\n    const fixupMetadataError = (result: ExpectResult) => {\n      // Library mode special case for the expect errors which are return values, not exceptions.\n      if (result.matches === options.isNot)\n        progress.metadata.error = { error: { name: 'Expect', message: 'Expect failed' } };\n    };\n    try {\n      // Step 1: perform locator handlers checkpoint with a specified timeout.\n      if (selector)\n        progress.log(`waiting for ${this._asLocator(selector)}`);\n      await this._page.performActionPreChecks(progress);\n\n      // Step 2: perform one-shot expect check without a timeout.\n      // Supports the case of `expect(locator).toBeVisible({ timeout: 1 })`\n      // that should succeed when the locator is already visible.\n      try {\n        const resultOneShot = await this._expectInternal(progress, selector, options, lastIntermediateResult, true);\n        if (resultOneShot.matches !== options.isNot)\n          return resultOneShot;\n      } catch (e) {\n        if (this.isNonRetriableError(e))\n          throw e;\n        // Ignore any other errors from one-shot, we'll handle them during retries.\n      }\n\n      // Step 3: auto-retry expect with increasing timeouts. Bounded by the total remaining time.\n      const result = await this.retryWithProgressAndTimeouts(progress, [100, 250, 500, 1000], async continuePolling => {\n        await this._page.performActionPreChecks(progress);\n        const { matches, received } = await this._expectInternal(progress, selector, options, lastIntermediateResult, false);\n        if (matches === options.isNot) {\n          // Keep waiting in these cases:\n          // expect(locator).conditionThatDoesNotMatch\n          // expect(locator).not.conditionThatDoesMatch\n          return continuePolling;\n        }\n        return { matches, received };\n      });\n      fixupMetadataError(result);\n      return result;\n    } catch (e) {\n      // Q: Why not throw upon isNonRetriableError(e) as in other places?\n      // A: We want user to receive a friendly message containing the last intermediate result.\n      if (js.isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))\n        throw e;\n      const result: ExpectResult = { matches: options.isNot, log: compressCallLog(progress.metadata.log) };\n      if (lastIntermediateResult.isSet)\n        result.received = lastIntermediateResult.received;\n      if (e instanceof TimeoutError)\n        result.timedOut = true;\n      fixupMetadataError(result);\n      return result;\n    }\n  }\n\n  private async _expectInternal(progress: Progress, selector: string | undefined, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean }, noAbort: boolean) {\n    // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.\n    const race = <T>(p: Promise<T>) => noAbort ? p : progress.race(p);\n    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : undefined;\n\n    const { frame, info } = selectorInFrame || { frame: this, info: undefined };\n    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');\n    const context = await race(frame._context(world));\n    const injected = await race(context.injectedScript());\n\n    const { log, matches, received, missingReceived } = await race(injected.evaluate(async (injected, { info, options, callId }) => {\n      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];\n      if (callId)\n        injected.markTargetElements(new Set(elements), callId);\n      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');\n      let log = '';\n      if (isArray)\n        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;\n      else if (elements.length > 1)\n        throw injected.strictModeViolationError(info!.parsed, elements);\n      else if (elements.length)\n        log = `  locator resolved to ${injected.previewNode(elements[0])}`;\n      return { log, ...await injected.expect(elements[0], options, elements) };\n    }, { info, options, callId: progress.metadata.id }));\n\n    if (log)\n      progress.log(log);\n    // Note: missingReceived avoids `unexpected value \"undefined\"` when element was not found.\n    if (matches === options.isNot) {\n      lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;\n      lastIntermediateResult.isSet = true;\n      if (!missingReceived && !Array.isArray(received))\n        progress.log(`  unexpected value \"${renderUnexpectedValue(options.expression, received)}\"`);\n    }\n    return { matches, received };\n  }\n\n  async waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: { pollingInterval?: number }, world: types.World = 'main'): Promise<js.SmartHandle<R>> {\n    if (typeof options.pollingInterval === 'number')\n      assert(options.pollingInterval > 0, 'Cannot poll with non-positive interval: ' + options.pollingInterval);\n    expression = js.normalizeEvaluationExpression(expression, isFunction);\n    return this.retryWithProgressAndTimeouts(progress, [100], async () => {\n      const context = world === 'main' ? await progress.race(this._mainContext()) : await progress.race(this._utilityContext());\n      const injectedScript = await progress.race(context.injectedScript());\n      const handle = await progress.race(injectedScript.evaluateHandle((injected, { expression, isFunction, polling, arg }) => {\n        let evaledExpression: any;\n        const predicate = (): R => {\n          // NOTE: make sure to use `globalThis.eval` instead of `self.eval` due to a bug with sandbox isolation\n          // in firefox.\n          // See https://bugzilla.mozilla.org/show_bug.cgi?id=1814898\n          let result = evaledExpression ?? globalThis.eval(expression);\n          if (isFunction === true) {\n            evaledExpression = result;\n            result = result(arg);\n          } else if (isFunction === false) {\n            result = result;\n          } else {\n            // auto detect.\n            if (typeof result === 'function') {\n              evaledExpression = result;\n              result = result(arg);\n            }\n          }\n          return result;\n        };\n\n        let fulfill: (result: R) => void;\n        let reject: (error: Error) => void;\n        let aborted = false;\n        const result = new Promise<R>((f, r) => { fulfill = f; reject = r; });\n\n        const next = () => {\n          if (aborted)\n            return;\n          try {\n            const success = predicate();\n            if (success) {\n              fulfill(success);\n              return;\n            }\n            if (typeof polling !== 'number')\n              injected.utils.builtins.requestAnimationFrame(next);\n            else\n              injected.utils.builtins.setTimeout(next, polling);\n          } catch (e) {\n            reject(e);\n          }\n        };\n\n        next();\n        return { result, abort: () => aborted = true };\n      }, { expression, isFunction, polling: options.pollingInterval, arg }));\n      try {\n        return await progress.race(handle.evaluateHandle(h => h.result));\n      } catch (error) {\n        // Note: it is important to await \"abort()\" to prevent any side effects\n        // after this method returns.\n        await handle.evaluate(h => h.abort()).catch(() => {});\n        throw error;\n      } finally {\n        handle.dispose();\n      }\n    });\n  }\n\n  async waitForFunctionValueInUtility<R>(progress: Progress, pageFunction: js.Func1<any, R>) {\n    const expression = `() => {\n      const result = (${pageFunction})();\n      if (!result)\n        return result;\n      return JSON.stringify(result);\n    }`;\n    const handle = await this.waitForFunctionExpression(progress, expression, true, undefined, {}, 'utility');\n    return JSON.parse(handle.rawValue()) as R;\n  }\n\n  async title(): Promise<string> {\n    const context = await this._utilityContext();\n    return context.evaluate(() => document.title);\n  }\n\n  async rafrafTimeout(progress: Progress, timeout: number): Promise<void> {\n    if (timeout === 0)\n      return;\n    const context = await progress.race(this._utilityContext());\n    await Promise.all([\n      // wait for double raf\n      progress.race(context.evaluate(() => new Promise(x => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(x);\n        });\n      }))),\n      progress.wait(timeout),\n    ]);\n  }\n\n  _onDetached() {\n    this._stopNetworkIdleTimer();\n    this._detachedScope.close(new Error('Frame was detached'));\n    for (const data of this._contextData.values()) {\n      if (data.context)\n        data.context.contextDestroyed('Frame was detached');\n      data.contextPromise.resolve({ destroyedReason: 'Frame was detached' });\n    }\n    if (this._parentFrame)\n      this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n\n  private async _callOnElementOnceMatches<T, R>(progress: Progress, selector: string, body: ElementCallback<T, R>, taskData: T, options: types.StrictOptions & { mainWorld?: boolean }, scope?: dom.ElementHandle): Promise<R> {\n    const callbackText = body.toString();\n    progress.log(`waiting for ${this._asLocator(selector)}`);\n    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {\n      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));\n      if (!resolved)\n        return continuePolling;\n      const { log, success, value } = await progress.race(resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {\n        const callback = injected.eval(callbackText) as ElementCallback<T, R>;\n        const element = injected.querySelector(info.parsed, root || document, info.strict);\n        if (!element)\n          return { success: false };\n        const log = `  locator resolved to ${injected.previewNode(element)}`;\n        if (callId)\n          injected.markTargetElements(new Set([element]), callId);\n        return { log, success: true, value: callback(injected, element, taskData as T) };\n      }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined }));\n      if (log)\n        progress.log(log);\n      if (!success)\n        return continuePolling;\n      return value!;\n    });\n    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;\n  }\n\n  private _setContext(world: types.World, context: dom.FrameExecutionContext | null) {\n    const data = this._contextData.get(world)!;\n    data.context = context;\n    if (context)\n      data.contextPromise.resolve(context);\n    else\n      data.contextPromise = new ManualPromise();\n  }\n\n  _contextCreated(world: types.World, context: dom.FrameExecutionContext) {\n    const data = this._contextData.get(world)!;\n    // In case of multiple sessions to the same target, there's a race between\n    // connections so we might end up creating multiple isolated worlds.\n    // We can use either.\n    if (data.context) {\n      data.context.contextDestroyed('Execution context was destroyed, most likely because of a navigation');\n      this._setContext(world, null);\n    }\n    this._setContext(world, context);\n  }\n\n  _contextDestroyed(context: dom.FrameExecutionContext) {\n    // Sometimes we get this after detach, in which case we should not reset\n    // our already destroyed contexts to something that will never resolve.\n    if (this._detachedScope.isClosed())\n      return;\n    context.contextDestroyed('Execution context was destroyed, most likely because of a navigation');\n    for (const [world, data] of this._contextData) {\n      if (data.context === context)\n        this._setContext(world, null);\n    }\n  }\n\n  _startNetworkIdleTimer() {\n    assert(!this._networkIdleTimer);\n    // We should not start a timer and report networkidle in detached frames.\n    // This happens at least in Firefox for child frames, where we may get requestFinished\n    // after the frame was detached - probably a race in the Firefox itself.\n    if (this._firedLifecycleEvents.has('networkidle') || this._detachedScope.isClosed())\n      return;\n    this._networkIdleTimer = setTimeout(() => {\n      this._firedNetworkIdleSelf = true;\n      this._page.mainFrame()._recalculateNetworkIdle();\n    }, 500);\n  }\n\n  _stopNetworkIdleTimer() {\n    if (this._networkIdleTimer)\n      clearTimeout(this._networkIdleTimer);\n    this._networkIdleTimer = undefined;\n    this._firedNetworkIdleSelf = false;\n  }\n\n  async extendInjectedScript(source: string, arg?: any) {\n    const context = await this._context('main');\n    const injectedScriptHandle = await context.injectedScript();\n    await injectedScriptHandle.evaluate((injectedScript, { source, arg }) => {\n      injectedScript.extend(source, arg);\n    }, { source, arg });\n  }\n\n  private _asLocator(selector: string) {\n    return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);\n  }\n}\n\nclass SignalBarrier {\n  private _progress: Progress;\n  private _protectCount = 0;\n  private _promise = new ManualPromise<void>();\n\n  constructor(progress: Progress) {\n    this._progress = progress;\n    this.retain();\n  }\n\n  waitFor(): PromiseLike<void> {\n    this.release();\n    return this._progress.race(this._promise);\n  }\n\n  addFrameNavigation(frame: Frame) {\n    // Auto-wait top-level navigations only.\n    if (frame.parentFrame())\n      return;\n    this.retain();\n    const waiter = helper.waitForEvent(this._progress, frame, Frame.Events.InternalNavigation, (e: NavigationEvent) => {\n      if (!e.isPublic)\n        return false;\n      if (!e.error && this._progress)\n        this._progress.log(`  navigated to \"${frame._url}\"`);\n      return true;\n    });\n    LongStandingScope.raceMultiple([\n      frame._page.openScope,\n      frame._detachedScope,\n    ], waiter.promise).catch(() => {}).finally(() => {\n      waiter.dispose();\n      this.release();\n    });\n  }\n\n  retain() {\n    ++this._protectCount;\n  }\n\n  release() {\n    --this._protectCount;\n    if (!this._protectCount)\n      this._promise.resolve();\n  }\n}\n\nfunction verifyLifecycle(name: string, waitUntil: types.LifecycleEvent): types.LifecycleEvent {\n  if (waitUntil as unknown === 'networkidle0')\n    waitUntil = 'networkidle';\n  if (!types.kLifecycleEvents.has(waitUntil))\n    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);\n  return waitUntil;\n}\n\nfunction renderUnexpectedValue(expression: string, received: any): string {\n  if (expression === 'to.match.aria')\n    return received ? received.raw : received;\n  return received;\n}\n"],
  "mappings": "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",
  "names": ["request", "event", "element", "visible", "log", "color", "html", "tag", "params", "url", "content", "result", "generated", "injected", "info", "options", "expression", "isFunction", "arg", "callbackText", "taskData", "source"]
}

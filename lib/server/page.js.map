{
  "version": 3,
  "sources": ["../../src/server/page.ts"],
  "sourcesContent": ["/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as accessibility from './accessibility';\nimport { BrowserContext } from './browserContext';\nimport { ConsoleMessage } from './console';\nimport { TargetClosedError, TimeoutError } from './errors';\nimport { FileChooser } from './fileChooser';\nimport * as frames from './frames';\nimport { helper } from './helper';\nimport * as input from './input';\nimport { SdkObject } from './instrumentation';\nimport * as js from './javascript';\nimport { Screenshotter, validateScreenshotOptions } from './screenshotter';\nimport { LongStandingScope, assert, renderTitleForCall, trimStringWithEllipsis } from '../utils';\nimport { asLocator } from '../utils';\nimport { getComparator } from './utils/comparators';\nimport { debugLogger } from './utils/debugLogger';\nimport { isInvalidSelectorError } from '../utils/isomorphic/selectorParser';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\nimport { parseEvaluationResultValue } from '../utils/isomorphic/utilityScriptSerializers';\nimport { compressCallLog } from './callLog';\nimport * as rawBindingsControllerSource from '../generated/bindingsControllerSource';\n\nimport type { Artifact } from './artifact';\nimport type * as dom from './dom';\nimport type * as network from './network';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type * as types from './types';\nimport type { ImageComparatorOptions } from './utils/comparators';\nimport type * as channels from '@protocol/channels';\nimport type { BindingPayload } from '@injected/bindingsController';\n\nexport interface PageDelegate {\n  readonly rawMouse: input.RawMouse;\n  readonly rawKeyboard: input.RawKeyboard;\n  readonly rawTouchscreen: input.RawTouchscreen;\n\n  reload(): Promise<void>;\n  goBack(): Promise<boolean>;\n  goForward(): Promise<boolean>;\n  requestGC(): Promise<void>;\n  addInitScript(initScript: InitScript): Promise<void>;\n  removeInitScripts(initScripts: InitScript[]): Promise<void>;\n  closePage(runBeforeUnload: boolean): Promise<void>;\n\n  navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n\n  updateExtraHTTPHeaders(): Promise<void>;\n  updateEmulatedViewportSize(preserveWindowBoundaries?: boolean): Promise<void>;\n  updateEmulateMedia(): Promise<void>;\n  updateRequestInterception(): Promise<void>;\n  updateFileChooserInterception(): Promise<void>;\n  bringToFront(): Promise<void>;\n\n  setBackgroundColor(color?: { r: number; g: number; b: number; a: number; }): Promise<void>;\n  takeScreenshot(progress: Progress, format: string, documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n\n  adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n  getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;  // Only called for frame owner elements.\n  getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>; // Returns frameId.\n  getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null | 'error:notconnected'>;\n  setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, files: string[]): Promise<void>;\n  getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n  getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n  scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n  setScreencastOptions(options: { width: number, height: number, quality: number } | null): Promise<void>;\n\n  getAccessibilityTree(needle?: dom.ElementHandle): Promise<{tree: accessibility.AXNode, needle: accessibility.AXNode | null}>;\n  pdf?: (options: channels.PagePdfParams) => Promise<Buffer>;\n  coverage?: () => any;\n\n  // Work around WebKit's raf issues on Windows.\n  rafCountForStablePosition(): number;\n  // Work around Chrome's non-associated input and protocol.\n  inputActionEpilogue(): Promise<void>;\n  // Work around for asynchronously dispatched CSP errors in Firefox.\n  readonly cspErrorsAsynchronousForInlineScripts?: boolean;\n  // Work around for mouse position in Firefox.\n  resetForReuse(progress: Progress): Promise<void>;\n  // WebKit hack.\n  shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\n\ntype EmulatedSize = { screen: types.Size, viewport: types.Size };\n\ntype EmulatedMedia = {\n  media: types.MediaType;\n  colorScheme: types.ColorScheme;\n  reducedMotion: types.ReducedMotion;\n  forcedColors: types.ForcedColors;\n  contrast: types.Contrast;\n};\n\ntype ExpectScreenshotOptions = ImageComparatorOptions & ScreenshotOptions & {\n  timeout: number,\n  expected?: Buffer,\n  isNot?: boolean,\n  locator?: {\n    frame: frames.Frame,\n    selector: string,\n  },\n};\n\nexport class Page extends SdkObject {\n  static Events = {\n    Close: 'close',\n    Crash: 'crash',\n    Download: 'download',\n    EmulatedSizeChanged: 'emulatedsizechanged',\n    FileChooser: 'filechooser',\n    FrameAttached: 'frameattached',\n    FrameDetached: 'framedetached',\n    InternalFrameNavigatedToNewDocument: 'internalframenavigatedtonewdocument',\n    LocatorHandlerTriggered: 'locatorhandlertriggered',\n    ScreencastFrame: 'screencastframe',\n    Video: 'video',\n    WebSocket: 'websocket',\n    Worker: 'worker',\n  };\n\n  private _closedState: 'open' | 'closing' | 'closed' = 'open';\n  private _closedPromise = new ManualPromise<void>();\n  private _initialized: Page | Error | undefined;\n  private _initializedPromise = new ManualPromise<Page | Error>();\n  private _eventsToEmitAfterInitialized: { event: string | symbol, args: any[] }[] = [];\n  private _crashed = false;\n  readonly openScope = new LongStandingScope();\n  readonly browserContext: BrowserContext;\n  readonly keyboard: input.Keyboard;\n  readonly mouse: input.Mouse;\n  readonly touchscreen: input.Touchscreen;\n  readonly delegate: PageDelegate;\n  private _emulatedSize: EmulatedSize | undefined;\n  private _extraHTTPHeaders: types.HeadersArray | undefined;\n  private _emulatedMedia: Partial<EmulatedMedia> = {};\n  private _fileChooserInterceptedBy = new Set<any>();\n  private readonly _pageBindings = new Map<string, PageBinding>();\n  initScripts: InitScript[] = [];\n  readonly screenshotter: Screenshotter;\n  readonly frameManager: frames.FrameManager;\n  readonly accessibility: accessibility.Accessibility;\n  private _workers = new Map<string, Worker>();\n  readonly pdf: ((options: channels.PagePdfParams) => Promise<Buffer>) | undefined;\n  readonly coverage: any;\n  readonly requestInterceptors: network.RouteHandler[] = [];\n  video: Artifact | null = null;\n  private _opener: Page | undefined;\n  readonly isStorageStatePage: boolean;\n  private _locatorHandlers = new Map<number, { selector: string, noWaitAfter?: boolean, resolved?: ManualPromise<void> }>();\n  private _lastLocatorHandlerUid = 0;\n  private _locatorHandlerRunningCounter = 0;\n\n  // Aiming at 25 fps by default - each frame is 40ms, but we give some slack with 35ms.\n  // When throttling for tracing, 200ms between frames, except for 10 frames around the action.\n  private _frameThrottler = new FrameThrottler(10, 35, 200);\n  closeReason: string | undefined;\n  lastSnapshotFrameIds: string[] = [];\n\n  constructor(delegate: PageDelegate, browserContext: BrowserContext) {\n    super(browserContext, 'page');\n    this.attribution.page = this;\n    this.delegate = delegate;\n    this.browserContext = browserContext;\n    this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));\n    this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);\n    this.mouse = new input.Mouse(delegate.rawMouse, this);\n    this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);\n    this.screenshotter = new Screenshotter(this);\n    this.frameManager = new frames.FrameManager(this);\n    if (delegate.pdf)\n      this.pdf = delegate.pdf.bind(delegate);\n    this.coverage = delegate.coverage ? delegate.coverage() : null;\n    this.isStorageStatePage = browserContext.isCreatingStorageStatePage();\n  }\n\n  async reportAsNew(opener: Page | undefined, error: Error | undefined = undefined, contextEvent: string = BrowserContext.Events.Page) {\n    if (opener) {\n      const openerPageOrError = await opener.waitForInitializedOrError();\n      if (openerPageOrError instanceof Page && !openerPageOrError.isClosed())\n        this._opener = openerPageOrError;\n    }\n    this._markInitialized(error, contextEvent);\n  }\n\n  private _markInitialized(error: Error | undefined = undefined, contextEvent: string = BrowserContext.Events.Page) {\n    if (error) {\n      // Initialization error could have happened because of\n      // context/browser closure. Just ignore the page.\n      if (this.browserContext.isClosingOrClosed())\n        return;\n      this.frameManager.createDummyMainFrameIfNeeded();\n    }\n    this._initialized = error || this;\n    this.emitOnContext(contextEvent, this);\n\n    for (const { event, args } of this._eventsToEmitAfterInitialized)\n      this.browserContext.emit(event, ...args);\n    this._eventsToEmitAfterInitialized = [];\n\n    // It may happen that page initialization finishes after Close event has already been sent,\n    // in that case we fire another Close event to ensure that each reported Page will have\n    // corresponding Close event after it is reported on the context.\n    if (this.isClosed())\n      this.emit(Page.Events.Close);\n    else\n      this.instrumentation.onPageOpen(this);\n\n    // Note: it is important to resolve _initializedPromise at the end,\n    // so that anyone who awaits waitForInitializedOrError got a ready and reported page.\n    this._initializedPromise.resolve(this._initialized);\n  }\n\n  initializedOrUndefined(): Page | undefined {\n    return this._initialized ? this : undefined;\n  }\n\n  waitForInitializedOrError(): Promise<Page | Error> {\n    return this._initializedPromise;\n  }\n\n  emitOnContext(event: string | symbol, ...args: any[]) {\n    if (this.isStorageStatePage)\n      return;\n    this.browserContext.emit(event, ...args);\n  }\n\n  emitOnContextOnceInitialized(event: string | symbol, ...args: any[]) {\n    if (this.isStorageStatePage)\n      return;\n    // Some events, like console messages, may come before page is ready.\n    // In this case, postpone the event until page is initialized,\n    // and dispatch it to the client later, either on the live Page,\n    // or on the \"errored\" Page.\n    if (this._initialized)\n      this.browserContext.emit(event, ...args);\n    else\n      this._eventsToEmitAfterInitialized.push({ event, args });\n  }\n\n  async resetForReuse(progress: Progress) {\n    // Re-navigate once init scripts are gone.\n    await this.mainFrame().gotoImpl(progress, 'about:blank', {});\n\n    this._emulatedSize = undefined;\n    this._emulatedMedia = {};\n    this._extraHTTPHeaders = undefined;\n    await Promise.all([\n      this.delegate.updateEmulatedViewportSize(),\n      this.delegate.updateEmulateMedia(),\n      this.delegate.updateExtraHTTPHeaders(),\n    ]);\n\n    await this.delegate.resetForReuse(progress);\n  }\n\n  _didClose() {\n    this.frameManager.dispose();\n    this._frameThrottler.dispose();\n    assert(this._closedState !== 'closed', 'Page closed twice');\n    this._closedState = 'closed';\n    this.emit(Page.Events.Close);\n    this._closedPromise.resolve();\n    this.instrumentation.onPageClose(this);\n    this.openScope.close(new TargetClosedError());\n  }\n\n  _didCrash() {\n    this.frameManager.dispose();\n    this._frameThrottler.dispose();\n    this.emit(Page.Events.Crash);\n    this._crashed = true;\n    this.instrumentation.onPageClose(this);\n    this.openScope.close(new Error('Page crashed'));\n  }\n\n  async _onFileChooserOpened(handle: dom.ElementHandle) {\n    let multiple;\n    try {\n      multiple = await handle.evaluate(element => !!(element as HTMLInputElement).multiple);\n    } catch (e) {\n      // Frame/context may be gone during async processing. Do not throw.\n      return;\n    }\n    if (!this.listenerCount(Page.Events.FileChooser)) {\n      handle.dispose();\n      return;\n    }\n    const fileChooser = new FileChooser(this, handle, multiple);\n    this.emit(Page.Events.FileChooser, fileChooser);\n  }\n\n  opener(): Page | undefined {\n    return this._opener;\n  }\n\n  mainFrame(): frames.Frame {\n    return this.frameManager.mainFrame();\n  }\n\n  frames(): frames.Frame[] {\n    return this.frameManager.frames();\n  }\n\n  async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding> {\n    if (this._pageBindings.has(name))\n      throw new Error(`Function \"${name}\" has been already registered`);\n    if (this.browserContext._pageBindings.has(name))\n      throw new Error(`Function \"${name}\" has been already registered in the browser context`);\n    await progress.race(this.browserContext.exposePlaywrightBindingIfNeeded());\n    const binding = new PageBinding(name, playwrightBinding, needsHandle);\n    this._pageBindings.set(name, binding);\n    try {\n      await progress.race(this.delegate.addInitScript(binding.initScript));\n      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));\n      return binding;\n    } catch (error) {\n      this._pageBindings.delete(name);\n      throw error;\n    }\n  }\n\n  async removeExposedBindings(bindings: PageBinding[]) {\n    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);\n    for (const binding of bindings)\n      this._pageBindings.delete(binding.name);\n    await this.delegate.removeInitScripts(bindings.map(binding => binding.initScript));\n    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\\n`).join('');\n    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');\n  }\n\n  async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {\n    const oldHeaders = this._extraHTTPHeaders;\n    try {\n      this._extraHTTPHeaders = headers;\n      await progress.race(this.delegate.updateExtraHTTPHeaders());\n    } catch (error) {\n      this._extraHTTPHeaders = oldHeaders;\n      // Note: no await, headers will be updated in the background as soon as possible.\n      this.delegate.updateExtraHTTPHeaders().catch(() => {});\n      throw error;\n    }\n  }\n\n  extraHTTPHeaders(): types.HeadersArray | undefined {\n    return this._extraHTTPHeaders;\n  }\n\n  async onBindingCalled(payload: string, context: dom.FrameExecutionContext) {\n    if (this._closedState === 'closed')\n      return;\n    await PageBinding.dispatch(this, payload, context);\n  }\n\n  addConsoleMessage(type: string, args: js.JSHandle[], location: types.ConsoleMessageLocation, text?: string) {\n    const message = new ConsoleMessage(this, type, text, args, location);\n    const intercepted = this.frameManager.interceptConsoleMessage(message);\n    if (intercepted) {\n      args.forEach(arg => arg.dispose());\n      return;\n    }\n    this.emitOnContextOnceInitialized(BrowserContext.Events.Console, message);\n  }\n\n  async reload(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null> {\n    return this.mainFrame().raceNavigationAction(progress, async () => {\n      // Note: waitForNavigation may fail before we get response to reload(),\n      // so we should await it immediately.\n      const [response] = await Promise.all([\n        // Reload must be a new document, and should not be confused with a stray pushState.\n        this.mainFrame()._waitForNavigation(progress, true /* requiresNewDocument */, options),\n        progress.race(this.delegate.reload()),\n      ]);\n      return response;\n    });\n  }\n\n  async goBack(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null> {\n    return this.mainFrame().raceNavigationAction(progress, async () => {\n      // Note: waitForNavigation may fail before we get response to goBack,\n      // so we should catch it immediately.\n      let error: Error | undefined;\n      const waitPromise = this.mainFrame()._waitForNavigation(progress, false /* requiresNewDocument */, options).catch(e => {\n        error = e;\n        return null;\n      });\n      const result = await progress.race(this.delegate.goBack());\n      if (!result) {\n        waitPromise.catch(() => {}); // Avoid an unhandled rejection.\n        return null;\n      }\n      const response = await waitPromise;\n      if (error)\n        throw error;\n      return response;\n    });\n  }\n\n  async goForward(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null> {\n    return this.mainFrame().raceNavigationAction(progress, async () => {\n      // Note: waitForNavigation may fail before we get response to goForward,\n      // so we should catch it immediately.\n      let error: Error | undefined;\n      const waitPromise = this.mainFrame()._waitForNavigation(progress, false /* requiresNewDocument */, options).catch(e => {\n        error = e;\n        return null;\n      });\n      const result = await progress.race(this.delegate.goForward());\n      if (!result) {\n        waitPromise.catch(() => {}); // Avoid an unhandled rejection.\n        return null;\n      }\n      const response = await waitPromise;\n      if (error)\n        throw error;\n      return response;\n    });\n  }\n\n  requestGC(): Promise<void> {\n    return this.delegate.requestGC();\n  }\n\n  registerLocatorHandler(selector: string, noWaitAfter: boolean | undefined) {\n    const uid = ++this._lastLocatorHandlerUid;\n    this._locatorHandlers.set(uid, { selector, noWaitAfter });\n    return uid;\n  }\n\n  resolveLocatorHandler(uid: number, remove: boolean | undefined) {\n    const handler = this._locatorHandlers.get(uid);\n    if (remove)\n      this._locatorHandlers.delete(uid);\n    if (handler) {\n      handler.resolved?.resolve();\n      handler.resolved = undefined;\n    }\n  }\n\n  unregisterLocatorHandler(uid: number) {\n    this._locatorHandlers.delete(uid);\n  }\n\n  async performActionPreChecks(progress: Progress) {\n    await this._performWaitForNavigationCheck(progress);\n    await this._performLocatorHandlersCheckpoint(progress);\n    // Wait once again, just in case a locator handler caused a navigation.\n    await this._performWaitForNavigationCheck(progress);\n  }\n\n  private async _performWaitForNavigationCheck(progress: Progress) {\n    const mainFrame = this.frameManager.mainFrame();\n    if (!mainFrame || !mainFrame.pendingDocument())\n      return;\n    const url = mainFrame.pendingDocument()?.request?.url();\n    const toUrl = url ? `\" ${trimStringWithEllipsis(url, 200)}\"` : '';\n    progress.log(`  waiting for${toUrl} navigation to finish...`);\n    await helper.waitForEvent(progress, mainFrame, frames.Frame.Events.InternalNavigation, (e: frames.NavigationEvent) => {\n      if (!e.isPublic)\n        return false;\n      if (!e.error)\n        progress.log(`  navigated to \"${trimStringWithEllipsis(mainFrame.url(), 200)}\"`);\n      return true;\n    }).promise;\n  }\n\n  private async _performLocatorHandlersCheckpoint(progress: Progress) {\n    // Do not run locator handlers from inside locator handler callbacks to avoid deadlocks.\n    if (this._locatorHandlerRunningCounter)\n      return;\n    for (const [uid, handler] of this._locatorHandlers) {\n      if (!handler.resolved) {\n        if (await this.mainFrame().isVisibleInternal(progress, handler.selector, { strict: true })) {\n          handler.resolved = new ManualPromise();\n          this.emit(Page.Events.LocatorHandlerTriggered, uid);\n        }\n      }\n      if (handler.resolved) {\n        ++this._locatorHandlerRunningCounter;\n        progress.log(`  found ${asLocator(this.browserContext._browser.sdkLanguage(), handler.selector)}, intercepting action to run the handler`);\n        const promise = handler.resolved.then(async () => {\n          if (!handler.noWaitAfter) {\n            progress.log(`  locator handler has finished, waiting for ${asLocator(this.browserContext._browser.sdkLanguage(), handler.selector)} to be hidden`);\n            await this.mainFrame().waitForSelector(progress, handler.selector, false, { state: 'hidden' });\n          } else {\n            progress.log(`  locator handler has finished`);\n          }\n        });\n        await progress.race(this.openScope.race(promise)).finally(() => --this._locatorHandlerRunningCounter);\n        progress.log(`  interception handler has finished, continuing`);\n      }\n    }\n  }\n\n  async emulateMedia(progress: Progress, options: Partial<EmulatedMedia>) {\n    const oldEmulatedMedia = { ...this._emulatedMedia };\n\n    if (options.media !== undefined)\n      this._emulatedMedia.media = options.media;\n    if (options.colorScheme !== undefined)\n      this._emulatedMedia.colorScheme = options.colorScheme;\n    if (options.reducedMotion !== undefined)\n      this._emulatedMedia.reducedMotion = options.reducedMotion;\n    if (options.forcedColors !== undefined)\n      this._emulatedMedia.forcedColors = options.forcedColors;\n    if (options.contrast !== undefined)\n      this._emulatedMedia.contrast = options.contrast;\n\n    try {\n      await progress.race(this.delegate.updateEmulateMedia());\n    } catch (error) {\n      this._emulatedMedia = oldEmulatedMedia;\n      // Note: no await, emulated media will be updated in the background as soon as possible.\n      this.delegate.updateEmulateMedia().catch(() => {});\n      throw error;\n    }\n  }\n\n  emulatedMedia(): EmulatedMedia {\n    const contextOptions = this.browserContext._options;\n    return {\n      media: this._emulatedMedia.media || 'no-override',\n      colorScheme: this._emulatedMedia.colorScheme !== undefined ? this._emulatedMedia.colorScheme : contextOptions.colorScheme ?? 'light',\n      reducedMotion: this._emulatedMedia.reducedMotion !== undefined ? this._emulatedMedia.reducedMotion : contextOptions.reducedMotion ?? 'no-preference',\n      forcedColors: this._emulatedMedia.forcedColors !== undefined ? this._emulatedMedia.forcedColors : contextOptions.forcedColors ?? 'none',\n      contrast: this._emulatedMedia.contrast !== undefined ? this._emulatedMedia.contrast : contextOptions.contrast ?? 'no-preference',\n    };\n  }\n\n  async setViewportSize(progress: Progress, viewportSize: types.Size) {\n    const oldEmulatedSize = this._emulatedSize;\n    try {\n      this._setEmulatedSize({ viewport: { ...viewportSize }, screen: { ...viewportSize } });\n      await progress.race(this.delegate.updateEmulatedViewportSize());\n    } catch (error) {\n      this._emulatedSize = oldEmulatedSize;\n      // Note: no await, emulated size will be updated in the background as soon as possible.\n      this.delegate.updateEmulatedViewportSize().catch(() => {});\n      throw error;\n    }\n  }\n\n  setEmulatedSizeFromWindowOpen(emulatedSize: EmulatedSize) {\n    this._setEmulatedSize(emulatedSize);\n  }\n\n  private _setEmulatedSize(emulatedSize: EmulatedSize) {\n    this._emulatedSize = emulatedSize;\n    this.emit(Page.Events.EmulatedSizeChanged);\n  }\n\n  emulatedSize(): EmulatedSize | undefined {\n    if (this._emulatedSize)\n      return this._emulatedSize;\n    const contextOptions = this.browserContext._options;\n    return contextOptions.viewport ? { viewport: contextOptions.viewport, screen: contextOptions.screen || contextOptions.viewport } : undefined;\n  }\n\n  async bringToFront(): Promise<void> {\n    await this.delegate.bringToFront();\n  }\n\n  async addInitScript(progress: Progress, source: string) {\n    const initScript = new InitScript(source);\n    this.initScripts.push(initScript);\n    try {\n      await progress.race(this.delegate.addInitScript(initScript));\n    } catch (error) {\n      // Note: no await, script will be removed in the background as soon as possible.\n      this.removeInitScripts([initScript]).catch(() => {});\n      throw error;\n    }\n    return initScript;\n  }\n\n  async removeInitScripts(initScripts: InitScript[]) {\n    const set = new Set(initScripts);\n    this.initScripts = this.initScripts.filter(script => !set.has(script));\n    await this.delegate.removeInitScripts(initScripts);\n  }\n\n  needsRequestInterception(): boolean {\n    return this.requestInterceptors.length > 0 || this.browserContext.requestInterceptors.length > 0;\n  }\n\n  async addRequestInterceptor(progress: Progress, handler: network.RouteHandler, prepend?: 'prepend'): Promise<void> {\n    // Note: progress is intentionally ignored, because this operation is not cancellable and should not block in the browser anyway.\n    if (prepend)\n      this.requestInterceptors.unshift(handler);\n    else\n      this.requestInterceptors.push(handler);\n    await this.delegate.updateRequestInterception();\n  }\n\n  async removeRequestInterceptor(handler: network.RouteHandler): Promise<void> {\n    const index = this.requestInterceptors.indexOf(handler);\n    if (index === -1)\n      return;\n    this.requestInterceptors.splice(index, 1);\n    await this.browserContext.notifyRoutesInFlightAboutRemovedHandler(handler);\n    await this.delegate.updateRequestInterception();\n  }\n\n  async expectScreenshot(progress: Progress, options: ExpectScreenshotOptions): Promise<{ actual?: Buffer, previous?: Buffer, diff?: Buffer, errorMessage?: string, log?: string[], timedOut?: boolean }> {\n    const locator = options.locator;\n    const rafrafScreenshot = locator ? async (timeout: number) => {\n      return await locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress, locator.selector, timeout, options || {});\n    } : async (timeout: number) => {\n      await this.performActionPreChecks(progress);\n      await this.mainFrame().rafrafTimeout(progress, timeout);\n      return await this.screenshotter.screenshotPage(progress, options || {});\n    };\n\n    const comparator = getComparator('image/png');\n    if (!options.expected && options.isNot)\n      return { errorMessage: '\"not\" matcher requires expected result' };\n    try {\n      const format = validateScreenshotOptions(options || {});\n      if (format !== 'png')\n        throw new Error('Only PNG screenshots are supported');\n    } catch (error) {\n      return { errorMessage: error.message };\n    }\n    let intermediateResult: {\n      actual?: Buffer,\n      previous?: Buffer,\n      errorMessage: string,\n      diff?: Buffer,\n    } | undefined;\n    const areEqualScreenshots = (actual: Buffer | undefined, expected: Buffer | undefined, previous: Buffer | undefined) => {\n      const comparatorResult = actual && expected ? comparator(actual, expected, options) : undefined;\n      if (comparatorResult !== undefined && !!comparatorResult === !!options.isNot)\n        return true;\n      if (comparatorResult)\n        intermediateResult = { errorMessage: comparatorResult.errorMessage, diff: comparatorResult.diff, actual, previous };\n      return false;\n    };\n\n    try {\n      let actual: Buffer | undefined;\n      let previous: Buffer | undefined;\n      const pollIntervals = [0, 100, 250, 500];\n      progress.log(`${renderTitleForCall(progress.metadata)}${options.timeout ? ` with timeout ${options.timeout}ms` : ''}`);\n      if (options.expected)\n        progress.log(`  verifying given screenshot expectation`);\n      else\n        progress.log(`  generating new stable screenshot expectation`);\n      let isFirstIteration = true;\n      while (true) {\n        if (this.isClosed())\n          throw new Error('The page has closed');\n        const screenshotTimeout = pollIntervals.shift() ?? 1000;\n        if (screenshotTimeout)\n          progress.log(`waiting ${screenshotTimeout}ms before taking screenshot`);\n        previous = actual;\n        actual = await rafrafScreenshot(screenshotTimeout).catch(e => {\n          if (this.mainFrame().isNonRetriableError(e))\n            throw e;\n          progress.log(`failed to take screenshot - ` + e.message);\n          return undefined;\n        });\n        if (!actual)\n          continue;\n        // Compare against expectation for the first iteration.\n        const expectation = options.expected && isFirstIteration ? options.expected : previous;\n        if (areEqualScreenshots(actual, expectation, previous))\n          break;\n        if (intermediateResult)\n          progress.log(intermediateResult.errorMessage);\n        isFirstIteration = false;\n      }\n\n      if (!isFirstIteration)\n        progress.log(`captured a stable screenshot`);\n\n      if (!options.expected)\n        return { actual };\n\n      if (isFirstIteration) {\n        progress.log(`screenshot matched expectation`);\n        return {};\n      }\n\n      if (areEqualScreenshots(actual, options.expected, undefined)) {\n        progress.log(`screenshot matched expectation`);\n        return {};\n      }\n      throw new Error(intermediateResult!.errorMessage);\n    } catch (e) {\n      // Q: Why not throw upon isNonRetriableError(e) as in other places?\n      // A: We want user to receive a friendly diff between actual and expected/previous.\n      if (js.isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))\n        throw e;\n      let errorMessage = e.message;\n      if (e instanceof TimeoutError && intermediateResult?.previous)\n        errorMessage = `Failed to take two consecutive stable screenshots.`;\n      return {\n        log: compressCallLog(e.message ? [...progress.metadata.log, e.message] : progress.metadata.log),\n        ...intermediateResult,\n        errorMessage,\n        timedOut: (e instanceof TimeoutError),\n      };\n    }\n  }\n\n  async screenshot(progress: Progress, options: ScreenshotOptions): Promise<Buffer> {\n    return await this.screenshotter.screenshotPage(progress, options);\n  }\n\n  async close(options: { runBeforeUnload?: boolean, reason?: string } = {}) {\n    if (this._closedState === 'closed')\n      return;\n    if (options.reason)\n      this.closeReason = options.reason;\n    const runBeforeUnload = !!options.runBeforeUnload;\n    if (this._closedState !== 'closing') {\n      this._closedState = 'closing';\n      // This might throw if the browser context containing the page closes\n      // while we are trying to close the page.\n      await this.delegate.closePage(runBeforeUnload).catch(e => debugLogger.log('error', e));\n    }\n    if (!runBeforeUnload)\n      await this._closedPromise;\n  }\n\n  isClosed(): boolean {\n    return this._closedState === 'closed';\n  }\n\n  hasCrashed() {\n    return this._crashed;\n  }\n\n  isClosedOrClosingOrCrashed() {\n    return this._closedState !== 'open' || this._crashed;\n  }\n\n  addWorker(workerId: string, worker: Worker) {\n    this._workers.set(workerId, worker);\n    this.emit(Page.Events.Worker, worker);\n  }\n\n  removeWorker(workerId: string) {\n    const worker = this._workers.get(workerId);\n    if (!worker)\n      return;\n    worker.didClose();\n    this._workers.delete(workerId);\n  }\n\n  clearWorkers() {\n    for (const [workerId, worker] of this._workers) {\n      worker.didClose();\n      this._workers.delete(workerId);\n    }\n  }\n\n  async setFileChooserInterceptedBy(enabled: boolean, by: any): Promise<void> {\n    const wasIntercepted = this.fileChooserIntercepted();\n    if (enabled)\n      this._fileChooserInterceptedBy.add(by);\n    else\n      this._fileChooserInterceptedBy.delete(by);\n    if (wasIntercepted !== this.fileChooserIntercepted())\n      await this.delegate.updateFileChooserInterception();\n  }\n\n  fileChooserIntercepted() {\n    return this._fileChooserInterceptedBy.size > 0;\n  }\n\n  frameNavigatedToNewDocument(frame: frames.Frame) {\n    this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);\n    const origin = frame.origin();\n    if (origin)\n      this.browserContext.addVisitedOrigin(origin);\n  }\n\n  allInitScripts() {\n    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map(binding => binding.initScript);\n    if (this.browserContext.bindingsInitScript)\n      bindings.unshift(this.browserContext.bindingsInitScript);\n    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];\n  }\n\n  getBinding(name: string) {\n    return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);\n  }\n\n  setScreencastOptions(options: { width: number, height: number, quality: number } | null) {\n    this.delegate.setScreencastOptions(options).catch(e => debugLogger.log('error', e));\n    this._frameThrottler.setThrottlingEnabled(!!options);\n  }\n\n  throttleScreencastFrameAck(ack: () => void) {\n    // Don't ack immediately, tracing has smart throttling logic that is implemented here.\n    this._frameThrottler.ack(ack);\n  }\n\n  temporarilyDisableTracingScreencastThrottling() {\n    this._frameThrottler.recharge();\n  }\n\n  async safeNonStallingEvaluateInAllFrames(expression: string, world: types.World, options: { throwOnJSErrors?: boolean } = {}) {\n    await Promise.all(this.frames().map(async frame => {\n      try {\n        await frame.nonStallingEvaluateInExistingContext(expression, world);\n      } catch (e) {\n        if (options.throwOnJSErrors && js.isJavaScriptErrorInEvaluate(e))\n          throw e;\n      }\n    }));\n  }\n\n  async hideHighlight() {\n    await Promise.all(this.frames().map(frame => frame.hideHighlight().catch(() => {})));\n  }\n\n  async snapshotForAI(progress: Progress): Promise<string> {\n    this.lastSnapshotFrameIds = [];\n    const snapshot = await snapshotFrameForAI(progress, this.mainFrame(), 0, this.lastSnapshotFrameIds);\n    return snapshot.join('\\n');\n  }\n}\n\nexport class Worker extends SdkObject {\n  static Events = {\n    Close: 'close',\n  };\n\n  readonly url: string;\n  private _executionContextPromise: Promise<js.ExecutionContext>;\n  private _executionContextCallback: (value: js.ExecutionContext) => void;\n  existingExecutionContext: js.ExecutionContext | null = null;\n  readonly openScope = new LongStandingScope();\n\n  constructor(parent: SdkObject, url: string) {\n    super(parent, 'worker');\n    this.url = url;\n    this._executionContextCallback = () => {};\n    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);\n  }\n\n  createExecutionContext(delegate: js.ExecutionContextDelegate) {\n    this.existingExecutionContext = new js.ExecutionContext(this, delegate, 'worker');\n    this._executionContextCallback(this.existingExecutionContext);\n    return this.existingExecutionContext;\n  }\n\n  didClose() {\n    if (this.existingExecutionContext)\n      this.existingExecutionContext.contextDestroyed('Worker was closed');\n    this.emit(Worker.Events.Close, this);\n    this.openScope.close(new Error('Worker closed'));\n  }\n\n  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {\n    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);\n  }\n\n  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {\n    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);\n  }\n}\n\nexport class PageBinding {\n  private static kController = '__playwright__binding__controller__';\n  static kBindingName = '__playwright__binding__';\n\n  static createInitScript() {\n    return new InitScript(`\n      (() => {\n        const module = {};\n        ${rawBindingsControllerSource.source}\n        const property = '${PageBinding.kController}';\n        if (!globalThis[property])\n          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${PageBinding.kBindingName}');\n      })();\n    `);\n  }\n\n  readonly name: string;\n  readonly playwrightFunction: frames.FunctionWithSource;\n  readonly initScript: InitScript;\n  readonly needsHandle: boolean;\n  readonly cleanupScript: string;\n  forClient?: unknown;\n\n  constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {\n    this.name = name;\n    this.playwrightFunction = playwrightFunction;\n    this.initScript = new InitScript(`globalThis['${PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);\n    this.needsHandle = needsHandle;\n    this.cleanupScript = `globalThis['${PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;\n  }\n\n  static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {\n    const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;\n    try {\n      assert(context.world);\n      const binding = page.getBinding(name);\n      if (!binding)\n        throw new Error(`Function \"${name}\" is not exposed`);\n      let result: any;\n      if (binding.needsHandle) {\n        const handle = await context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq }).catch(e => null);\n        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, handle);\n      } else {\n        if (!Array.isArray(serializedArgs))\n          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);\n        const args = serializedArgs!.map(a => parseEvaluationResultValue(a));\n        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, ...args);\n      }\n      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, result }).catch(e => debugLogger.log('error', e));\n    } catch (error) {\n      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, error }).catch(e => debugLogger.log('error', e));\n    }\n  }\n}\n\nexport class InitScript {\n  readonly source: string;\n\n  constructor(source: string) {\n    this.source = `(() => {\n      ${source}\n    })();`;\n  }\n}\n\nclass FrameThrottler {\n  private _acks: (() => void)[] = [];\n  private _defaultInterval: number;\n  private _throttlingInterval: number;\n  private _nonThrottledFrames: number;\n  private _budget: number;\n  private _throttlingEnabled = false;\n  private _timeoutId: NodeJS.Timeout | undefined;\n\n  constructor(nonThrottledFrames: number, defaultInterval: number, throttlingInterval: number) {\n    this._nonThrottledFrames = nonThrottledFrames;\n    this._budget = nonThrottledFrames;\n    this._defaultInterval = defaultInterval;\n    this._throttlingInterval = throttlingInterval;\n    this._tick();\n  }\n\n  dispose() {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = undefined;\n    }\n  }\n\n  setThrottlingEnabled(enabled: boolean) {\n    this._throttlingEnabled = enabled;\n  }\n\n  recharge() {\n    // Send all acks, reset budget.\n    for (const ack of this._acks)\n      ack();\n    this._acks = [];\n    this._budget = this._nonThrottledFrames;\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      this._tick();\n    }\n  }\n\n  ack(ack: () => void) {\n    if (!this._timeoutId) {\n      // Already disposed.\n      ack();\n      return;\n    }\n    this._acks.push(ack);\n  }\n\n  private _tick() {\n    const ack = this._acks.shift();\n    if (ack) {\n      --this._budget;\n      ack();\n    }\n\n    if (this._throttlingEnabled && this._budget <= 0) {\n      // Non-throttled frame budget is exceeded. Next ack will be throttled.\n      this._timeoutId = setTimeout(() => this._tick(), this._throttlingInterval);\n    } else {\n      // Either not throttling, or still under budget. Next ack will be after the default timeout.\n      this._timeoutId = setTimeout(() => this._tick(), this._defaultInterval);\n    }\n  }\n}\n\nasync function snapshotFrameForAI(progress: Progress, frame: frames.Frame, frameOrdinal: number, frameIds: string[]): Promise<string[]> {\n  // Only await the topmost navigations, inner frames will be empty when racing.\n  const snapshot = await frame.retryWithProgressAndTimeouts(progress, [1000, 2000, 4000, 8000], async continuePolling => {\n    try {\n      const context = await progress.race(frame._utilityContext());\n      const injectedScript = await progress.race(context.injectedScript());\n      const snapshotOrRetry = await progress.race(injectedScript.evaluate((injected, refPrefix) => {\n        const node = injected.document.body;\n        if (!node)\n          return true;\n        return injected.ariaSnapshot(node, { mode: 'ai', refPrefix });\n      }, frameOrdinal ? 'f' + frameOrdinal : ''));\n      if (snapshotOrRetry === true)\n        return continuePolling;\n      return snapshotOrRetry;\n    } catch (e) {\n      if (frame.isNonRetriableError(e))\n        throw e;\n      return continuePolling;\n    }\n  });\n\n  const lines = snapshot.split('\\n');\n  const result = [];\n  for (const line of lines) {\n    const match = line.match(/^(\\s*)- iframe (?:\\[active\\] )?\\[ref=([^\\]]*)\\]/);\n    if (!match) {\n      result.push(line);\n      continue;\n    }\n\n    const leadingSpace = match[1];\n    const ref = match[2];\n    const frameSelector = `aria-ref=${ref} >> internal:control=enter-frame`;\n    const frameBodySelector = `${frameSelector} >> body`;\n    const child = await progress.race(frame.selectors.resolveFrameForSelector(frameBodySelector, { strict: true }));\n    if (!child) {\n      result.push(line);\n      continue;\n    }\n    const frameOrdinal = frameIds.length + 1;\n    frameIds.push(child.frame._id);\n    try {\n      const childSnapshot = await snapshotFrameForAI(progress, child.frame, frameOrdinal, frameIds);\n      result.push(line + ':', ...childSnapshot.map(l => leadingSpace + '  ' + l));\n    } catch {\n      result.push(line);\n    }\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "frameOrdinal"]
}

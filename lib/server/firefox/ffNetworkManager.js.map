{
  "version": 3,
  "sources": ["../../../src/server/firefox/ffNetworkManager.ts"],
  "sourcesContent": ["/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { eventsHelper } from '../utils/eventsHelper';\nimport * as network from '../network';\n\nimport type { FFSession } from './ffConnection';\nimport type { HeadersArray } from '../../server/types';\nimport type { RegisteredListener } from '../utils/eventsHelper';\nimport type * as frames from '../frames';\nimport type { Page } from '../page';\nimport type * as types from '../types';\nimport type { Protocol } from './protocol';\n\nexport class FFNetworkManager {\n  private _session: FFSession;\n  private _requests: Map<string, InterceptableRequest>;\n  private _page: Page;\n  private _eventListeners: RegisteredListener[];\n\n  constructor(session: FFSession, page: Page) {\n    this._session = session;\n\n    this._requests = new Map();\n    this._page = page;\n\n    this._eventListeners = [\n      eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.requestFinished', this._onRequestFinished.bind(this)),\n      eventsHelper.addEventListener(session, 'Network.requestFailed', this._onRequestFailed.bind(this)),\n    ];\n  }\n\n  dispose() {\n    eventsHelper.removeEventListeners(this._eventListeners);\n  }\n\n  async setRequestInterception(enabled: boolean) {\n    await Promise.all([\n      this._session.send('Network.setRequestInterception', { enabled }),\n      this._session.send('Page.setCacheDisabled', { cacheDisabled: enabled }),\n    ]);\n  }\n\n  _onRequestWillBeSent(event: Protocol.Network.requestWillBeSentPayload) {\n    const redirectedFrom = event.redirectedFrom ? (this._requests.get(event.redirectedFrom) || null) : null;\n    const frame = redirectedFrom ? redirectedFrom.request.frame() : (event.frameId ? this._page.frameManager.frame(event.frameId) : null);\n    if (!frame)\n      return;\n    // Align with Chromium and WebKit and not expose preflight OPTIONS requests to the client.\n    if (event.method === 'OPTIONS' && !event.isIntercepted)\n      return;\n    if (redirectedFrom)\n      this._requests.delete(redirectedFrom._id);\n    const request = new InterceptableRequest(frame, redirectedFrom, event);\n    let route;\n    if (event.isIntercepted)\n      route = new FFRouteImpl(this._session, request);\n    this._requests.set(request._id, request);\n    this._page.frameManager.requestStarted(request.request, route);\n  }\n\n  _onResponseReceived(event: Protocol.Network.responseReceivedPayload) {\n    const request = this._requests.get(event.requestId);\n    if (!request)\n      return;\n    const getResponseBody = async () => {\n      const response = await this._session.send('Network.getResponseBody', {\n        requestId: request._id\n      });\n      if (response.evicted)\n        throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);\n      return Buffer.from(response.base64body, 'base64');\n    };\n\n    const startTime = event.timing.startTime;\n    function relativeToStart(time: number): number {\n      if (!time)\n        return -1;\n      return (time - startTime) / 1000;\n    }\n    const timing = {\n      startTime: startTime / 1000,\n      domainLookupStart: relativeToStart(event.timing.domainLookupStart),\n      domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),\n      connectStart: relativeToStart(event.timing.connectStart),\n      secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),\n      connectEnd: relativeToStart(event.timing.connectEnd),\n      requestStart: relativeToStart(event.timing.requestStart),\n      responseStart: relativeToStart(event.timing.responseStart),\n    };\n    const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);\n    if (event?.remoteIPAddress && typeof event?.remotePort === 'number') {\n      response._serverAddrFinished({\n        ipAddress: event.remoteIPAddress,\n        port: event.remotePort,\n      });\n    } else {\n      response._serverAddrFinished();\n    }\n    response._securityDetailsFinished({\n      protocol: event?.securityDetails?.protocol,\n      subjectName: event?.securityDetails?.subjectName,\n      issuer: event?.securityDetails?.issuer,\n      validFrom: event?.securityDetails?.validFrom,\n      validTo: event?.securityDetails?.validTo,\n    });\n    // \"raw\" headers are the same as \"provisional\" headers in Firefox.\n    response.setRawResponseHeaders(null);\n    // Headers size are not available in Firefox.\n    response.setResponseHeadersSize(null);\n    this._page.frameManager.requestReceivedResponse(response);\n  }\n\n  _onRequestFinished(event: Protocol.Network.requestFinishedPayload) {\n    const request = this._requests.get(event.requestId);\n    if (!request)\n      return;\n    const response = request.request._existingResponse()!;\n    response.setTransferSize(event.transferSize);\n    response.setEncodedBodySize(event.encodedBodySize);\n\n    // Keep redirected requests in the map for future reference as redirectedFrom.\n    const isRedirected = response.status() >= 300 && response.status() <= 399;\n    const responseEndTime = event.responseEndTime ? event.responseEndTime / 1000 - response.timing().startTime : -1;\n    if (isRedirected) {\n      response._requestFinished(responseEndTime);\n    } else {\n      this._requests.delete(request._id);\n      response._requestFinished(responseEndTime);\n    }\n    if (event.protocolVersion)\n      response._setHttpVersion(event.protocolVersion);\n    this._page.frameManager.reportRequestFinished(request.request, response);\n  }\n\n  _onRequestFailed(event: Protocol.Network.requestFailedPayload) {\n    const request = this._requests.get(event.requestId);\n    if (!request)\n      return;\n    this._requests.delete(request._id);\n    const response = request.request._existingResponse();\n    if (response) {\n      response.setTransferSize(null);\n      response.setEncodedBodySize(null);\n      response._requestFinished(-1);\n    }\n    request.request._setFailureText(event.errorCode);\n    this._page.frameManager.requestFailed(request.request, event.errorCode === 'NS_BINDING_ABORTED');\n  }\n}\n\nconst causeToResourceType: {[key: string]: string} = {\n  TYPE_INVALID: 'other',\n  TYPE_OTHER: 'other',\n  TYPE_SCRIPT: 'script',\n  TYPE_IMAGE: 'image',\n  TYPE_STYLESHEET: 'stylesheet',\n  TYPE_OBJECT: 'other',\n  TYPE_DOCUMENT: 'document',\n  TYPE_SUBDOCUMENT: 'document',\n  TYPE_REFRESH: 'document',\n  TYPE_XBL: 'other',\n  TYPE_PING: 'other',\n  TYPE_XMLHTTPREQUEST: 'xhr',\n  TYPE_OBJECT_SUBREQUEST: 'other',\n  TYPE_DTD: 'other',\n  TYPE_FONT: 'font',\n  TYPE_MEDIA: 'media',\n  TYPE_WEBSOCKET: 'websocket',\n  TYPE_CSP_REPORT: 'other',\n  TYPE_XSLT: 'other',\n  TYPE_BEACON: 'other',\n  TYPE_FETCH: 'fetch',\n  TYPE_IMAGESET: 'image',\n  TYPE_WEB_MANIFEST: 'manifest',\n};\n\nconst internalCauseToResourceType: {[key: string]: string} = {\n  TYPE_INTERNAL_EVENTSOURCE: 'eventsource',\n};\n\nclass InterceptableRequest {\n  readonly request: network.Request;\n  readonly _id: string;\n  private _redirectedTo: InterceptableRequest | undefined;\n\n  constructor(frame: frames.Frame, redirectedFrom: InterceptableRequest | null, payload: Protocol.Network.requestWillBeSentPayload) {\n    this._id = payload.requestId;\n    if (redirectedFrom)\n      redirectedFrom._redirectedTo = this;\n    let postDataBuffer = null;\n    if (payload.postData)\n      postDataBuffer = Buffer.from(payload.postData, 'base64');\n    this.request = new network.Request(frame._page.browserContext, frame, null, redirectedFrom ? redirectedFrom.request : null, payload.navigationId,\n        payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || 'other', payload.method, postDataBuffer, payload.headers);\n    // \"raw\" headers are the same as \"provisional\" headers in Firefox.\n    this.request.setRawRequestHeaders(null);\n  }\n\n  _finalRequest(): InterceptableRequest {\n    let request: InterceptableRequest = this;\n    while (request._redirectedTo)\n      request = request._redirectedTo;\n    return request;\n  }\n}\n\nclass FFRouteImpl implements network.RouteDelegate {\n  private _request: InterceptableRequest;\n  private _session: FFSession;\n\n  constructor(session: FFSession, request: InterceptableRequest) {\n    this._session = session;\n    this._request = request;\n  }\n\n  async continue(overrides: types.NormalizedContinueOverrides) {\n    await this._session.sendMayFail('Network.resumeInterceptedRequest', {\n      requestId: this._request._id,\n      url: overrides.url,\n      method: overrides.method,\n      headers: overrides.headers,\n      postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined,\n    });\n  }\n\n  async fulfill(response: types.NormalizedFulfillResponse) {\n    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');\n\n    await this._session.sendMayFail('Network.fulfillInterceptedRequest', {\n      requestId: this._request._id,\n      status: response.status,\n      statusText: network.statusText(response.status),\n      headers: response.headers,\n      base64body,\n    });\n  }\n\n  async abort(errorCode: string) {\n    await this._session.sendMayFail('Network.abortInterceptedRequest', {\n      requestId: this._request._id,\n      errorCode,\n    });\n  }\n}\n\nfunction parseMultivalueHeaders(headers: HeadersArray) {\n  const result: HeadersArray = [];\n  for (const header of headers) {\n    const separator = header.name.toLowerCase() === 'set-cookie' ? '\\n' : ',';\n    const tokens = header.value.split(separator).map(s => s.trim());\n    for (const token of tokens)\n      result.push({ name: header.name, value: token });\n  }\n  return result;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,0BAA6B;AAC7B,cAAyB;AAUlB,MAAM,iBAAiB;AAAA,EAM5B,YAAY,SAAoB,MAAY;AAC1C,SAAK,WAAW;AAEhB,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,QAAQ;AAEb,SAAK,kBAAkB;AAAA,MACrB,iCAAa,iBAAiB,SAAS,6BAA6B,KAAK,qBAAqB,KAAK,IAAI,CAAC;AAAA,MACxG,iCAAa,iBAAiB,SAAS,4BAA4B,KAAK,oBAAoB,KAAK,IAAI,CAAC;AAAA,MACtG,iCAAa,iBAAiB,SAAS,2BAA2B,KAAK,mBAAmB,KAAK,IAAI,CAAC;AAAA,MACpG,iCAAa,iBAAiB,SAAS,yBAAyB,KAAK,iBAAiB,KAAK,IAAI,CAAC;AAAA,IAClG;AAAA,EACF;AAAA,EAEA,UAAU;AACR,qCAAa,qBAAqB,KAAK,eAAe;AAAA,EACxD;AAAA,EAEA,MAAM,uBAAuB,SAAkB;AAC7C,UAAM,QAAQ,IAAI;AAAA,MAChB,KAAK,SAAS,KAAK,kCAAkC,EAAE,QAAQ,CAAC;AAAA,MAChE,KAAK,SAAS,KAAK,yBAAyB,EAAE,eAAe,QAAQ,CAAC;AAAA,IACxE,CAAC;AAAA,EACH;AAAA,EAEA,qBAAqB,OAAkD;AACrE,UAAM,iBAAiB,MAAM,iBAAkB,KAAK,UAAU,IAAI,MAAM,cAAc,KAAK,OAAQ;AACnG,UAAM,QAAQ,iBAAiB,eAAe,QAAQ,MAAM,IAAK,MAAM,UAAU,KAAK,MAAM,aAAa,MAAM,MAAM,OAAO,IAAI;AAChI,QAAI,CAAC;AACH;AAEF,QAAI,MAAM,WAAW,aAAa,CAAC,MAAM;AACvC;AACF,QAAI;AACF,WAAK,UAAU,OAAO,eAAe,GAAG;AAC1C,UAAM,UAAU,IAAI,qBAAqB,OAAO,gBAAgB,KAAK;AACrE,QAAI;AACJ,QAAI,MAAM;AACR,cAAQ,IAAI,YAAY,KAAK,UAAU,OAAO;AAChD,SAAK,UAAU,IAAI,QAAQ,KAAK,OAAO;AACvC,SAAK,MAAM,aAAa,eAAe,QAAQ,SAAS,KAAK;AAAA,EAC/D;AAAA,EAEA,oBAAoB,OAAiD;AACnE,UAAM,UAAU,KAAK,UAAU,IAAI,MAAM,SAAS;AAClD,QAAI,CAAC;AACH;AACF,UAAM,kBAAkB,YAAY;AAClC,YAAMA,YAAW,MAAM,KAAK,SAAS,KAAK,2BAA2B;AAAA,QACnE,WAAW,QAAQ;AAAA,MACrB,CAAC;AACD,UAAIA,UAAS;AACX,cAAM,IAAI,MAAM,qBAAqB,QAAQ,QAAQ,OAAO,CAAC,IAAI,QAAQ,QAAQ,IAAI,CAAC,eAAe;AACvG,aAAO,OAAO,KAAKA,UAAS,YAAY,QAAQ;AAAA,IAClD;AAEA,UAAM,YAAY,MAAM,OAAO;AAC/B,aAAS,gBAAgB,MAAsB;AAC7C,UAAI,CAAC;AACH,eAAO;AACT,cAAQ,OAAO,aAAa;AAAA,IAC9B;AACA,UAAM,SAAS;AAAA,MACb,WAAW,YAAY;AAAA,MACvB,mBAAmB,gBAAgB,MAAM,OAAO,iBAAiB;AAAA,MACjE,iBAAiB,gBAAgB,MAAM,OAAO,eAAe;AAAA,MAC7D,cAAc,gBAAgB,MAAM,OAAO,YAAY;AAAA,MACvD,uBAAuB,gBAAgB,MAAM,OAAO,qBAAqB;AAAA,MACzE,YAAY,gBAAgB,MAAM,OAAO,UAAU;AAAA,MACnD,cAAc,gBAAgB,MAAM,OAAO,YAAY;AAAA,MACvD,eAAe,gBAAgB,MAAM,OAAO,aAAa;AAAA,IAC3D;AACA,UAAM,WAAW,IAAI,QAAQ,SAAS,QAAQ,SAAS,MAAM,QAAQ,MAAM,YAAY,uBAAuB,MAAM,OAAO,GAAG,QAAQ,iBAAiB,MAAM,iBAAiB;AAC9K,QAAI,OAAO,mBAAmB,OAAO,OAAO,eAAe,UAAU;AACnE,eAAS,oBAAoB;AAAA,QAC3B,WAAW,MAAM;AAAA,QACjB,MAAM,MAAM;AAAA,MACd,CAAC;AAAA,IACH,OAAO;AACL,eAAS,oBAAoB;AAAA,IAC/B;AACA,aAAS,yBAAyB;AAAA,MAChC,UAAU,OAAO,iBAAiB;AAAA,MAClC,aAAa,OAAO,iBAAiB;AAAA,MACrC,QAAQ,OAAO,iBAAiB;AAAA,MAChC,WAAW,OAAO,iBAAiB;AAAA,MACnC,SAAS,OAAO,iBAAiB;AAAA,IACnC,CAAC;AAED,aAAS,sBAAsB,IAAI;AAEnC,aAAS,uBAAuB,IAAI;AACpC,SAAK,MAAM,aAAa,wBAAwB,QAAQ;AAAA,EAC1D;AAAA,EAEA,mBAAmB,OAAgD;AACjE,UAAM,UAAU,KAAK,UAAU,IAAI,MAAM,SAAS;AAClD,QAAI,CAAC;AACH;AACF,UAAM,WAAW,QAAQ,QAAQ,kBAAkB;AACnD,aAAS,gBAAgB,MAAM,YAAY;AAC3C,aAAS,mBAAmB,MAAM,eAAe;AAGjD,UAAM,eAAe,SAAS,OAAO,KAAK,OAAO,SAAS,OAAO,KAAK;AACtE,UAAM,kBAAkB,MAAM,kBAAkB,MAAM,kBAAkB,MAAO,SAAS,OAAO,EAAE,YAAY;AAC7G,QAAI,cAAc;AAChB,eAAS,iBAAiB,eAAe;AAAA,IAC3C,OAAO;AACL,WAAK,UAAU,OAAO,QAAQ,GAAG;AACjC,eAAS,iBAAiB,eAAe;AAAA,IAC3C;AACA,QAAI,MAAM;AACR,eAAS,gBAAgB,MAAM,eAAe;AAChD,SAAK,MAAM,aAAa,sBAAsB,QAAQ,SAAS,QAAQ;AAAA,EACzE;AAAA,EAEA,iBAAiB,OAA8C;AAC7D,UAAM,UAAU,KAAK,UAAU,IAAI,MAAM,SAAS;AAClD,QAAI,CAAC;AACH;AACF,SAAK,UAAU,OAAO,QAAQ,GAAG;AACjC,UAAM,WAAW,QAAQ,QAAQ,kBAAkB;AACnD,QAAI,UAAU;AACZ,eAAS,gBAAgB,IAAI;AAC7B,eAAS,mBAAmB,IAAI;AAChC,eAAS,iBAAiB,EAAE;AAAA,IAC9B;AACA,YAAQ,QAAQ,gBAAgB,MAAM,SAAS;AAC/C,SAAK,MAAM,aAAa,cAAc,QAAQ,SAAS,MAAM,cAAc,oBAAoB;AAAA,EACjG;AACF;AAEA,MAAM,sBAA+C;AAAA,EACnD,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,iBAAiB;AAAA,EACjB,aAAa;AAAA,EACb,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,cAAc;AAAA,EACd,UAAU;AAAA,EACV,WAAW;AAAA,EACX,qBAAqB;AAAA,EACrB,wBAAwB;AAAA,EACxB,UAAU;AAAA,EACV,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,mBAAmB;AACrB;AAEA,MAAM,8BAAuD;AAAA,EAC3D,2BAA2B;AAC7B;AAEA,MAAM,qBAAqB;AAAA,EAKzB,YAAY,OAAqB,gBAA6C,SAAoD;AAChI,SAAK,MAAM,QAAQ;AACnB,QAAI;AACF,qBAAe,gBAAgB;AACjC,QAAI,iBAAiB;AACrB,QAAI,QAAQ;AACV,uBAAiB,OAAO,KAAK,QAAQ,UAAU,QAAQ;AACzD,SAAK,UAAU,IAAI,QAAQ;AAAA,MAAQ,MAAM,MAAM;AAAA,MAAgB;AAAA,MAAO;AAAA,MAAM,iBAAiB,eAAe,UAAU;AAAA,MAAM,QAAQ;AAAA,MAChI,QAAQ;AAAA,MAAK,4BAA4B,QAAQ,aAAa,KAAK,oBAAoB,QAAQ,KAAK,KAAK;AAAA,MAAS,QAAQ;AAAA,MAAQ;AAAA,MAAgB,QAAQ;AAAA,IAAO;AAErK,SAAK,QAAQ,qBAAqB,IAAI;AAAA,EACxC;AAAA,EAEA,gBAAsC;AACpC,QAAI,UAAgC;AACpC,WAAO,QAAQ;AACb,gBAAU,QAAQ;AACpB,WAAO;AAAA,EACT;AACF;AAEA,MAAM,YAA6C;AAAA,EAIjD,YAAY,SAAoB,SAA+B;AAC7D,SAAK,WAAW;AAChB,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,SAAS,WAA8C;AAC3D,UAAM,KAAK,SAAS,YAAY,oCAAoC;AAAA,MAClE,WAAW,KAAK,SAAS;AAAA,MACzB,KAAK,UAAU;AAAA,MACf,QAAQ,UAAU;AAAA,MAClB,SAAS,UAAU;AAAA,MACnB,UAAU,UAAU,WAAW,OAAO,KAAK,UAAU,QAAQ,EAAE,SAAS,QAAQ,IAAI;AAAA,IACtF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ,UAA2C;AACvD,UAAM,aAAa,SAAS,WAAW,SAAS,OAAO,OAAO,KAAK,SAAS,IAAI,EAAE,SAAS,QAAQ;AAEnG,UAAM,KAAK,SAAS,YAAY,qCAAqC;AAAA,MACnE,WAAW,KAAK,SAAS;AAAA,MACzB,QAAQ,SAAS;AAAA,MACjB,YAAY,QAAQ,WAAW,SAAS,MAAM;AAAA,MAC9C,SAAS,SAAS;AAAA,MAClB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,MAAM,WAAmB;AAC7B,UAAM,KAAK,SAAS,YAAY,mCAAmC;AAAA,MACjE,WAAW,KAAK,SAAS;AAAA,MACzB;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,SAAS,uBAAuB,SAAuB;AACrD,QAAM,SAAuB,CAAC;AAC9B,aAAW,UAAU,SAAS;AAC5B,UAAM,YAAY,OAAO,KAAK,YAAY,MAAM,eAAe,OAAO;AACtE,UAAM,SAAS,OAAO,MAAM,MAAM,SAAS,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC;AAC9D,eAAW,SAAS;AAClB,aAAO,KAAK,EAAE,MAAM,OAAO,MAAM,OAAO,MAAM,CAAC;AAAA,EACnD;AACA,SAAO;AACT;",
  "names": ["response"]
}

{
  "version": 3,
  "sources": ["../../src/server/fetch.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport http from 'http';\nimport https from 'https';\nimport { Transform, pipeline } from 'stream';\nimport { TLSSocket } from 'tls';\nimport * as zlib from 'zlib';\n\nimport { assert, constructURLBasedOnBaseURL, createProxyAgent, eventsHelper, monotonicTime  } from '../utils';\nimport { createGuid } from './utils/crypto';\nimport { getUserAgent } from './utils/userAgent';\nimport { BrowserContext, verifyClientCertificates } from './browserContext';\nimport { Cookie, CookieStore, domainMatches, parseRawCookie } from './cookieStore';\nimport { MultipartFormData } from './formData';\nimport { SdkObject } from './instrumentation';\nimport { isAbortError } from './progress';\nimport { getMatchingTLSOptionsForOrigin, rewriteOpenSSLErrorIfNeeded } from './socksClientCertificatesInterceptor';\nimport { httpHappyEyeballsAgent, httpsHappyEyeballsAgent, timingForSocket } from './utils/happyEyeballs';\nimport { Tracing } from './trace/recorder/tracing';\n\nimport type { Playwright } from './playwright';\nimport type { Progress } from './progress';\nimport type * as types from './types';\nimport type { HeadersArray, ProxySettings } from './types';\nimport type { HTTPCredentials } from '../../types/types';\nimport type { RegisteredListener } from '../utils';\nimport type * as channels from '@protocol/channels';\nimport type * as har from '@trace/har';\nimport type { LookupAddress } from 'dns';\nimport type { Readable, TransformCallback } from 'stream';\n\n\ntype FetchRequestOptions = {\n  userAgent: string;\n  extraHTTPHeaders?: HeadersArray;\n  failOnStatusCode?: boolean;\n  httpCredentials?: HTTPCredentials;\n  proxy?: ProxySettings;\n  ignoreHTTPSErrors?: boolean;\n  maxRedirects?: number;\n  baseURL?: string;\n  clientCertificates?: types.BrowserContextOptions['clientCertificates'];\n};\n\ntype HeadersObject = Readonly<{ [name: string]: string }>;\n\nexport type APIRequestEvent = {\n  url: URL,\n  method: string,\n  headers: HeadersObject,\n  cookies: channels.NameValue[],\n  postData?: Buffer\n};\n\nexport type APIRequestFinishedEvent = {\n  requestEvent: APIRequestEvent,\n  httpVersion: string;\n  headers: http.IncomingHttpHeaders;\n  cookies: channels.NetworkCookie[];\n  rawHeaders: string[];\n  statusCode: number;\n  statusMessage: string;\n  body?: Buffer;\n  timings: har.Timings;\n  serverIPAddress?: string;\n  serverPort?: number;\n  securityDetails?: har.SecurityDetails;\n};\n\ntype SendRequestOptions = https.RequestOptions & {\n  maxRedirects: number,\n  headers: HeadersObject,\n  __testHookLookup?: (hostname: string) => LookupAddress[]\n};\n\ntype SendRequestResult = Omit<channels.APIResponse, 'fetchUid'> & { body: Buffer };\n\nexport abstract class APIRequestContext extends SdkObject {\n  static Events = {\n    Dispose: 'dispose',\n\n    Request: 'request',\n    RequestFinished: 'requestfinished',\n  };\n\n  readonly fetchResponses: Map<string, Buffer> = new Map();\n  readonly fetchLog: Map<string, string[]> = new Map();\n  protected static allInstances: Set<APIRequestContext> = new Set();\n  _closeReason: string | undefined;\n\n  static findResponseBody(guid: string): Buffer | undefined {\n    for (const request of APIRequestContext.allInstances) {\n      const body = request.fetchResponses.get(guid);\n      if (body)\n        return body;\n    }\n    return undefined;\n  }\n\n  constructor(parent: SdkObject) {\n    super(parent, 'request-context');\n    APIRequestContext.allInstances.add(this);\n  }\n\n  protected _disposeImpl() {\n    APIRequestContext.allInstances.delete(this);\n    this.fetchResponses.clear();\n    this.fetchLog.clear();\n    this.emit(APIRequestContext.Events.Dispose);\n  }\n\n  disposeResponse(fetchUid: string) {\n    this.fetchResponses.delete(fetchUid);\n    this.fetchLog.delete(fetchUid);\n  }\n\n  abstract tracing(): Tracing;\n\n  abstract dispose(options: { reason?: string }): Promise<void>;\n\n  abstract _defaultOptions(): FetchRequestOptions;\n  abstract _addCookies(cookies: channels.NetworkCookie[]): Promise<void>;\n  abstract _cookies(url: URL): Promise<channels.NetworkCookie[]>;\n  abstract storageState(progress: Progress, indexedDB?: boolean): Promise<channels.APIRequestContextStorageStateResult>;\n\n  private _storeResponseBody(body: Buffer): string {\n    const uid = createGuid();\n    this.fetchResponses.set(uid, body);\n    return uid;\n  }\n\n  async fetch(progress: Progress, params: channels.APIRequestContextFetchParams): Promise<channels.APIResponse> {\n    const defaults = this._defaultOptions();\n    const headers: HeadersObject = {\n      'user-agent': defaults.userAgent,\n      'accept': '*/*',\n      'accept-encoding': 'gzip,deflate,br',\n    };\n\n    if (defaults.extraHTTPHeaders) {\n      for (const { name, value } of defaults.extraHTTPHeaders)\n        setHeader(headers, name, value);\n    }\n\n    if (params.headers) {\n      for (const { name, value } of params.headers)\n        setHeader(headers, name, value);\n    }\n\n    const requestUrl = new URL(constructURLBasedOnBaseURL(defaults.baseURL, params.url));\n    if (params.encodedParams) {\n      requestUrl.search = params.encodedParams;\n    } else if (params.params) {\n      for (const { name, value } of params.params)\n        requestUrl.searchParams.append(name, value);\n    }\n\n    const credentials = this._getHttpCredentials(requestUrl);\n    if (credentials?.send === 'always')\n      setBasicAuthorizationHeader(headers, credentials);\n\n    const method = params.method?.toUpperCase() || 'GET';\n    const proxy = defaults.proxy;\n    let agent;\n    // We skip 'per-context' in order to not break existing users. 'per-context' was previously used to\n    // workaround an upstream Chromium bug. Can be removed in the future.\n    if (proxy?.server !== 'per-context')\n      agent = createProxyAgent(proxy, requestUrl);\n\n    let maxRedirects = params.maxRedirects ?? (defaults.maxRedirects ?? 20);\n    maxRedirects = maxRedirects === 0 ? -1 : maxRedirects;\n\n    const options: SendRequestOptions = {\n      method,\n      headers,\n      agent,\n      maxRedirects,\n      ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, requestUrl.origin),\n      __testHookLookup: (params as any).__testHookLookup,\n    };\n    // rejectUnauthorized = undefined is treated as true in Node.js 12.\n    if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)\n      options.rejectUnauthorized = false;\n\n    const postData = serializePostData(params, headers);\n    if (postData)\n      setHeader(headers, 'content-length', String(postData.byteLength));\n    const fetchResponse = await this._sendRequestWithRetries(progress, requestUrl, options, postData, params.maxRetries);\n    const fetchUid = this._storeResponseBody(fetchResponse.body);\n    this.fetchLog.set(fetchUid, progress.metadata.log);\n    const failOnStatusCode = params.failOnStatusCode !== undefined ? params.failOnStatusCode : !!defaults.failOnStatusCode;\n    if (failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400)) {\n      let responseText = '';\n      if (fetchResponse.body.byteLength) {\n        let text = fetchResponse.body.toString('utf8');\n        if (text.length > 1000)\n          text = text.substring(0, 997) + '...';\n        responseText = `\\nResponse text:\\n${text}`;\n      }\n      throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}${responseText}`);\n    }\n    return { ...fetchResponse, fetchUid };\n  }\n\n  private _parseSetCookieHeader(responseUrl: string, setCookie: string[] | undefined): channels.NetworkCookie[] {\n    if (!setCookie)\n      return [];\n    const url = new URL(responseUrl);\n    // https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4\n    const defaultPath = '/' + url.pathname.substr(1).split('/').slice(0, -1).join('/');\n    const cookies: channels.NetworkCookie[] = [];\n    for (const header of setCookie) {\n      // Decode cookie value?\n      const cookie: channels.NetworkCookie | null = parseCookie(header);\n      if (!cookie)\n        continue;\n      // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.3\n      if (!cookie.domain)\n        cookie.domain = url.hostname;\n      else\n        assert(cookie.domain.startsWith('.') || !cookie.domain.includes('.'));\n      if (!domainMatches(url.hostname, cookie.domain!))\n        continue;\n      // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.4\n      if (!cookie.path || !cookie.path.startsWith('/'))\n        cookie.path = defaultPath;\n      cookies.push(cookie);\n    }\n    return cookies;\n  }\n\n  private async _updateRequestCookieHeader(progress: Progress, url: URL, headers: HeadersObject) {\n    if (getHeader(headers, 'cookie') !== undefined)\n      return;\n    const contextCookies = await progress.race(this._cookies(url));\n    // Browser context returns cookies with domain matching both .example.com and\n    // example.com. Those without leading dot are only sent when domain is strictly\n    // matching example.com, but not for sub.example.com.\n    const cookies = contextCookies.filter(c => new Cookie(c).matches(url));\n    if (cookies.length) {\n      const valueArray = cookies.map(c => `${c.name}=${c.value}`);\n      setHeader(headers, 'cookie', valueArray.join('; '));\n    }\n  }\n\n  private async _sendRequestWithRetries(progress: Progress, url: URL, options: SendRequestOptions, postData?: Buffer, maxRetries?: number): Promise<SendRequestResult>{\n    maxRetries ??= 0;\n    let backoff = 250;\n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        return await this._sendRequest(progress, url, options, postData);\n      } catch (e) {\n        if (isAbortError(e))\n          throw e;\n        e = rewriteOpenSSLErrorIfNeeded(e);\n        if (maxRetries === 0)\n          throw e;\n        if (i === maxRetries)\n          throw new Error(`Failed after ${i + 1} attempt(s): ${e}`);\n        // Retry on connection reset only.\n        if (e.code !== 'ECONNRESET')\n          throw e;\n        progress.log(`  Received ECONNRESET, will retry after ${backoff}ms.`);\n        await progress.wait(backoff);\n        backoff *= 2;\n      }\n    }\n    throw new Error('Unreachable');\n  }\n\n  private async _sendRequest(progress: Progress, url: URL, options: SendRequestOptions, postData?: Buffer): Promise<SendRequestResult>{\n    await this._updateRequestCookieHeader(progress, url, options.headers);\n\n    const requestCookies = getHeader(options.headers, 'cookie')?.split(';').map(p => {\n      const [name, value] = p.split('=').map(v => v.trim());\n      return { name, value };\n    }) || [];\n    const requestEvent: APIRequestEvent = {\n      url,\n      method: options.method!,\n      headers: options.headers,\n      cookies: requestCookies,\n      postData\n    };\n    this.emit(APIRequestContext.Events.Request, requestEvent);\n\n    let destroyRequest: (() => void) | undefined;\n    const resultPromise = new Promise<SendRequestResult>((fulfill, reject) => {\n      const requestConstructor: ((url: URL, options: http.RequestOptions, callback?: (res: http.IncomingMessage) => void) => http.ClientRequest)\n        = (url.protocol === 'https:' ? https : http).request;\n      // If we have a proxy agent already, do not override it.\n      const agent = options.agent || (url.protocol === 'https:' ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent);\n      const requestOptions = { ...options, agent };\n\n      const startAt = monotonicTime();\n      let reusedSocketAt: number | undefined;\n      let dnsLookupAt: number | undefined;\n      let tcpConnectionAt: number | undefined;\n      let tlsHandshakeAt: number | undefined;\n      let requestFinishAt: number | undefined;\n      let serverIPAddress: string | undefined;\n      let serverPort: number | undefined;\n\n      let securityDetails: har.SecurityDetails | undefined;\n\n      const listeners: RegisteredListener[] = [];\n\n      const request = requestConstructor(url, requestOptions as any, async response => {\n        const responseAt = monotonicTime();\n\n        const notifyRequestFinished = (body?: Buffer) => {\n          const endAt = monotonicTime();\n          // spec: http://www.softwareishard.com/blog/har-12-spec/#timings\n          const connectEnd = tlsHandshakeAt ?? tcpConnectionAt;\n          const timings: har.Timings = {\n            send: requestFinishAt! - startAt,\n            wait: responseAt - requestFinishAt!,\n            receive: endAt - responseAt,\n            dns: dnsLookupAt ? dnsLookupAt - startAt : -1,\n            connect: connectEnd ? connectEnd - startAt : -1, // \"If [ssl] is defined then the time is also included in the connect field \"\n            ssl: tlsHandshakeAt ? tlsHandshakeAt - tcpConnectionAt! : -1,\n            blocked: reusedSocketAt ? reusedSocketAt - startAt : -1,\n          };\n\n          const requestFinishedEvent: APIRequestFinishedEvent = {\n            requestEvent,\n            httpVersion: response.httpVersion,\n            statusCode: response.statusCode || 0,\n            statusMessage: response.statusMessage || '',\n            headers: response.headers,\n            rawHeaders: response.rawHeaders,\n            cookies,\n            body,\n            timings,\n            serverIPAddress,\n            serverPort,\n            securityDetails,\n          };\n          this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);\n        };\n        progress.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);\n        for (const [name, value] of Object.entries(response.headers))\n          progress.log(`  ${name}: ${value}`);\n\n        const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers['set-cookie']) ;\n        if (cookies.length) {\n          try {\n            await this._addCookies(cookies);\n          } catch (e) {\n            // Cookie value is limited by 4096 characters in the browsers. If setCookies failed,\n            // we try setting each cookie individually just in case only some of them are bad.\n            await Promise.all(cookies.map(c => this._addCookies([c]).catch(() => {})));\n          }\n        }\n\n        if (redirectStatus.includes(response.statusCode!) && options.maxRedirects >= 0) {\n          if (options.maxRedirects === 0) {\n            reject(new Error('Max redirect count exceeded'));\n            request.destroy();\n            return;\n          }\n          const headers = { ...options.headers };\n          removeHeader(headers, `cookie`);\n\n          // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)\n          const status = response.statusCode!;\n          let method = options.method!;\n          if ((status === 301 || status === 302) && method === 'POST' ||\n              status === 303 && !['GET', 'HEAD'].includes(method)) {\n            method = 'GET';\n            postData = undefined;\n            removeHeader(headers, `content-encoding`);\n            removeHeader(headers, `content-language`);\n            removeHeader(headers, `content-length`);\n            removeHeader(headers, `content-location`);\n            removeHeader(headers, `content-type`);\n          }\n\n\n          const redirectOptions: SendRequestOptions = {\n            method,\n            headers,\n            agent: options.agent,\n            maxRedirects: options.maxRedirects - 1,\n            ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, url.origin),\n            __testHookLookup: options.__testHookLookup,\n          };\n          // rejectUnauthorized = undefined is treated as true in node 12.\n          if (options.rejectUnauthorized === false)\n            redirectOptions.rejectUnauthorized = false;\n\n          // HTTP-redirect fetch step 4: If locationURL is null, then return response.\n          // Best-effort UTF-8 decoding, per spec it's US-ASCII only, but browsers are more lenient.\n          // Node.js parses it as Latin1 via std::v8::String, so we convert it to UTF-8.\n          const locationHeaderValue = Buffer.from(response.headers.location ?? '', 'latin1').toString('utf8');\n          if (locationHeaderValue) {\n            let locationURL;\n            try {\n              locationURL = new URL(locationHeaderValue, url);\n            } catch (error) {\n              reject(new Error(`uri requested responds with an invalid redirect URL: ${locationHeaderValue}`));\n              request.destroy();\n              return;\n            }\n\n            if (headers['host'])\n              headers['host'] = locationURL.host;\n\n            notifyRequestFinished();\n            fulfill(this._sendRequest(progress, locationURL, redirectOptions, postData));\n            request.destroy();\n            return;\n          }\n        }\n        if (response.statusCode === 401 && !getHeader(options.headers, 'authorization')) {\n          const auth = response.headers['www-authenticate'];\n          const credentials = this._getHttpCredentials(url);\n          if (auth?.trim().startsWith('Basic') && credentials) {\n            setBasicAuthorizationHeader(options.headers, credentials);\n            notifyRequestFinished();\n            fulfill(this._sendRequest(progress, url, options, postData));\n            request.destroy();\n            return;\n          }\n        }\n        response.on('aborted', () => reject(new Error('aborted')));\n\n        const chunks: Buffer[] = [];\n        const notifyBodyFinished = () => {\n          const body = Buffer.concat(chunks);\n          notifyRequestFinished(body);\n          fulfill({\n            url: response.url || url.toString(),\n            status: response.statusCode || 0,\n            statusText: response.statusMessage || '',\n            headers: toHeadersArray(response.rawHeaders),\n            body\n          });\n        };\n\n        let body: Readable = response;\n        let transform: Transform | undefined;\n        const encoding = response.headers['content-encoding'];\n        if (encoding === 'gzip' || encoding === 'x-gzip') {\n          transform = zlib.createGunzip({\n            flush: zlib.constants.Z_SYNC_FLUSH,\n            finishFlush: zlib.constants.Z_SYNC_FLUSH\n          });\n        } else if (encoding === 'br') {\n          transform = zlib.createBrotliDecompress({\n            flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n            finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n          });\n        } else if (encoding === 'deflate') {\n          transform = zlib.createInflate();\n        }\n        if (transform) {\n          // Brotli and deflate decompressors throw if the input stream is empty.\n          const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);\n          body = pipeline(response, emptyStreamTransform, transform, e => {\n            if (e)\n              reject(new Error(`failed to decompress '${encoding}' encoding: ${e.message}`));\n          });\n          body.on('error', e => reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`)));\n        } else {\n          body.on('error', reject);\n        }\n\n        body.on('data', chunk => chunks.push(chunk));\n        body.on('end', notifyBodyFinished);\n      });\n      request.on('error', reject);\n      destroyRequest = () => request.destroy();\n\n      listeners.push(\n          eventsHelper.addEventListener(this, APIRequestContext.Events.Dispose, () => {\n            reject(new Error('Request context disposed.'));\n            request.destroy();\n          })\n      );\n      request.on('close', () => eventsHelper.removeEventListeners(listeners));\n\n      request.on('socket', socket => {\n        if (request.reusedSocket) {\n          reusedSocketAt = monotonicTime();\n          return;\n        }\n\n        // happy eyeballs don't emit lookup and connect events, so we use our custom ones\n        const happyEyeBallsTimings = timingForSocket(socket);\n        dnsLookupAt = happyEyeBallsTimings.dnsLookupAt;\n        tcpConnectionAt = happyEyeBallsTimings.tcpConnectionAt;\n\n        // non-happy-eyeballs sockets\n        listeners.push(\n            eventsHelper.addEventListener(socket, 'lookup', () => { dnsLookupAt = monotonicTime(); }),\n            eventsHelper.addEventListener(socket, 'connect', () => { tcpConnectionAt = monotonicTime(); }),\n            eventsHelper.addEventListener(socket, 'secureConnect', () => {\n              tlsHandshakeAt = monotonicTime();\n\n              if (socket instanceof TLSSocket) {\n                const peerCertificate = socket.getPeerCertificate();\n                securityDetails = {\n                  protocol: socket.getProtocol() ?? undefined,\n                  subjectName: peerCertificate.subject.CN,\n                  validFrom: new Date(peerCertificate.valid_from).getTime() / 1000,\n                  validTo: new Date(peerCertificate.valid_to).getTime() / 1000,\n                  issuer: peerCertificate.issuer.CN\n                };\n              }\n            }),\n        );\n\n        serverIPAddress = socket.remoteAddress;\n        serverPort = socket.remotePort;\n      });\n      request.on('finish', () => { requestFinishAt = monotonicTime(); });\n\n      progress.log(`\u2192 ${options.method} ${url.toString()}`);\n      if (options.headers) {\n        for (const [name, value] of Object.entries(options.headers))\n          progress.log(`  ${name}: ${value}`);\n      }\n\n      if (postData)\n        request.write(postData);\n      request.end();\n    });\n\n    return progress.race(resultPromise).catch(error => {\n      destroyRequest?.();\n      throw error;\n    });\n  }\n\n  private _getHttpCredentials(url: URL) {\n    if (!this._defaultOptions().httpCredentials?.origin || url.origin.toLowerCase() === this._defaultOptions().httpCredentials?.origin?.toLowerCase())\n      return this._defaultOptions().httpCredentials;\n    return undefined;\n  }\n}\n\nclass SafeEmptyStreamTransform extends Transform {\n  private _receivedSomeData: boolean = false;\n  private _onEmptyStreamCallback: () => void;\n\n  constructor(onEmptyStreamCallback: () => void) {\n    super();\n    this._onEmptyStreamCallback = onEmptyStreamCallback;\n  }\n  override _transform(chunk: any, encoding: BufferEncoding, callback: TransformCallback): void {\n    this._receivedSomeData = true;\n    callback(null, chunk);\n  }\n  override _flush(callback: TransformCallback): void {\n    if (this._receivedSomeData)\n      callback(null);\n    else\n      this._onEmptyStreamCallback();\n  }\n}\n\nexport class BrowserContextAPIRequestContext extends APIRequestContext {\n  private readonly _context: BrowserContext;\n\n  constructor(context: BrowserContext) {\n    super(context);\n    this._context = context;\n    context.once(BrowserContext.Events.Close, () => this._disposeImpl());\n  }\n\n  override tracing() {\n    return this._context.tracing;\n  }\n\n  override async dispose(options: { reason?: string }) {\n    this._closeReason = options.reason;\n    this.fetchResponses.clear();\n  }\n\n  _defaultOptions(): FetchRequestOptions {\n    return {\n      userAgent: this._context._options.userAgent || this._context._browser.userAgent(),\n      extraHTTPHeaders: this._context._options.extraHTTPHeaders,\n      failOnStatusCode: undefined,\n      httpCredentials: this._context._options.httpCredentials,\n      proxy: this._context._options.proxy || this._context._browser.options.proxy,\n      ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,\n      baseURL: this._context._options.baseURL,\n      clientCertificates: this._context._options.clientCertificates,\n    };\n  }\n\n  async _addCookies(cookies: channels.NetworkCookie[]): Promise<void> {\n    await this._context.addCookies(cookies);\n  }\n\n  async _cookies(url: URL): Promise<channels.NetworkCookie[]> {\n    return await this._context.cookies(url.toString());\n  }\n\n  override async storageState(progress: Progress, indexedDB?: boolean): Promise<channels.APIRequestContextStorageStateResult> {\n    return this._context.storageState(progress, indexedDB);\n  }\n}\n\n\nexport class GlobalAPIRequestContext extends APIRequestContext {\n  private readonly _cookieStore: CookieStore = new CookieStore();\n  private readonly _options: FetchRequestOptions;\n  private readonly _origins: channels.OriginStorage[] | undefined;\n  private readonly _tracing: Tracing;\n\n  constructor(playwright: Playwright, options: channels.PlaywrightNewRequestOptions) {\n    super(playwright);\n    this.attribution.context = this;\n    if (options.storageState) {\n      this._origins = options.storageState.origins?.map(origin => ({ indexedDB: [], ...origin }));\n      this._cookieStore.addCookies(options.storageState.cookies || []);\n    }\n    verifyClientCertificates(options.clientCertificates);\n    this._options = {\n      baseURL: options.baseURL,\n      userAgent: options.userAgent || getUserAgent(),\n      extraHTTPHeaders: options.extraHTTPHeaders,\n      failOnStatusCode: !!options.failOnStatusCode,\n      ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,\n      maxRedirects: options.maxRedirects,\n      httpCredentials: options.httpCredentials,\n      clientCertificates: options.clientCertificates,\n      proxy: options.proxy,\n    };\n    this._tracing = new Tracing(this, options.tracesDir);\n  }\n\n  override tracing() {\n    return this._tracing;\n  }\n\n  override async dispose(options: { reason?: string }) {\n    this._closeReason = options.reason;\n    await this._tracing.flush();\n    await this._tracing.deleteTmpTracesDir();\n    this._disposeImpl();\n  }\n\n  _defaultOptions(): FetchRequestOptions {\n    return this._options;\n  }\n\n  async _addCookies(cookies: channels.NetworkCookie[]): Promise<void> {\n    this._cookieStore.addCookies(cookies);\n  }\n\n  async _cookies(url: URL): Promise<channels.NetworkCookie[]> {\n    return this._cookieStore.cookies(url);\n  }\n\n  override async storageState(progress: Progress, indexedDB = false): Promise<channels.APIRequestContextStorageStateResult> {\n    return {\n      cookies: this._cookieStore.allCookies(),\n      origins: (this._origins || []).map(origin => ({ ...origin, indexedDB: indexedDB ? origin.indexedDB : [] })),\n    };\n  }\n}\n\nfunction toHeadersArray(rawHeaders: string[]): types.HeadersArray {\n  const result: types.HeadersArray = [];\n  for (let i = 0; i < rawHeaders.length; i += 2)\n    result.push({ name: rawHeaders[i], value: rawHeaders[i + 1] });\n  return result;\n}\n\nconst redirectStatus = [301, 302, 303, 307, 308];\n\nfunction parseCookie(header: string): channels.NetworkCookie | null {\n  const raw = parseRawCookie(header);\n  if (!raw)\n    return null;\n  const cookie: channels.NetworkCookie = {\n    domain: '',\n    path: '',\n    expires: -1,\n    httpOnly: false,\n    secure: false,\n    // From https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite\n    // The cookie-sending behavior if SameSite is not specified is SameSite=Lax.\n    sameSite: 'Lax',\n    ...raw\n  };\n  return cookie;\n}\n\nfunction serializePostData(params: channels.APIRequestContextFetchParams, headers: HeadersObject): Buffer | undefined {\n  assert((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);\n  if (params.jsonData !== undefined) {\n    setHeader(headers, 'content-type', 'application/json', true);\n    return Buffer.from(params.jsonData, 'utf8');\n  } else if (params.formData) {\n    const searchParams = new URLSearchParams();\n    for (const { name, value } of params.formData)\n      searchParams.append(name, value);\n    setHeader(headers, 'content-type', 'application/x-www-form-urlencoded', true);\n    return Buffer.from(searchParams.toString(), 'utf8');\n  } else if (params.multipartData) {\n    const formData = new MultipartFormData();\n    for (const field of params.multipartData) {\n      if (field.file)\n        formData.addFileField(field.name, field.file);\n      else if (field.value)\n        formData.addField(field.name, field.value);\n    }\n    setHeader(headers, 'content-type', formData.contentTypeHeader(), true);\n    return formData.finish();\n  } else if (params.postData !== undefined) {\n    setHeader(headers, 'content-type', 'application/octet-stream', true);\n    return params.postData;\n  }\n  return undefined;\n}\n\nfunction setHeader(headers: { [name: string]: string }, name: string, value: string, keepExisting = false) {\n  const existing = Object.entries(headers).find(pair => pair[0].toLowerCase() === name.toLowerCase());\n  if (!existing)\n    headers[name] = value;\n  else if (!keepExisting)\n    headers[existing[0]] = value;\n}\n\nfunction getHeader(headers: HeadersObject, name: string) {\n  const existing = Object.entries(headers).find(pair => pair[0].toLowerCase() === name.toLowerCase());\n  return existing ? existing[1] : undefined;\n}\n\nfunction removeHeader(headers: { [name: string]: string }, name: string) {\n  delete headers[name];\n}\n\nfunction setBasicAuthorizationHeader(headers: { [name: string]: string }, credentials: HTTPCredentials) {\n  const { username, password } = credentials;\n  const encoded = Buffer.from(`${username || ''}:${password || ''}`).toString('base64');\n  setHeader(headers, 'authorization', `Basic ${encoded}`);\n}\n"],
  "mappings": "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",
  "names": ["https", "http", "body"]
}

{
  "version": 3,
  "sources": ["../../src/server/harBackend.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { createGuid } from './utils/crypto';\nimport { ZipFile } from './utils/zipFile';\n\nimport type { HeadersArray } from '../utils/isomorphic/types';\nimport type * as har from '@trace/har';\n\nconst redirectStatus = [301, 302, 303, 307, 308];\n\nexport class HarBackend {\n  readonly id: string;\n  private _harFile: har.HARFile;\n  private _zipFile: ZipFile | null;\n  private _baseDir: string | null;\n\n  constructor(harFile: har.HARFile, baseDir: string | null, zipFile: ZipFile | null) {\n    this.id = createGuid();\n    this._harFile = harFile;\n    this._baseDir = baseDir;\n    this._zipFile = zipFile;\n  }\n\n  async lookup(url: string, method: string, headers: HeadersArray, postData: Buffer | undefined, isNavigationRequest: boolean): Promise<{\n    action: 'error' | 'redirect' | 'fulfill' | 'noentry',\n    message?: string,\n    redirectURL?: string,\n    status?: number,\n    headers?: HeadersArray,\n    body?: Buffer\n  }> {\n    let entry;\n    try {\n      entry = await this._harFindResponse(url, method, headers, postData);\n    } catch (e) {\n      return { action: 'error', message: 'HAR error: ' + e.message };\n    }\n\n    if (!entry)\n      return { action: 'noentry' };\n\n    // If navigation is being redirected, restart it with the final url to ensure the document's url changes.\n    if (entry.request.url !== url && isNavigationRequest)\n      return { action: 'redirect', redirectURL: entry.request.url };\n\n    const response = entry.response;\n    try {\n      const buffer = await this._loadContent(response.content);\n      return {\n        action: 'fulfill',\n        status: response.status,\n        headers: response.headers,\n        body: buffer,\n      };\n    } catch (e) {\n      return { action: 'error', message: e.message };\n    }\n  }\n\n  private async _loadContent(content: { text?: string, encoding?: string, _file?: string }): Promise<Buffer> {\n    const file = content._file;\n    let buffer: Buffer;\n    if (file) {\n      if (this._zipFile)\n        buffer = await this._zipFile.read(file);\n      else\n        buffer = await fs.promises.readFile(path.resolve(this._baseDir!, file));\n    } else {\n      buffer = Buffer.from(content.text || '', content.encoding === 'base64' ? 'base64' : 'utf-8');\n    }\n    return buffer;\n  }\n\n  private async _harFindResponse(url: string, method: string, headers: HeadersArray, postData: Buffer | undefined): Promise<har.Entry | undefined> {\n    const harLog = this._harFile.log;\n    const visited = new Set<har.Entry>();\n    while (true) {\n      const entries: har.Entry[] = [];\n      for (const candidate of harLog.entries) {\n        if (candidate.request.url !== url || candidate.request.method !== method)\n          continue;\n        if (method === 'POST' && postData && candidate.request.postData) {\n          const buffer = await this._loadContent(candidate.request.postData);\n          if (!buffer.equals(postData)) {\n            const boundary = multipartBoundary(headers);\n            if (!boundary)\n              continue;\n            const candidataBoundary = multipartBoundary(candidate.request.headers);\n            if (!candidataBoundary)\n              continue;\n            // Try to match multipart/form-data ignoring boundary as it changes between requests.\n            if (postData.toString().replaceAll(boundary, '') !== buffer.toString().replaceAll(candidataBoundary, ''))\n              continue;\n          }\n        }\n        entries.push(candidate);\n      }\n\n      if (!entries.length)\n        return;\n\n      let entry = entries[0];\n\n      // Disambiguate using headers - then one with most matching headers wins.\n      if (entries.length > 1) {\n        const list: { candidate: har.Entry, matchingHeaders: number }[] = [];\n        for (const candidate of entries) {\n          const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);\n          list.push({ candidate, matchingHeaders });\n        }\n        list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);\n        entry = list[0].candidate;\n      }\n\n      if (visited.has(entry))\n        throw new Error(`Found redirect cycle for ${url}`);\n\n      visited.add(entry);\n\n      // Follow redirects.\n      const locationHeader = entry.response.headers.find(h => h.name.toLowerCase() === 'location');\n      if (redirectStatus.includes(entry.response.status) && locationHeader) {\n        const locationURL = new URL(locationHeader.value, url);\n        url = locationURL.toString();\n        if ((entry.response.status === 301 || entry.response.status === 302) && method === 'POST' ||\n          entry.response.status === 303 && !['GET', 'HEAD'].includes(method)) {\n          // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)\n          method = 'GET';\n        }\n        continue;\n      }\n\n      return entry;\n    }\n  }\n\n  dispose() {\n    this._zipFile?.close();\n  }\n}\n\nfunction countMatchingHeaders(harHeaders: har.Header[], headers: HeadersArray): number {\n  const set = new Set(headers.map(h => h.name.toLowerCase() + ':' + h.value));\n  let matches = 0;\n  for (const h of harHeaders) {\n    if (set.has(h.name.toLowerCase() + ':' + h.value))\n      ++matches;\n  }\n  return matches;\n}\n\nfunction multipartBoundary(headers: HeadersArray) {\n  const contentType = headers.find(h => h.name.toLowerCase() === 'content-type');\n  if (!contentType?.value.includes('multipart/form-data'))\n    return undefined;\n  const boundary = contentType.value.match(/boundary=(\\S+)/);\n  if (boundary)\n    return boundary[1];\n  return undefined;\n}\n"],
  "mappings": "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",
  "names": ["fs", "path"]
}

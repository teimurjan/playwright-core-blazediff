{
  "version": 3,
  "sources": ["../../src/server/accessibility.ts"],
  "sourcesContent": ["/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as dom from './dom';\nimport type * as channels from '@protocol/channels';\n\nexport interface AXNode {\n  isInteresting(insideControl: boolean): boolean;\n  isLeafNode(): boolean;\n  isControl(): boolean;\n  serialize(): channels.AXNode;\n  children(): Iterable<AXNode>;\n}\n\nexport class Accessibility {\n  private _getAXTree:  (needle?: dom.ElementHandle) => Promise<{tree: AXNode, needle: AXNode | null}>;\n  constructor(getAXTree: (needle?: dom.ElementHandle) => Promise<{tree: AXNode, needle: AXNode | null}>) {\n    this._getAXTree = getAXTree;\n  }\n\n  async snapshot(options: {\n    interestingOnly?: boolean;\n    root?: dom.ElementHandle;\n  } = {}): Promise<channels.AXNode | null> {\n    const {\n      interestingOnly = true,\n      root = null,\n    } = options;\n    const { tree, needle } = await this._getAXTree(root || undefined);\n    if (!interestingOnly) {\n      if (root)\n        return needle && serializeTree(needle)[0];\n      return serializeTree(tree)[0];\n    }\n\n    const interestingNodes: Set<AXNode> = new Set();\n    collectInterestingNodes(interestingNodes, tree, false);\n    if (root && (!needle || !interestingNodes.has(needle)))\n      return null;\n    return serializeTree(needle || tree, interestingNodes)[0];\n  }\n}\n\nfunction collectInterestingNodes(collection: Set<AXNode>, node: AXNode, insideControl: boolean) {\n  if (node.isInteresting(insideControl))\n    collection.add(node);\n  if (node.isLeafNode())\n    return;\n  insideControl = insideControl || node.isControl();\n  for (const child of node.children())\n    collectInterestingNodes(collection, child, insideControl);\n}\n\nfunction serializeTree(node: AXNode, whitelistedNodes?: Set<AXNode>): channels.AXNode[] {\n  const children: channels.AXNode[] = [];\n  for (const child of node.children())\n    children.push(...serializeTree(child, whitelistedNodes));\n\n  if (whitelistedNodes && !whitelistedNodes.has(node))\n    return children;\n\n  const serializedNode = node.serialize();\n  if (children.length)\n    serializedNode.children = children;\n  return [serializedNode];\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BO,MAAM,cAAc;AAAA,EAEzB,YAAY,WAA2F;AACrG,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAM,SAAS,UAGX,CAAC,GAAoC;AACvC,UAAM;AAAA,MACJ,kBAAkB;AAAA,MAClB,OAAO;AAAA,IACT,IAAI;AACJ,UAAM,EAAE,MAAM,OAAO,IAAI,MAAM,KAAK,WAAW,QAAQ,MAAS;AAChE,QAAI,CAAC,iBAAiB;AACpB,UAAI;AACF,eAAO,UAAU,cAAc,MAAM,EAAE,CAAC;AAC1C,aAAO,cAAc,IAAI,EAAE,CAAC;AAAA,IAC9B;AAEA,UAAM,mBAAgC,oBAAI,IAAI;AAC9C,4BAAwB,kBAAkB,MAAM,KAAK;AACrD,QAAI,SAAS,CAAC,UAAU,CAAC,iBAAiB,IAAI,MAAM;AAClD,aAAO;AACT,WAAO,cAAc,UAAU,MAAM,gBAAgB,EAAE,CAAC;AAAA,EAC1D;AACF;AAEA,SAAS,wBAAwB,YAAyB,MAAc,eAAwB;AAC9F,MAAI,KAAK,cAAc,aAAa;AAClC,eAAW,IAAI,IAAI;AACrB,MAAI,KAAK,WAAW;AAClB;AACF,kBAAgB,iBAAiB,KAAK,UAAU;AAChD,aAAW,SAAS,KAAK,SAAS;AAChC,4BAAwB,YAAY,OAAO,aAAa;AAC5D;AAEA,SAAS,cAAc,MAAc,kBAAmD;AACtF,QAAM,WAA8B,CAAC;AACrC,aAAW,SAAS,KAAK,SAAS;AAChC,aAAS,KAAK,GAAG,cAAc,OAAO,gBAAgB,CAAC;AAEzD,MAAI,oBAAoB,CAAC,iBAAiB,IAAI,IAAI;AAChD,WAAO;AAET,QAAM,iBAAiB,KAAK,UAAU;AACtC,MAAI,SAAS;AACX,mBAAe,WAAW;AAC5B,SAAO,CAAC,cAAc;AACxB;",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../src/server/recorder/chat.ts"],
  "sourcesContent": ["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WebSocketTransport } from '../transport';\n\nimport type { ConnectionTransport, ProtocolResponse } from '../transport';\n\nexport type ChatMessage = {\n  content: string;\n  user: 'user' | 'assistant';\n};\n\nexport class Chat {\n  private _history: ChatMessage[] = [];\n  private _connectionPromise: Promise<Connection> | undefined;\n  private _chatSinks = new Map<string, (chunk: string) => void>();\n  private _wsEndpoint: string;\n\n  constructor(wsEndpoint: string) {\n    this._wsEndpoint =  wsEndpoint;\n  }\n\n  clearHistory() {\n    this._history = [];\n  }\n\n  async post<T>(prompt: string): Promise<T | null> {\n    await this._append('user', prompt);\n    let text = await asString(await this._post());\n    if (text.startsWith('```json') && text.endsWith('```'))\n      text = text.substring('```json'.length, text.length - '```'.length);\n    for (let i = 0; i < 3; ++i) {\n      try {\n        return JSON.parse(text);\n      } catch (e) {\n        await this._append('user', String(e));\n      }\n    }\n    throw new Error('Failed to parse response: ' + text);\n  }\n\n  private async _append(user: ChatMessage['user'], content: string) {\n    this._history.push({ user, content });\n  }\n\n  private async _connection(): Promise<Connection> {\n    if (!this._connectionPromise) {\n      this._connectionPromise = WebSocketTransport.connect(undefined, this._wsEndpoint).then(transport => {\n        return new Connection(transport, (method, params) => this._dispatchEvent(method, params), () => {});\n      });\n    }\n    return this._connectionPromise;\n  }\n\n  private _dispatchEvent(method: string, params: any) {\n    if (method === 'chatChunk') {\n      const { chatId, chunk } = params;\n      const chunkSink = this._chatSinks.get(chatId)!;\n      chunkSink(chunk);\n      if (!chunk)\n        this._chatSinks.delete(chatId);\n    }\n  }\n\n  private async _post(): Promise<AsyncIterable<string>> {\n    const connection = await this._connection();\n    const result = await connection.send('chat', { history: this._history });\n    const { chatId } = result;\n    const { iterable, addChunk } = iterablePump();\n    this._chatSinks.set(chatId, addChunk);\n    return iterable;\n  }\n}\n\nexport async function asString(stream: AsyncIterable<string>): Promise<string> {\n  let result = '';\n  for await (const chunk of stream)\n    result += chunk;\n  return result;\n}\n\ntype ChunkIterator = {\n  iterable: AsyncIterable<string>;\n  addChunk: (chunk: string) => void;\n};\n\nfunction iterablePump(): ChunkIterator {\n  let controller: ReadableStreamDefaultController<string>;\n  const stream = new ReadableStream<string>({ start: c => controller = c });\n\n  const iterable = (async function* () {\n    const reader = stream.getReader();\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        break;\n      yield value!;\n    }\n  })();\n\n  return {\n    iterable,\n    addChunk: chunk => {\n      if (chunk)\n        controller.enqueue(chunk);\n      else\n        controller.close();\n    }\n  };\n}\n\nclass Connection {\n  private readonly _transport: ConnectionTransport;\n  private _lastId = 0;\n  private _closed = false;\n  private _pending = new Map<number, { resolve: (result: any) => void; reject: (error: any) => void; }>();\n  private _onEvent: (method: string, params: any) => void;\n  private _onClose: () => void;\n\n  constructor(transport: ConnectionTransport, onEvent: (method: string, params: any) => void, onClose: () => void) {\n    this._transport = transport;\n    this._onEvent = onEvent;\n    this._onClose = onClose;\n    this._transport.onmessage = this._dispatchMessage.bind(this);\n    this._transport.onclose = this._close.bind(this);\n  }\n\n  send(method: string, params: any): Promise<any> {\n    const id = this._lastId++;\n    const message = { id, method, params };\n    this._transport.send(message);\n    return new Promise((resolve, reject) => {\n      this._pending.set(id, { resolve, reject });\n    });\n  }\n\n  private _dispatchMessage(message: ProtocolResponse) {\n    if (message.id === undefined) {\n      this._onEvent(message.method!, message.params);\n      return;\n    }\n\n    const callback = this._pending.get(message.id);\n    this._pending.delete(message.id);\n    if (!callback)\n      return;\n\n    if (message.error) {\n      callback.reject(new Error(message.error.message));\n      return;\n    }\n    callback.resolve(message.result);\n  }\n\n  _close() {\n    this._closed = true;\n    this._transport.onmessage = undefined;\n    this._transport.onclose = undefined;\n    for (const { reject } of this._pending.values())\n      reject(new Error('Connection closed'));\n    this._onClose();\n  }\n\n  isClosed() {\n    return this._closed;\n  }\n\n  close() {\n    if (!this._closed)\n      this._transport.close();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
